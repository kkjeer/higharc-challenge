{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { EventGroup, getId } from '../../Utilities';\nimport { KeytipEvents } from '../../utilities/keytips/KeytipConstants';\n/**\n * This class is responsible for handling registering, updating, and unregistering of keytips\n */\n\nvar KeytipManager =\n/** @class */\nfunction () {\n  function KeytipManager() {\n    this.keytips = {};\n    this.persistedKeytips = {};\n    this.sequenceMapping = {}; // This is (and should be) updated and kept in sync\n    // with the inKeytipMode in KeytipLayer.\n\n    this.inKeytipMode = false; // Boolean that gets checked before entering keytip mode by the KeytipLayer\n    // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)\n\n    this.shouldEnterKeytipMode = true; // Boolean to indicate whether to delay firing an event to update subscribers of\n    // keytip data changed.\n\n    this.delayUpdatingKeytipChange = false;\n  }\n  /**\n   * Static function to get singleton KeytipManager instance\n   *\n   * @returns Singleton KeytipManager instance\n   */\n\n\n  KeytipManager.getInstance = function () {\n    return this._instance;\n  };\n  /**\n   * Initialization code to set set parameters to define\n   * how the KeytipManager handles keytip data.\n   *\n   * @param delayUpdatingKeytipChange - T/F if we should delay notifiying keytip subscribers\n   * of keytip changes\n   */\n\n\n  KeytipManager.prototype.init = function (delayUpdatingKeytipChange) {\n    this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;\n  };\n  /**\n   * Registers a keytip\n   *\n   * @param keytipProps - Keytip to register\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   * @returns Unique ID for this keytip\n   */\n\n\n  KeytipManager.prototype.register = function (keytipProps, persisted) {\n    if (persisted === void 0) {\n      persisted = false;\n    }\n\n    var props = keytipProps;\n\n    if (!persisted) {\n      // Add the overflowSetSequence if necessary\n      props = this.addParentOverflow(keytipProps);\n      this.sequenceMapping[props.keySequences.toString()] = props;\n    } // Create a unique keytip\n\n\n    var uniqueKeytip = this._getUniqueKtp(props); // Add to dictionary\n\n\n    persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip; // We only want to add something new if we are currently showing keytip mode\n\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;\n      EventGroup.raise(this, event_1, {\n        keytip: props,\n        uniqueID: uniqueKeytip.uniqueID\n      });\n    }\n\n    return uniqueKeytip.uniqueID;\n  };\n  /**\n   * Update a keytip\n   *\n   * @param keytipProps - Keytip to update\n   * @param uniqueID - Unique ID of this keytip\n   */\n\n\n  KeytipManager.prototype.update = function (keytipProps, uniqueID) {\n    var newKeytipProps = this.addParentOverflow(keytipProps);\n\n    var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);\n\n    var oldKeyTip = this.keytips[uniqueID];\n\n    if (oldKeyTip) {\n      // Update everything except 'visible'\n      uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible; // Update keytip in this.keytips\n\n      this.keytips[uniqueID] = uniqueKeytip; // Update the sequence to be up to date\n\n      delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];\n      this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip; // Raise event only if we are currently in keytip mode\n\n      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n        EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {\n          keytip: uniqueKeytip.keytip,\n          uniqueID: uniqueKeytip.uniqueID\n        });\n      }\n    }\n  };\n  /**\n   * Unregisters a keytip\n   *\n   * @param keytipToRemove - IKeytipProps of the keytip to remove\n   * @param uniqueID - Unique ID of this keytip\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   */\n\n\n  KeytipManager.prototype.unregister = function (keytipToRemove, uniqueID, persisted) {\n    if (persisted === void 0) {\n      persisted = false;\n    }\n\n    persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];\n    !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];\n    var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED; // Update keytips only if we're in keytip mode\n\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      EventGroup.raise(this, event, {\n        keytip: keytipToRemove,\n        uniqueID: uniqueID\n      });\n    }\n  };\n  /**\n   * Manual call to enter keytip mode\n   */\n\n\n  KeytipManager.prototype.enterKeytipMode = function () {\n    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);\n  };\n  /**\n   * Manual call to exit keytip mode\n   */\n\n\n  KeytipManager.prototype.exitKeytipMode = function () {\n    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);\n  };\n  /**\n   * Gets all IKeytipProps from this.keytips\n   *\n   * @returns All keytips stored in the manager\n   */\n\n\n  KeytipManager.prototype.getKeytips = function () {\n    var _this = this;\n\n    return Object.keys(this.keytips).map(function (key) {\n      return _this.keytips[key].keytip;\n    });\n  };\n  /**\n   * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it\n   *\n   * @param keytipProps - Keytip props to add overflowSetSequence to if necessary\n   * @returns - Modified keytip props, if needed to be modified\n   */\n\n\n  KeytipManager.prototype.addParentOverflow = function (keytipProps) {\n    var fullSequence = __spreadArray([], keytipProps.keySequences);\n\n    fullSequence.pop();\n\n    if (fullSequence.length !== 0) {\n      var parentKeytip = this.sequenceMapping[fullSequence.toString()];\n\n      if (parentKeytip && parentKeytip.overflowSetSequence) {\n        return __assign(__assign({}, keytipProps), {\n          overflowSetSequence: parentKeytip.overflowSetSequence\n        });\n      }\n    }\n\n    return keytipProps;\n  };\n  /**\n   * Public function to bind for overflow items that have a submenu\n   */\n\n\n  KeytipManager.prototype.menuExecute = function (overflowButtonSequences, keytipSequences) {\n    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {\n      overflowButtonSequences: overflowButtonSequences,\n      keytipSequences: keytipSequences\n    });\n  };\n  /**\n   * Creates an IUniqueKeytip object\n   *\n   * @param keytipProps - IKeytipProps\n   * @param uniqueID - Unique ID, will default to the next unique ID if not passed\n   * @returns IUniqueKeytip object\n   */\n\n\n  KeytipManager.prototype._getUniqueKtp = function (keytipProps, uniqueID) {\n    if (uniqueID === void 0) {\n      uniqueID = getId();\n    }\n\n    return {\n      keytip: __assign({}, keytipProps),\n      uniqueID: uniqueID\n    };\n  };\n\n  KeytipManager._instance = new KeytipManager();\n  return KeytipManager;\n}();\n\nexport { KeytipManager };","map":{"version":3,"sources":["utilities/keytips/KeytipManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventGroup, getId } from '../../Utilities';\nimport { KeytipEvents } from '../../utilities/keytips/KeytipConstants';\nimport type { IKeytipProps } from '../../Keytip';\n\nexport interface IUniqueKeytip {\n  uniqueID: string;\n  keytip: IKeytipProps;\n}\n\n/**\n * This class is responsible for handling registering, updating, and unregistering of keytips\n */\nexport class KeytipManager {\n  private static _instance: KeytipManager = new KeytipManager();\n\n  public keytips: { [key: string]: IUniqueKeytip } = {};\n  public persistedKeytips: { [key: string]: IUniqueKeytip } = {};\n  public sequenceMapping: { [key: string]: IKeytipProps } = {};\n\n  // This is (and should be) updated and kept in sync\n  // with the inKeytipMode in KeytipLayer.\n  public inKeytipMode = false;\n\n  // Boolean that gets checked before entering keytip mode by the KeytipLayer\n  // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)\n  public shouldEnterKeytipMode = true;\n\n  // Boolean to indicate whether to delay firing an event to update subscribers of\n  // keytip data changed.\n  public delayUpdatingKeytipChange = false;\n\n  /**\n   * Static function to get singleton KeytipManager instance\n   *\n   * @returns Singleton KeytipManager instance\n   */\n  public static getInstance(): KeytipManager {\n    return this._instance;\n  }\n\n  /**\n   * Initialization code to set set parameters to define\n   * how the KeytipManager handles keytip data.\n   *\n   * @param delayUpdatingKeytipChange - T/F if we should delay notifiying keytip subscribers\n   * of keytip changes\n   */\n  public init(delayUpdatingKeytipChange: boolean) {\n    this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;\n  }\n\n  /**\n   * Registers a keytip\n   *\n   * @param keytipProps - Keytip to register\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   * @returns Unique ID for this keytip\n   */\n  public register(keytipProps: IKeytipProps, persisted: boolean = false): string {\n    let props: IKeytipProps = keytipProps;\n    if (!persisted) {\n      // Add the overflowSetSequence if necessary\n      props = this.addParentOverflow(keytipProps);\n      this.sequenceMapping[props.keySequences.toString()] = props;\n    }\n    // Create a unique keytip\n    const uniqueKeytip: IUniqueKeytip = this._getUniqueKtp(props);\n    // Add to dictionary\n    persisted\n      ? (this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip)\n      : (this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip);\n\n    // We only want to add something new if we are currently showing keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;\n      EventGroup.raise(this, event, {\n        keytip: props,\n        uniqueID: uniqueKeytip.uniqueID,\n      });\n    }\n\n    return uniqueKeytip.uniqueID;\n  }\n\n  /**\n   * Update a keytip\n   *\n   * @param keytipProps - Keytip to update\n   * @param uniqueID - Unique ID of this keytip\n   */\n  public update(keytipProps: IKeytipProps, uniqueID: string): void {\n    const newKeytipProps = this.addParentOverflow(keytipProps);\n    const uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);\n    const oldKeyTip = this.keytips[uniqueID];\n    if (oldKeyTip) {\n      // Update everything except 'visible'\n      uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;\n      // Update keytip in this.keytips\n      this.keytips[uniqueID] = uniqueKeytip;\n\n      // Update the sequence to be up to date\n      delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];\n      this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;\n\n      // Raise event only if we are currently in keytip mode\n      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n        EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {\n          keytip: uniqueKeytip.keytip,\n          uniqueID: uniqueKeytip.uniqueID,\n        });\n      }\n    }\n  }\n\n  /**\n   * Unregisters a keytip\n   *\n   * @param keytipToRemove - IKeytipProps of the keytip to remove\n   * @param uniqueID - Unique ID of this keytip\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   */\n  public unregister(keytipToRemove: IKeytipProps, uniqueID: string, persisted: boolean = false): void {\n    persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];\n    !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];\n\n    const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;\n    // Update keytips only if we're in keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      EventGroup.raise(this, event, {\n        keytip: keytipToRemove,\n        uniqueID: uniqueID,\n      });\n    }\n  }\n\n  /**\n   * Manual call to enter keytip mode\n   */\n  public enterKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);\n  }\n\n  /**\n   * Manual call to exit keytip mode\n   */\n  public exitKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);\n  }\n\n  /**\n   * Gets all IKeytipProps from this.keytips\n   *\n   * @returns All keytips stored in the manager\n   */\n  public getKeytips(): IKeytipProps[] {\n    return Object.keys(this.keytips).map(key => this.keytips[key].keytip);\n  }\n\n  /**\n   * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it\n   *\n   * @param keytipProps - Keytip props to add overflowSetSequence to if necessary\n   * @returns - Modified keytip props, if needed to be modified\n   */\n  public addParentOverflow(keytipProps: IKeytipProps): IKeytipProps {\n    const fullSequence = [...keytipProps.keySequences];\n    fullSequence.pop();\n    if (fullSequence.length !== 0) {\n      const parentKeytip = this.sequenceMapping[fullSequence.toString()];\n      if (parentKeytip && parentKeytip.overflowSetSequence) {\n        return {\n          ...keytipProps,\n          overflowSetSequence: parentKeytip.overflowSetSequence,\n        };\n      }\n    }\n    return keytipProps;\n  }\n\n  /**\n   * Public function to bind for overflow items that have a submenu\n   */\n  public menuExecute(overflowButtonSequences: string[], keytipSequences: string[]) {\n    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {\n      overflowButtonSequences,\n      keytipSequences,\n    });\n  }\n\n  /**\n   * Creates an IUniqueKeytip object\n   *\n   * @param keytipProps - IKeytipProps\n   * @param uniqueID - Unique ID, will default to the next unique ID if not passed\n   * @returns IUniqueKeytip object\n   */\n  private _getUniqueKtp(keytipProps: IKeytipProps, uniqueID: string = getId()): IUniqueKeytip {\n    return { keytip: { ...keytipProps }, uniqueID };\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}