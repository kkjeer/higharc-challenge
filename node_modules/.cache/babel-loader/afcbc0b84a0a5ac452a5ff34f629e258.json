{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\n\nfunction _createPositionData(targetEdge, alignmentEdge, isAuto) {\n  return {\n    targetEdge: targetEdge,\n    alignmentEdge: alignmentEdge,\n    isAuto: isAuto\n  };\n} // Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\n\n\nvar DirectionalDictionary = (_a = {}, _a[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, undefined, true), _a[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, undefined, true), _a[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a);\n\nfunction _isRectangleWithinBounds(rect, boundingRect) {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\n\n\nfunction _getOutOfBoundsEdges(rect, boundingRect) {\n  var outOfBounds = [];\n\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n\n  return outOfBounds;\n}\n\nfunction _getEdgeValue(rect, edge) {\n  return rect[RectangleEdge[edge]];\n}\n\nfunction _setEdgeValue(rect, edge, value) {\n  rect[RectangleEdge[edge]] = value;\n  return rect;\n}\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\n\n\nfunction _getCenterValue(rect, edge) {\n  var edges = _getFlankingEdges(edge);\n\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\n\n\nfunction _getRelativeEdgeValue(edge, value) {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\n\nfunction _getRelativeRectEdgeValue(edge, rect) {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\n\nfunction _getRelativeEdgeDifference(rect, hostRect, edge) {\n  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n * if maintainSize is set to false, it will only adjust the specified edge value\n */\n\n\nfunction _moveEdge(rect, edge, newValue, maintainSize) {\n  if (maintainSize === void 0) {\n    maintainSize = true;\n  }\n\n  var difference = _getEdgeValue(rect, edge) - newValue;\n\n  var returnRect = _setEdgeValue(rect, edge, newValue);\n\n  if (maintainSize) {\n    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  }\n\n  return returnRect;\n}\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\n\n\nfunction _alignEdges(rect, target, edge, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\n\n\nfunction _alignOppositeEdges(rect, target, targetEdge, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var oppositeEdge = targetEdge * -1;\n\n  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\n\n\nfunction _isEdgeInBounds(rect, bounds, edge) {\n  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n/**\n * Returns a measure of how much a rectangle is out of bounds for a given alignment;\n * this can be used to compare which rectangle is more or less out of bounds.\n * A value of 0 means the rectangle is entirely in bounds\n */\n\n\nfunction _getOutOfBoundsDegree(rect, bounds) {\n  var breakingEdges = _getOutOfBoundsEdges(rect, bounds);\n\n  var total = 0;\n\n  for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {\n    var edge = breakingEdges_1[_i];\n    total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);\n  }\n\n  return total;\n}\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the least bad option should be returned.\n */\n\n\nfunction _flipToFit(rect, target, bounding, positionData, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var directions = [RectangleEdge.left, RectangleEdge.right, RectangleEdge.bottom, RectangleEdge.top]; // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n\n  var currentEstimate = rect;\n  var currentEdge = positionData.targetEdge;\n  var currentAlignment = positionData.alignmentEdge; // keep track of least bad option, in case no sides fit\n\n  var oobDegree;\n  var bestEdge = currentEdge;\n  var bestAlignment = currentAlignment; // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n\n  for (var i = 0; i < 4; i++) {\n    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      // update least-bad edges\n      var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);\n\n      if (!oobDegree || currentOOBDegree < oobDegree) {\n        oobDegree = currentOOBDegree;\n        bestEdge = currentEdge;\n        bestAlignment = currentAlignment;\n      }\n\n      directions.splice(directions.indexOf(currentEdge), 1);\n\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n\n        currentEstimate = _estimatePosition(rect, target, {\n          targetEdge: currentEdge,\n          alignmentEdge: currentAlignment\n        }, gap);\n      }\n    } else {\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment\n      };\n    }\n  } // nothing fits, use least-bad option\n\n\n  currentEstimate = _estimatePosition(rect, target, {\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment\n  }, gap);\n  return {\n    elementRectangle: currentEstimate,\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment\n  };\n}\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when `alignTargetEdge` is specified.\n */\n\n\nfunction _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {\n  var alignmentEdge = elementEstimate.alignmentEdge,\n      targetEdge = elementEstimate.targetEdge,\n      elementRectangle = elementEstimate.elementRectangle;\n  var oppositeEdge = alignmentEdge * -1;\n\n  var newEstimate = _estimatePosition(elementRectangle, target, {\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge\n  }, gap, coverTarget);\n\n  return {\n    elementRectangle: newEstimate,\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge\n  };\n}\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\n\n\nfunction _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var alignmentEdge = positionData.alignmentEdge,\n      alignTargetEdge = positionData.alignTargetEdge;\n  var elementEstimate = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: alignmentEdge\n  };\n\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);\n  }\n\n  var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding); // if directionalHintFixed is specified, we need to force the target edge to not change\n  // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite\n\n\n  var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;\n\n  if (outOfBounds.length > 0) {\n    if (alignTargetEdge) {\n      // The edge opposite to the alignment edge might be out of bounds.\n      // Flip alignment to see if we can get it within bounds.\n      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n        var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n\n        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n          return flippedElementEstimate;\n        } else {\n          // If the flipped elements edges are still out of bounds, try nudging it.\n          elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);\n        }\n      } else {\n        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n      }\n    } else {\n      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n    }\n  }\n\n  return elementEstimate;\n}\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n * @param preserveEdge - Specify an edge that should not be modified\n */\n\n\nfunction _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {\n  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {\n    var direction = outOfBoundsEdges_1[_i];\n    var edgeAttempt = void 0; // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge\n    // this is because _alignEdges will move the opposite edge\n\n    if (preserveEdge && preserveEdge === direction * -1) {\n      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);\n      elementEstimate.forcedInBounds = true;\n    } else {\n      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n\n      var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1); // only update estimate if the attempt didn't break out of the opposite bounding edge\n\n\n      if (!inBounds) {\n        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);\n        elementEstimate.forcedInBounds = true;\n      }\n    }\n\n    elementEstimate.elementRectangle = edgeAttempt;\n  }\n\n  return elementEstimate;\n}\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\n\n\nfunction _centerEdgeToPoint(rect, edge, point) {\n  var positiveEdge = _getFlankingEdges(edge).positiveEdge;\n\n  var elementMiddle = _getCenterValue(rect, edge);\n\n  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\n\n\nfunction _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);\n  var alignmentEdge = positionData.alignmentEdge,\n      targetEdge = positionData.targetEdge;\n  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget ? _alignEdges(estimatedElementPosition, target, targetEdge, gap) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap); // if no alignment edge is provided it's supposed to be centered.\n\n  if (!alignmentEdge) {\n    var targetMiddlePoint = _getCenterValue(target, targetEdge);\n\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n\n  return estimatedElementPosition;\n}\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\n\n\nfunction _getFlankingEdges(edge) {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom\n    };\n  }\n}\n/**\n * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\n\n\nfunction _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {\n  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {\n    return returnEdge * -1;\n  }\n\n  return returnEdge;\n}\n/**\n * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds\n * @param elementRectangle The rectangle whose edge we are considering\n * @param bounds The rectangle marking the bounds\n * @param edge The target edge we're considering\n * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds\n */\n\n\nfunction _isEdgeOnBounds(elementRectangle, edge, bounds) {\n  return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);\n}\n/**\n * Finalizes the element position based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.\n */\n\n\nfunction _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {\n  var returnValue = {};\n\n  var hostRect = _getRectangleFromElement(hostElement);\n\n  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge; // If we are finalizing the return edge, choose the edge such that we grow away from the bounds\n  // If we are not finalizing the return edge but the opposite edge is flush against the bounds,\n  // choose that as the anchor edge so the element rect can grow away from the bounds' edge\n  // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow\n  // in the usual direction\n\n  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n\n  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge); // if the positioned element will still overflow, return all four edges with in-bounds values\n\n  if (forceWithinBounds) {\n    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);\n    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);\n  }\n\n  return returnValue;\n} // Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\n\n\nfunction _calculateActualBeakWidthInPixels(beakWidth) {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\n\n\nfunction _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {\n  if (directionalHint === void 0) {\n    directionalHint = DirectionalHint.bottomAutoEdge;\n  }\n\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge\n    };\n  }\n\n  var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);\n\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n\n  return positionInformation;\n}\n/**\n * Gets the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\n\n\nfunction _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\n\nfunction getClosestEdge(targetEdge, target, boundingRect) {\n  var targetCenter = _getCenterValue(target, targetEdge);\n\n  var boundingCenter = _getCenterValue(boundingRect, targetEdge);\n\n  var _a = _getFlankingEdges(targetEdge),\n      positiveEdge = _a.positiveEdge,\n      negativeEdge = _a.negativeEdge;\n\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\n\nfunction _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {\n  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);\n\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge\n    };\n  } else {\n    return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);\n  }\n}\n\nfunction _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {\n  var targetEdge = elementPosition.targetEdge * -1; // The \"host\" element that we will use to help position the beak.\n\n  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);\n  var returnValue = {};\n\n  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds); // only show the beak if the callout is not fully covering the target\n\n\n  var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);\n\n  var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n  return {\n    elementPosition: __assign({}, returnValue),\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge: targetEdge,\n    hideBeak: !showBeak\n  };\n}\n\nfunction _positionBeak(beakWidth, elementPosition) {\n  var target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n\n  var _a = _getFlankingEdges(elementPosition.targetEdge),\n      positiveEdge = _a.positiveEdge,\n      negativeEdge = _a.negativeEdge;\n\n  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n\n  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);\n  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));\n\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n\n  return beakPosition;\n}\n\nfunction _getRectangleFromElement(element) {\n  var clientRect = element.getBoundingClientRect();\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\n\nfunction _getRectangleFromIRect(rect) {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\n\nfunction _getTargetRect(bounds, target) {\n  var targetRectangle;\n\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!target.preventDefault) {\n      var ev = target;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY); // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!target.getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target); // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      var rectOrPoint = target; // eslint-disable-next-line deprecation/deprecation\n\n      var left = rectOrPoint.left || rectOrPoint.x; // eslint-disable-next-line deprecation/deprecation\n\n      var top_1 = rectOrPoint.top || rectOrPoint.y;\n      var right = rectOrPoint.right || left;\n      var bottom = rectOrPoint.bottom || top_1;\n      targetRectangle = new Rectangle(left, right, top_1, bottom);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {\n        var direction = outOfBounds_1[_i];\n        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n\n  return targetRectangle;\n}\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\n\n\nfunction _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {\n  var maxHeight = 0;\n  var directionalHint = DirectionalDictionary[targetEdge]; // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n\n  var target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\n\nfunction _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {\n  var gap = props.gapSpace ? props.gapSpace : 0;\n\n  var targetRect = _getTargetRect(boundingRect, props.target);\n\n  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);\n\n  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);\n\n  return __assign(__assign({}, positionedElement), {\n    targetRectangle: targetRect\n  });\n}\n\nfunction _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {\n  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);\n\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge\n  };\n}\n\nfunction _positionElement(props, hostElement, elementToPosition, previousPositions) {\n  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  var positionedElement = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);\n\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\n\nfunction _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {\n  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\n  var positionProps = props;\n  positionProps.gapSpace = gap;\n  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);\n\n  var beakPositioned = _positionBeak(beakWidth, positionedElement);\n\n  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);\n\n  return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), {\n    beakPosition: finalizedBeakPosition\n  });\n}\n\nfunction _positionCard(props, hostElement, callout, previousPositions) {\n  return _positionCallout(props, hostElement, callout, previousPositions, true);\n} // END PRIVATE FUNCTIONS\n\n\nexport var __positioningTestPackage = {\n  _finalizePositionData: _finalizePositionData,\n  _finalizeBeakPosition: _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels: _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds: _positionElementWithinBounds,\n  _positionBeak: _positionBeak,\n  _getPositionData: _getPositionData,\n  _getMaxHeightFromTargetRectangle: _getMaxHeightFromTargetRectangle\n};\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\n\nexport function positionElement(props, hostElement, elementToPosition, previousPositions) {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions);\n}\nexport function positionCallout(props, hostElement, elementToPosition, previousPositions) {\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions);\n}\nexport function positionCard(props, hostElement, elementToPosition, previousPositions) {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions);\n}\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\n\nexport function getMaxHeight(target, targetEdge, gapSpace, bounds, coverTarget) {\n  if (gapSpace === void 0) {\n    gapSpace = 0;\n  }\n\n  var mouseTarget = target;\n  var elementTarget = target;\n  var rectOrPointTarget = target;\n  var targetRect;\n  var boundingRectangle = bounds ? _getRectangleFromIRect(bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight); // eslint-disable-next-line deprecation/deprecation\n\n  var left = rectOrPointTarget.left || rectOrPointTarget.x; // eslint-disable-next-line deprecation/deprecation\n\n  var top = rectOrPointTarget.top || rectOrPointTarget.y;\n  var right = rectOrPointTarget.right || left;\n  var bottom = rectOrPointTarget.bottom || top; // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, right, top, bottom);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\n\nexport function getOppositeEdge(edge) {\n  return edge * -1;\n}\n\nfunction _getBoundsFromTargetWindow(target, targetWindow) {\n  var segments = undefined;\n\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  } // Identify if we're dealing with single screen scenarios.\n\n\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight\n    };\n  } // Logic for determining dual screen scenarios.\n\n\n  var x = 0;\n  var y = 0; // If the target is an Element get coordinates for its center.\n\n  if (target !== null && !!target.getBoundingClientRect) {\n    var clientRect = target.getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  } // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = target.left || target.x; // eslint-disable-next-line deprecation/deprecation\n\n    y = target.top || target.y;\n  }\n\n  var bounds = {\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    width: 0,\n    height: 0\n  }; // Define which window segment are the coordinates in and calculate bounds based on that.\n\n  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n    var segment = segments_1[_i];\n\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height\n      };\n    }\n  }\n\n  return bounds;\n}\n\nexport function getBoundsFromTargetWindow(target, targetWindow) {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}","map":{"version":3,"sources":["utilities/positioning/positioning.ts"],"names":[],"mappings":"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","sourcesContent":["import { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\nimport type { IRectangle, Point } from '../../Utilities';\nimport type {\n  IPositionDirectionalHintData,\n  IPositionedData,\n  ICalloutPositionedInfo,\n  ICalloutBeakPositionedInfo,\n  IPositionProps,\n  ICalloutPositionProps,\n  IWindowWithSegments,\n} from './positioning.types';\n\nfunction _createPositionData(\n  targetEdge: RectangleEdge,\n  alignmentEdge?: RectangleEdge,\n  isAuto?: boolean,\n): IPositionDirectionalHintData {\n  return {\n    targetEdge: targetEdge,\n    alignmentEdge: alignmentEdge,\n    isAuto: isAuto,\n  };\n}\n\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nconst DirectionalDictionary: { [key: number]: IPositionDirectionalHintData } = {\n  [DirectionalHint.topLeftEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.left),\n  [DirectionalHint.topCenter]: _createPositionData(RectangleEdge.top),\n  [DirectionalHint.topRightEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.right),\n  [DirectionalHint.topAutoEdge]: _createPositionData(RectangleEdge.top, undefined, true),\n  [DirectionalHint.bottomLeftEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.left),\n  [DirectionalHint.bottomCenter]: _createPositionData(RectangleEdge.bottom),\n  [DirectionalHint.bottomRightEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.right),\n  [DirectionalHint.bottomAutoEdge]: _createPositionData(RectangleEdge.bottom, undefined, true),\n  [DirectionalHint.leftTopEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.top),\n  [DirectionalHint.leftCenter]: _createPositionData(RectangleEdge.left),\n  [DirectionalHint.leftBottomEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.bottom),\n  [DirectionalHint.rightTopEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.top),\n  [DirectionalHint.rightCenter]: _createPositionData(RectangleEdge.right),\n  [DirectionalHint.rightBottomEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.bottom),\n};\n\n/**\n * Do not call methods from this directly, use either positionCallout or positionElement or make another function that\n * utilizes them.\n * START Private functions and interfaces\n */\n\nexport interface IElementPosition {\n  elementRectangle: Rectangle;\n  targetEdge: RectangleEdge;\n  alignmentEdge: RectangleEdge | undefined;\n  forcedInBounds?: boolean;\n}\n\nexport interface IElementPositionInfo extends IElementPosition {\n  targetRectangle: Rectangle;\n}\n\ntype PartialIRectangle = Partial<IRectangle>;\n\ninterface IPartialIRectangle extends PartialIRectangle {\n  [key: string]: number | undefined;\n}\n\nfunction _isRectangleWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\nfunction _getOutOfBoundsEdges(rect: Rectangle, boundingRect: Rectangle): RectangleEdge[] {\n  const outOfBounds: RectangleEdge[] = [];\n\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n\n  return outOfBounds;\n}\n\nfunction _getEdgeValue(rect: Rectangle, edge: RectangleEdge): number {\n  return (rect as any)[RectangleEdge[edge]] as number;\n}\n\nfunction _setEdgeValue(rect: Rectangle, edge: RectangleEdge, value: number) {\n  (rect as any)[RectangleEdge[edge]] = value;\n  return rect;\n}\n\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\nfunction _getCenterValue(rect: Rectangle, edge: RectangleEdge): number {\n  const edges = _getFlankingEdges(edge);\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\nfunction _getRelativeEdgeValue(edge: RectangleEdge, value: number): number {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\n\nfunction _getRelativeRectEdgeValue(edge: RectangleEdge, rect: Rectangle): number {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\n\nfunction _getRelativeEdgeDifference(rect: Rectangle, hostRect: Rectangle, edge: RectangleEdge): number {\n  const edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n * if maintainSize is set to false, it will only adjust the specified edge value\n */\nfunction _moveEdge(rect: Rectangle, edge: RectangleEdge, newValue: number, maintainSize = true): Rectangle {\n  const difference = _getEdgeValue(rect, edge) - newValue;\n  let returnRect = _setEdgeValue(rect, edge, newValue);\n  if (maintainSize) {\n    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  }\n  return returnRect;\n}\n\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\nfunction _alignEdges(rect: Rectangle, target: Rectangle, edge: RectangleEdge, gap: number = 0): Rectangle {\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\nfunction _alignOppositeEdges(\n  rect: Rectangle,\n  target: Rectangle,\n  targetEdge: RectangleEdge,\n  gap: number = 0,\n): Rectangle {\n  const oppositeEdge = targetEdge * -1;\n  const adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\nfunction _isEdgeInBounds(rect: Rectangle, bounds: Rectangle, edge: RectangleEdge): boolean {\n  const adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n\n/**\n * Returns a measure of how much a rectangle is out of bounds for a given alignment;\n * this can be used to compare which rectangle is more or less out of bounds.\n * A value of 0 means the rectangle is entirely in bounds\n */\nfunction _getOutOfBoundsDegree(rect: Rectangle, bounds: Rectangle) {\n  const breakingEdges = _getOutOfBoundsEdges(rect, bounds);\n  let total = 0;\n  for (const edge of breakingEdges) {\n    total += _getRelativeEdgeDifference(rect, bounds, edge) ** 2;\n  }\n\n  return total;\n}\n\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the least bad option should be returned.\n */\nfunction _flipToFit(\n  rect: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n): IElementPosition {\n  const directions: RectangleEdge[] = [\n    RectangleEdge.left,\n    RectangleEdge.right,\n    RectangleEdge.bottom,\n    RectangleEdge.top,\n  ];\n  // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n  let currentEstimate = rect;\n  let currentEdge = positionData.targetEdge;\n  let currentAlignment = positionData.alignmentEdge;\n\n  // keep track of least bad option, in case no sides fit\n  let oobDegree;\n  let bestEdge = currentEdge;\n  let bestAlignment = currentAlignment;\n\n  // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n  for (let i = 0; i < 4; i++) {\n    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      // update least-bad edges\n      const currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);\n      if (!oobDegree || currentOOBDegree < oobDegree) {\n        oobDegree = currentOOBDegree;\n        bestEdge = currentEdge;\n        bestAlignment = currentAlignment;\n      }\n\n      directions.splice(directions.indexOf(currentEdge), 1);\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n        currentEstimate = _estimatePosition(\n          rect,\n          target,\n          { targetEdge: currentEdge, alignmentEdge: currentAlignment },\n          gap,\n        );\n      }\n    } else {\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment,\n      };\n    }\n  }\n\n  // nothing fits, use least-bad option\n  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);\n  return {\n    elementRectangle: currentEstimate,\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment,\n  };\n}\n\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when `alignTargetEdge` is specified.\n */\nfunction _flipAlignmentEdge(\n  elementEstimate: IElementPosition,\n  target: Rectangle,\n  gap: number,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, targetEdge, elementRectangle } = elementEstimate;\n  const oppositeEdge = alignmentEdge! * -1;\n  const newEstimate = _estimatePosition(\n    elementRectangle,\n    target,\n    { targetEdge: targetEdge, alignmentEdge: oppositeEdge },\n    gap,\n    coverTarget,\n  );\n\n  return {\n    elementRectangle: newEstimate,\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge,\n  };\n}\n\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\nfunction _adjustFitWithinBounds(\n  element: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, alignTargetEdge } = positionData;\n  let elementEstimate: IElementPosition = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: alignmentEdge,\n  };\n\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);\n  }\n  const outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);\n  // if directionalHintFixed is specified, we need to force the target edge to not change\n  // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite\n  const fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;\n\n  if (outOfBounds.length > 0) {\n    if (alignTargetEdge) {\n      // The edge opposite to the alignment edge might be out of bounds.\n      // Flip alignment to see if we can get it within bounds.\n      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n        const flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n          return flippedElementEstimate;\n        } else {\n          // If the flipped elements edges are still out of bounds, try nudging it.\n          elementEstimate = _alignOutOfBoundsEdges(\n            _getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding),\n            elementEstimate,\n            bounding,\n            fixedEdge,\n          );\n        }\n      } else {\n        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n      }\n    } else {\n      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n    }\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n * @param preserveEdge - Specify an edge that should not be modified\n */\nfunction _alignOutOfBoundsEdges(\n  outOfBoundsEdges: RectangleEdge[],\n  elementEstimate: IElementPosition,\n  bounding: Rectangle,\n  preserveEdge?: RectangleEdge,\n) {\n  for (const direction of outOfBoundsEdges) {\n    let edgeAttempt;\n\n    // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge\n    // this is because _alignEdges will move the opposite edge\n    if (preserveEdge && preserveEdge === direction * -1) {\n      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);\n      elementEstimate.forcedInBounds = true;\n    } else {\n      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n      const inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);\n      // only update estimate if the attempt didn't break out of the opposite bounding edge\n      if (!inBounds) {\n        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);\n        elementEstimate.forcedInBounds = true;\n      }\n    }\n\n    elementEstimate.elementRectangle = edgeAttempt;\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\nfunction _centerEdgeToPoint(rect: Rectangle, edge: RectangleEdge, point: number): Rectangle {\n  const { positiveEdge } = _getFlankingEdges(edge);\n  const elementMiddle = _getCenterValue(rect, edge);\n  const distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\nfunction _estimatePosition(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  coverTarget?: boolean,\n): Rectangle {\n  let estimatedElementPosition = new Rectangle(\n    elementToPosition.left,\n    elementToPosition.right,\n    elementToPosition.top,\n    elementToPosition.bottom,\n  );\n  const { alignmentEdge, targetEdge } = positionData;\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget\n    ? _alignEdges(estimatedElementPosition, target, targetEdge, gap)\n    : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);\n  // if no alignment edge is provided it's supposed to be centered.\n  if (!alignmentEdge) {\n    const targetMiddlePoint = _getCenterValue(target, targetEdge);\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n\n  return estimatedElementPosition;\n}\n\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\nfunction _getFlankingEdges(edge: RectangleEdge): { positiveEdge: RectangleEdge; negativeEdge: RectangleEdge } {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right,\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom,\n    };\n  }\n}\n\n/**\n * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\nfunction _finalizeReturnEdge(\n  elementRectangle: Rectangle,\n  returnEdge: RectangleEdge,\n  bounds?: Rectangle,\n): RectangleEdge {\n  if (\n    bounds &&\n    Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >\n      Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))\n  ) {\n    return returnEdge * -1;\n  }\n\n  return returnEdge;\n}\n\n/**\n * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds\n * @param elementRectangle The rectangle whose edge we are considering\n * @param bounds The rectangle marking the bounds\n * @param edge The target edge we're considering\n * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds\n */\nfunction _isEdgeOnBounds(elementRectangle: Rectangle, edge: RectangleEdge, bounds?: Rectangle): boolean {\n  return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);\n}\n\n/**\n * Finalizes the element position based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.\n */\nfunction _finalizeElementPosition(\n  elementRectangle: Rectangle,\n  hostElement: HTMLElement,\n  targetEdge: RectangleEdge,\n  bounds?: Rectangle,\n  alignmentEdge?: RectangleEdge,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n  forceWithinBounds?: boolean,\n): IPartialIRectangle {\n  const returnValue: IPartialIRectangle = {};\n\n  const hostRect: Rectangle = _getRectangleFromElement(hostElement);\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  let returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n\n  // If we are finalizing the return edge, choose the edge such that we grow away from the bounds\n  // If we are not finalizing the return edge but the opposite edge is flush against the bounds,\n  // choose that as the anchor edge so the element rect can grow away from the bounds' edge\n  // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow\n  // in the usual direction\n  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n\n  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n\n  // if the positioned element will still overflow, return all four edges with in-bounds values\n  if (forceWithinBounds) {\n    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      elementEdge * -1,\n    );\n    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      returnEdge * -1,\n    );\n  }\n\n  return returnValue;\n}\n\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\nfunction _calculateActualBeakWidthInPixels(beakWidth: number): number {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\nfunction _getPositionData(\n  directionalHint: DirectionalHint = DirectionalHint.bottomAutoEdge,\n  directionalHintForRTL?: DirectionalHint,\n  previousPositions?: IPositionDirectionalHintData,\n): IPositionDirectionalHintData {\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge,\n    };\n  }\n  const positionInformation: IPositionDirectionalHintData = { ...DirectionalDictionary[directionalHint] };\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n  return positionInformation;\n}\n\n/**\n * Gets the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\nfunction _getAlignmentData(\n  positionData: IPositionDirectionalHintData,\n  target: Rectangle,\n  boundingRect: Rectangle,\n  coverTarget?: boolean,\n  alignTargetEdge?: boolean,\n): IPositionDirectionalHintData {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\n\nfunction getClosestEdge(targetEdge: RectangleEdge, target: Rectangle, boundingRect: Rectangle): RectangleEdge {\n  const targetCenter: number = _getCenterValue(target, targetEdge);\n  const boundingCenter: number = _getCenterValue(boundingRect, targetEdge);\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(targetEdge);\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\n\nfunction _positionElementWithinBounds(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const estimatedElementPosition: Rectangle = _estimatePosition(\n    elementToPosition,\n    target,\n    positionData,\n    gap,\n    coverTarget,\n  );\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge,\n    };\n  } else {\n    return _adjustFitWithinBounds(\n      estimatedElementPosition,\n      target,\n      bounding,\n      positionData,\n      gap,\n      directionalHintFixed,\n      coverTarget,\n    );\n  }\n}\n\nfunction _finalizeBeakPosition(\n  elementPosition: IElementPositionInfo,\n  positionedBeak: Rectangle,\n  bounds?: Rectangle,\n): ICalloutBeakPositionedInfo {\n  const targetEdge = elementPosition.targetEdge * -1;\n  // The \"host\" element that we will use to help position the beak.\n  const actualElement = new Rectangle(\n    0,\n    elementPosition.elementRectangle.width,\n    0,\n    elementPosition.elementRectangle.height,\n  );\n  const returnValue: IPartialIRectangle = {};\n  const returnEdge = _finalizeReturnEdge(\n    elementPosition.elementRectangle,\n    elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge,\n    bounds,\n  );\n\n  // only show the beak if the callout is not fully covering the target\n  const beakEdgeDifference = _getRelativeEdgeDifference(\n    elementPosition.elementRectangle,\n    elementPosition.targetRectangle,\n    targetEdge,\n  );\n  const showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));\n\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n\n  return {\n    elementPosition: { ...returnValue },\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge: targetEdge,\n    hideBeak: !showBeak,\n  };\n}\n\nfunction _positionBeak(beakWidth: number, elementPosition: IElementPositionInfo): Rectangle {\n  const target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(elementPosition.targetEdge);\n  const beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n  const elementBounds = new Rectangle(\n    beakWidth / 2,\n    elementPosition.elementRectangle.width - beakWidth / 2,\n    beakWidth / 2,\n    elementPosition.elementRectangle.height - beakWidth / 2,\n  );\n\n  let beakPosition: Rectangle = new Rectangle(0, beakWidth, 0, beakWidth);\n\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n\n  beakPosition = _centerEdgeToPoint(\n    beakPosition,\n    elementPosition.targetEdge * -1,\n    beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle),\n  );\n\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n\n  return beakPosition;\n}\n\nfunction _getRectangleFromElement(element: Element): Rectangle {\n  const clientRect: ClientRect = element.getBoundingClientRect();\n\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\n\nfunction _getRectangleFromIRect(rect: IRectangle): Rectangle {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\n\nfunction _getTargetRect(bounds: Rectangle, target: Element | MouseEvent | Point | Rectangle | undefined): Rectangle {\n  let targetRectangle: Rectangle;\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!(target as MouseEvent).preventDefault) {\n      const ev = target as MouseEvent;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n      // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!(target as Element).getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target as Element);\n      // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      const rectOrPoint: Point & Rectangle = target as Point & Rectangle;\n      // eslint-disable-next-line deprecation/deprecation\n      const left = rectOrPoint.left || rectOrPoint.x;\n      // eslint-disable-next-line deprecation/deprecation\n      const top = rectOrPoint.top || rectOrPoint.y;\n      const right = rectOrPoint.right || left;\n      const bottom = rectOrPoint.bottom || top;\n      targetRectangle = new Rectangle(left, right, top, bottom);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      const outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (const direction of outOfBounds) {\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n\n  return targetRectangle;\n}\n\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\nfunction _getMaxHeightFromTargetRectangle(\n  targetRectangle: Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number,\n  bounds: Rectangle,\n  coverTarget?: boolean,\n) {\n  let maxHeight = 0;\n  const directionalHint = DirectionalDictionary[targetEdge];\n\n  // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n  const target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\n\nfunction _positionElementRelative(\n  props: IPositionProps,\n  elementToPosition: HTMLElement,\n  boundingRect: Rectangle,\n  previousPositions?: IPositionedData,\n): IElementPositionInfo {\n  const gap: number = props.gapSpace ? props.gapSpace : 0;\n  const targetRect: Rectangle = _getTargetRect(boundingRect, props.target);\n  const positionData: IPositionDirectionalHintData = _getAlignmentData(\n    _getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions)!,\n    targetRect,\n    boundingRect,\n    props.coverTarget,\n    props.alignTargetEdge,\n  );\n  const positionedElement: IElementPosition = _positionElementWithinBounds(\n    _getRectangleFromElement(elementToPosition),\n    targetRect,\n    boundingRect,\n    positionData,\n    gap,\n    props.directionalHintFixed,\n    props.coverTarget,\n  );\n  return { ...positionedElement, targetRectangle: targetRect };\n}\n\nfunction _finalizePositionData(\n  positionedElement: IElementPosition,\n  hostElement: HTMLElement,\n  bounds?: Rectangle,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n): IPositionedData {\n  const finalizedElement: IPartialIRectangle = _finalizeElementPosition(\n    positionedElement.elementRectangle,\n    hostElement,\n    positionedElement.targetEdge,\n    bounds,\n    positionedElement.alignmentEdge,\n    coverTarget,\n    doNotFinalizeReturnEdge,\n    positionedElement.forcedInBounds,\n  );\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge,\n  };\n}\n\nfunction _positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPosition = _positionElementRelative(\n    props,\n    elementToPosition,\n    boundingRect,\n    previousPositions,\n  );\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\n\nfunction _positionCallout(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  doNotFinalizeReturnEdge?: boolean,\n): ICalloutPositionedInfo {\n  const beakWidth: number = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  const gap: number = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\n  const positionProps: IPositionProps = props;\n  positionProps.gapSpace = gap;\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPositionInfo = _positionElementRelative(\n    positionProps,\n    callout,\n    boundingRect,\n    previousPositions,\n  );\n\n  const beakPositioned: Rectangle = _positionBeak(beakWidth, positionedElement);\n  const finalizedBeakPosition: ICalloutBeakPositionedInfo = _finalizeBeakPosition(\n    positionedElement,\n    beakPositioned,\n    boundingRect,\n  );\n\n  return {\n    ..._finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge),\n    beakPosition: finalizedBeakPosition,\n  };\n}\n\nfunction _positionCard(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, callout, previousPositions, true);\n}\n// END PRIVATE FUNCTIONS\n\nexport const __positioningTestPackage = {\n  _finalizePositionData,\n  _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds,\n  _positionBeak,\n  _getPositionData,\n  _getMaxHeightFromTargetRectangle,\n};\n\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\nexport function positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCallout(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCard(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions);\n}\n\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(\n  target: Element | MouseEvent | Point | Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number = 0,\n  bounds?: IRectangle,\n  coverTarget?: boolean,\n): number {\n  const mouseTarget: MouseEvent = target as MouseEvent;\n  const elementTarget: Element = target as Element;\n  const rectOrPointTarget: Point & Rectangle = target as Point & Rectangle;\n  let targetRect: Rectangle;\n  const boundingRectangle = bounds\n    ? _getRectangleFromIRect(bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  // eslint-disable-next-line deprecation/deprecation\n  const left = rectOrPointTarget.left || rectOrPointTarget.x;\n  // eslint-disable-next-line deprecation/deprecation\n  const top = rectOrPointTarget.top || rectOrPointTarget.y;\n  const right = rectOrPointTarget.right || left;\n  const bottom = rectOrPointTarget.bottom || top;\n\n  // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, right, top, bottom);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\nexport function getOppositeEdge(edge: RectangleEdge): RectangleEdge {\n  return edge * -1;\n}\n\nfunction _getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  let segments = undefined;\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  }\n\n  // Identify if we're dealing with single screen scenarios.\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight,\n    };\n  }\n\n  // Logic for determining dual screen scenarios.\n  let x: number | undefined = 0;\n  let y: number | undefined = 0;\n\n  // If the target is an Element get coordinates for its center.\n  if (target !== null && !!(target as Element).getBoundingClientRect) {\n    const clientRect = (target as Element).getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  }\n  // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = (target as Point).left || (target as MouseEvent | Point).x;\n    // eslint-disable-next-line deprecation/deprecation\n    y = (target as Point).top || (target as MouseEvent | Point).y;\n  }\n\n  let bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };\n\n  // Define which window segment are the coordinates in and calculate bounds based on that.\n  for (const segment of segments) {\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height,\n      };\n    }\n  }\n\n  return bounds;\n}\n\nexport function getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}