{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, allowScrollOnElement, allowOverscrollOnElement, getPropsWithDefaults, KeyCodes, elementContains, EventGroup } from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport { useBoolean, useMergedRefs, useWarnings, useConst, useSetTimeout, useId, useUnmount } from '@fluentui/react-hooks';\nvar ZERO = {\n  x: 0,\n  y: 0\n};\nvar DEFAULT_PROPS = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true\n};\nvar getClassNames = classNamesFunction();\n\nvar getMoveDelta = function (ev) {\n  var delta = 10;\n\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nvar useComponentRef = function (props, focusTrapZone) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function () {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      }\n    };\n  }, [focusTrapZone]);\n};\n\nexport var ModalBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var allowTouchBodyScroll = props.allowTouchBodyScroll,\n      className = props.className,\n      children = props.children,\n      containerClassName = props.containerClassName,\n      scrollableContentClassName = props.scrollableContentClassName,\n      elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n      firstFocusableSelector = props.firstFocusableSelector,\n      forceFocusInsideTrap = props.forceFocusInsideTrap,\n      ignoreExternalFocusing = props.ignoreExternalFocusing,\n      isBlocking = props.isBlocking,\n      isAlert = props.isAlert,\n      isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap,\n      isDarkOverlay = props.isDarkOverlay,\n      onDismiss = props.onDismiss,\n      layerProps = props.layerProps,\n      overlay = props.overlay,\n      isOpen = props.isOpen,\n      titleAriaId = props.titleAriaId,\n      styles = props.styles,\n      subtitleAriaId = props.subtitleAriaId,\n      theme = props.theme,\n      topOffsetFixed = props.topOffsetFixed,\n      responsiveMode = props.responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n  onLayerDidMount = props.onLayerDidMount,\n      isModeless = props.isModeless,\n      dragOptions = props.dragOptions,\n      onDismissed = props.onDismissed,\n      // eslint-disable-next-line deprecation/deprecation\n  enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var rootRef = React.useRef(null);\n  var focusTrapZone = React.useRef(null);\n  var focusTrapZoneElm = React.useRef(null);\n  var mergedRef = useMergedRefs(rootRef, ref);\n  var modalResponsiveMode = useResponsiveMode(mergedRef);\n  var focusTrapZoneId = useId('ModalFocusTrapZone');\n  var win = useWindow();\n\n  var _a = useSetTimeout(),\n      setTimeout = _a.setTimeout,\n      clearTimeout = _a.clearTimeout;\n\n  var _b = React.useState(isOpen),\n      isModalOpen = _b[0],\n      setIsModalOpen = _b[1];\n\n  var _c = React.useState(isOpen),\n      isVisible = _c[0],\n      setIsVisible = _c[1];\n\n  var _d = React.useState(ZERO),\n      coordinates = _d[0],\n      setCoordinates = _d[1];\n\n  var _e = React.useState(),\n      modalRectangleTop = _e[0],\n      setModalRectangleTop = _e[1];\n\n  var _f = useBoolean(false),\n      isModalMenuOpen = _f[0],\n      _g = _f[1],\n      toggleModalMenuOpen = _g.toggle,\n      setModalMenuClose = _g.setFalse;\n\n  var internalState = useConst(function () {\n    return {\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll: allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({})\n    };\n  });\n  var keepInBounds = (dragOptions || {}).keepInBounds;\n  var isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : isBlocking && !isModeless;\n  var layerClassName = layerProps === undefined ? '' : layerProps.className;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    containerClassName: containerClassName,\n    scrollableContentClassName: scrollableContentClassName,\n    isOpen: isOpen,\n    isVisible: isVisible,\n    hasBeenOpened: internalState.hasBeenOpened,\n    modalRectangleTop: modalRectangleTop,\n    topOffsetFixed: topOffsetFixed,\n    isModeless: isModeless,\n    layerClassName: layerClassName,\n    windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,\n    isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n  });\n\n  var mergedLayerProps = __assign(__assign({\n    eventBubblingEnabled: false\n  }, layerProps), {\n    onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n    insertFirst: isModeless,\n    className: classNames.layer\n  }); // Allow the user to scroll within the modal but not on the body\n\n\n  var allowScrollOnModal = React.useCallback(function (elt) {\n    if (elt) {\n      if (internalState.allowTouchBodyScroll) {\n        allowOverscrollOnElement(elt, internalState.events);\n      } else {\n        allowScrollOnElement(elt, internalState.events);\n      }\n    } else {\n      internalState.events.off(internalState.scrollableContent);\n    }\n\n    internalState.scrollableContent = elt;\n  }, [internalState]);\n\n  var registerInitialModalPosition = function () {\n    var dialogMain = focusTrapZoneElm.current;\n    var modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();\n\n    if (modalRectangle) {\n      if (topOffsetFixed) {\n        setModalRectangleTop(modalRectangle.top);\n      }\n\n      if (keepInBounds) {\n        // x/y are unavailable in IE, so use the equivalent left/top\n        internalState.minPosition = {\n          x: -modalRectangle.left,\n          y: -modalRectangle.top\n        };\n        internalState.maxPosition = {\n          x: modalRectangle.left,\n          y: modalRectangle.top\n        };\n      }\n    }\n  };\n  /**\n   * Clamps an axis to a specified min and max position.\n   *\n   * @param axis A string that represents the axis (x/y).\n   * @param position The position on the axis.\n   */\n\n\n  var getClampedAxis = React.useCallback(function (axis, position) {\n    var minPosition = internalState.minPosition,\n        maxPosition = internalState.maxPosition;\n\n    if (keepInBounds && minPosition && maxPosition) {\n      position = Math.max(minPosition[axis], position);\n      position = Math.min(maxPosition[axis], position);\n    }\n\n    return position;\n  }, [keepInBounds, internalState]);\n\n  var handleModalClose = function () {\n    var _a;\n\n    internalState.lastSetCoordinates = ZERO;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n    setIsModalOpen(false);\n    setCoordinates(ZERO);\n    (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);\n    onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();\n  };\n\n  var handleDragStart = React.useCallback(function () {\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n  }, [internalState, setModalMenuClose]);\n  var handleDrag = React.useCallback(function (ev, dragData) {\n    setCoordinates(function (prevValue) {\n      return {\n        x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n        y: getClampedAxis('y', prevValue.y + dragData.delta.y)\n      };\n    });\n  }, [getClampedAxis]);\n  var handleDragStop = React.useCallback(function () {\n    if (focusTrapZone.current) {\n      focusTrapZone.current.focus();\n    }\n  }, []);\n\n  var handleEnterKeyboardMoveMode = function () {\n    // We need a global handleKeyDown event when we are in the move mode so that we can\n    // handle the key presses and the components inside the modal do not get the events\n    var handleKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        ev.preventDefault();\n        ev.stopPropagation();\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n\n      if (isModalMenuOpen && newLocal) {\n        setModalMenuClose();\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n        internalState.isInKeyboardMoveMode = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n\n      if (internalState.isInKeyboardMoveMode) {\n        var handledEvent = true;\n        var delta_1 = getMoveDelta(ev); // eslint-disable-next-line deprecation/deprecation\n\n        switch (ev.keyCode) {\n          /* eslint-disable no-fallthrough */\n          case KeyCodes.escape:\n            setCoordinates(internalState.lastSetCoordinates);\n\n          case KeyCodes.enter:\n            {\n              // TODO: determine if fallthrough was intentional\n\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO; // setIsInKeyboardMoveMode(false);\n\n              break;\n            }\n\n          case KeyCodes.up:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y - delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.down:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y + delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.left:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x - delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.right:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x + delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n\n        if (handledEvent) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    internalState.lastSetCoordinates = coordinates;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = true;\n    internalState.events.on(win, 'keydown', handleKeyDown, true\n    /* useCapture */\n    );\n\n    internalState.disposeOnKeyDown = function () {\n      internalState.events.off(win, 'keydown', handleKeyDown, true\n      /* useCapture */\n      );\n      internalState.disposeOnKeyDown = undefined;\n    };\n  };\n\n  var handleExitKeyboardMoveMode = function () {\n    var _a;\n\n    internalState.lastSetCoordinates = ZERO;\n    internalState.isInKeyboardMoveMode = false;\n    (_a = internalState.disposeOnKeyDown) === null || _a === void 0 ? void 0 : _a.call(internalState);\n  };\n\n  var registerForKeyUp = function () {\n    var handleKeyUp = function (ev) {\n      // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        if (elementContains(internalState.scrollableContent, ev.target)) {\n          toggleModalMenuOpen();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    if (!internalState.disposeOnKeyUp) {\n      internalState.events.on(win, 'keyup', handleKeyUp, true\n      /* useCapture */\n      );\n\n      internalState.disposeOnKeyUp = function () {\n        internalState.events.off(win, 'keyup', handleKeyUp, true\n        /* useCapture */\n        );\n        internalState.disposeOnKeyUp = undefined;\n      };\n    }\n  };\n\n  React.useEffect(function () {\n    clearTimeout(internalState.onModalCloseTimer); // Opening the dialog\n\n    if (isOpen) {\n      // This must be done after the modal content has rendered\n      requestAnimationFrame(function () {\n        return setTimeout(registerInitialModalPosition, 0);\n      });\n      setIsModalOpen(true); // Add a keyUp handler for all key up events once the dialog is open.\n\n      if (dragOptions) {\n        registerForKeyUp();\n      }\n\n      internalState.hasBeenOpened = true;\n      setIsVisible(true);\n    } // Closing the dialog\n\n\n    if (!isOpen && isModalOpen) {\n      internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n      setIsVisible(false);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n\n  }, [isModalOpen, isOpen]);\n  useUnmount(function () {\n    internalState.events.dispose();\n  });\n  useComponentRef(props, focusTrapZone);\n  useDebugWarnings(props);\n  var modalContent = React.createElement(FocusTrapZone, {\n    id: focusTrapZoneId,\n    ref: focusTrapZoneElm,\n    componentRef: focusTrapZone,\n    className: classNames.main,\n    elementToFocusOnDismiss: elementToFocusOnDismiss,\n    isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking,\n    ignoreExternalFocusing: ignoreExternalFocusing,\n    forceFocusInsideTrap: forceFocusInsideTrap && !isModeless,\n    firstFocusableSelector: firstFocusableSelector,\n    focusPreviouslyFocusedInnerElement: true,\n    onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined\n  }, dragOptions && internalState.isInKeyboardMoveMode && React.createElement(\"div\", {\n    className: classNames.keyboardMoveIconContainer\n  }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, __assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n    iconName: \"move\",\n    className: classNames.keyboardMoveIcon\n  })), React.createElement(\"div\", {\n    ref: allowScrollOnModal,\n    className: classNames.scrollableContent,\n    \"data-is-scrollable\": true\n  }, dragOptions && isModalMenuOpen && React.createElement(dragOptions.menu, {\n    items: [{\n      key: 'move',\n      text: dragOptions.moveMenuItemText,\n      onClick: handleEnterKeyboardMoveMode\n    }, {\n      key: 'close',\n      text: dragOptions.closeMenuItemText,\n      onClick: handleModalClose\n    }],\n    onDismiss: setModalMenuClose,\n    alignTargetEdge: true,\n    coverTarget: true,\n    directionalHint: DirectionalHint.topLeftEdge,\n    directionalHintFixed: true,\n    shouldFocusOnMount: true,\n    target: internalState.scrollableContent\n  }), children));\n  return isModalOpen && modalResponsiveMode >= (responsiveMode || ResponsiveMode.small) && React.createElement(Layer, __assign({\n    ref: mergedRef\n  }, mergedLayerProps), React.createElement(Popup, {\n    role: isAlertRole ? 'alertdialog' : 'dialog',\n    ariaLabelledBy: titleAriaId,\n    ariaDescribedBy: subtitleAriaId,\n    onDismiss: onDismiss,\n    shouldRestoreFocus: !ignoreExternalFocusing,\n    // Modeless modals shouldn't hide siblings.\n    // Popup will automatically handle this based on the aria-modal setting.\n    enableAriaHiddenSiblings: enableAriaHiddenSiblings,\n    \"aria-modal\": !isModeless\n  }, React.createElement(\"div\", {\n    className: classNames.root,\n    role: !isModeless ? 'document' : undefined\n  }, !isModeless && React.createElement(Overlay, __assign({\n    \"aria-hidden\": true,\n    isDarkThemed: isDarkOverlay,\n    onClick: isBlocking ? undefined : onDismiss,\n    allowTouchBodyScroll: allowTouchBodyScroll\n  }, overlay)), dragOptions ? React.createElement(DraggableZone, {\n    handleSelector: dragOptions.dragHandleSelector || \"#\" + focusTrapZoneId,\n    preventDragSelector: \"button\",\n    onStart: handleDragStart,\n    onDragChange: handleDrag,\n    onStop: handleDragStop,\n    position: coordinates\n  }, modalContent) : modalContent))) || null;\n});\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props: props,\n      deprecations: {\n        onLayerDidMount: 'layerProps.onLayerDidMount'\n      }\n    });\n  }\n}","map":{"version":3,"sources":["components/Modal/Modal.base.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SACE,kBADF,EAEE,oBAFF,EAGE,wBAHF,EAIE,oBAJF,EAKE,QALF,EAME,eANF,EAOE,UAPF,QAQO,iBARP;AASA,SAAS,aAAT,QAA8B,qBAA9B;AACA,SAAS,iBAAT,QAAkC,gBAAlC;AACA,SAAS,OAAT,QAAwB,eAAxB;AACA,SAAS,KAAT,QAAsB,aAAtB;AACA,SAAS,KAAT,QAAsB,aAAtB;AACA,SAAS,cAAT,EAAyB,iBAAzB,QAAkD,sBAAlD;AACA,SAAS,eAAT,QAAgC,8BAAhC;AACA,SAAS,IAAT,QAAqB,YAArB;AACA,SAAS,aAAT,QAA8B,qCAA9B;AACA,SAAS,SAAT,QAA0B,iCAA1B;AACA,SACE,UADF,EAEE,aAFF,EAGE,WAHF,EAIE,QAJF,EAKE,aALF,EAME,KANF,EAOE,UAPF,QAQO,uBARP;AAkCA,IAAM,IAAI,GAAiB;EAAE,CAAC,EAAE,CAAL;EAAQ,CAAC,EAAE;AAAX,CAA3B;AAEA,IAAM,aAAa,GAAyB;EAC1C,MAAM,EAAE,KADkC;EAE1C,aAAa,EAAE,IAF2B;EAG1C,SAAS,EAAE,EAH+B;EAI1C,kBAAkB,EAAE,EAJsB;EAK1C,wBAAwB,EAAE;AALgB,CAA5C;AAQA,IAAM,aAAa,GAAG,kBAAkB,EAAxC;;AAEA,IAAM,YAAY,GAAG,UAAC,EAAD,EAAqC;EACxD,IAAI,KAAK,GAAG,EAAZ;;EACA,IAAI,EAAE,CAAC,QAAP,EAAiB;IACf,IAAI,CAAC,EAAE,CAAC,OAAR,EAAiB;MACf,KAAK,GAAG,EAAR;IACD;EACF,CAJD,MAIO,IAAI,EAAE,CAAC,OAAP,EAAgB;IACrB,KAAK,GAAG,CAAR;EACD;;EAED,OAAO,KAAP;AACD,CAXD;;AAaA,IAAM,eAAe,GAAG,UAAC,KAAD,EAAqB,aAArB,EAAmE;EACzF,KAAK,CAAC,mBAAN,CACE,KAAK,CAAC,YADR,EAEE,YAAA;IAAM,OAAC;MACL,KAAK,EAAA,YAAA;QACH,IAAI,aAAa,CAAC,OAAlB,EAA2B;UACzB,aAAa,CAAC,OAAd,CAAsB,KAAtB;QACD;MACF;IALI,CAAD;EAMJ,CARJ,EASE,CAAC,aAAD,CATF;AAWD,CAZD;;AAcA,OAAO,IAAM,SAAS,GAAyC,KAAK,CAAC,UAAN,CAC7D,UAAC,oBAAD,EAAuB,GAAvB,EAA0B;EACxB,IAAM,KAAK,GAAG,oBAAoB,CAAC,aAAD,EAAgB,oBAAhB,CAAlC;EAEE,IAAA,oBAAoB,GA8BlB,KAAK,CA9Ba,oBAApB;EAAA,IACA,SAAS,GA6BP,KAAK,CA7BE,SADT;EAAA,IAEA,QAAQ,GA4BN,KAAK,CA5BC,QAFR;EAAA,IAGA,kBAAkB,GA2BhB,KAAK,CA3BW,kBAHlB;EAAA,IAIA,0BAA0B,GA0BxB,KAAK,CA1BmB,0BAJ1B;EAAA,IAKA,uBAAuB,GAyBrB,KAAK,CAzBgB,uBALvB;EAAA,IAMA,sBAAsB,GAwBpB,KAAK,CAxBe,sBANtB;EAAA,IAOA,oBAAoB,GAuBlB,KAAK,CAvBa,oBAPpB;EAAA,IAQA,sBAAsB,GAsBpB,KAAK,CAtBe,sBARtB;EAAA,IASA,UAAU,GAqBR,KAAK,CArBG,UATV;EAAA,IAUA,OAAO,GAoBL,KAAK,CApBA,OAVP;EAAA,IAWA,2BAA2B,GAmBzB,KAAK,CAnBoB,2BAX3B;EAAA,IAYA,aAAa,GAkBX,KAAK,CAlBM,aAZb;EAAA,IAaA,SAAS,GAiBP,KAAK,CAjBE,SAbT;EAAA,IAcA,UAAU,GAgBR,KAAK,CAhBG,UAdV;EAAA,IAeA,OAAO,GAeL,KAAK,CAfA,OAfP;EAAA,IAgBA,MAAM,GAcJ,KAAK,CAdD,MAhBN;EAAA,IAiBA,WAAW,GAaT,KAAK,CAbI,WAjBX;EAAA,IAkBA,MAAM,GAYJ,KAAK,CAZD,MAlBN;EAAA,IAmBA,cAAc,GAWZ,KAAK,CAXO,cAnBd;EAAA,IAoBA,KAAK,GAUH,KAAK,CAVF,KApBL;EAAA,IAqBA,cAAc,GASZ,KAAK,CATO,cArBd;EAAA,IAsBA,cAAc,GAQZ,KAAK,CARO,cAtBd;EAAA,IAuBA;EACA,eAAe,GAMb,KAAK,CANQ,eAxBf;EAAA,IAyBA,UAAU,GAKR,KAAK,CALG,UAzBV;EAAA,IA0BA,WAAW,GAIT,KAAK,CAJI,WA1BX;EAAA,IA2BA,WAAW,GAGT,KAAK,CAHI,WA3BX;EAAA,IA4BA;EACA,wBAAwB,GACtB,KAAK,CADiB,wBA7BxB;EAgCF,IAAM,OAAO,GAAG,KAAK,CAAC,MAAN,CAA6B,IAA7B,CAAhB;EACA,IAAM,aAAa,GAAG,KAAK,CAAC,MAAN,CAA6B,IAA7B,CAAtB;EACA,IAAM,gBAAgB,GAAG,KAAK,CAAC,MAAN,CAA6B,IAA7B,CAAzB;EACA,IAAM,SAAS,GAAG,aAAa,CAAC,OAAD,EAAU,GAAV,CAA/B;EAEA,IAAM,mBAAmB,GAAG,iBAAiB,CAAC,SAAD,CAA7C;EAEA,IAAM,eAAe,GAAG,KAAK,CAAC,oBAAD,CAA7B;EAEA,IAAM,GAAG,GAAG,SAAS,EAArB;;EAEM,IAAA,EAAA,GAA+B,aAAa,EAA5C;EAAA,IAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;EAAA,IAAc,YAAY,GAAA,EAAA,CAAA,YAA1B;;EAEA,IAAA,EAAA,GAAgC,KAAK,CAAC,QAAN,CAAe,MAAf,CAAhC;EAAA,IAAC,WAAW,GAAA,EAAA,CAAA,CAAA,CAAZ;EAAA,IAAc,cAAc,GAAA,EAAA,CAAA,CAAA,CAA5B;;EACA,IAAA,EAAA,GAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B;EAAA,IAAC,SAAS,GAAA,EAAA,CAAA,CAAA,CAAV;EAAA,IAAY,YAAY,GAAA,EAAA,CAAA,CAAA,CAAxB;;EACA,IAAA,EAAA,GAAgC,KAAK,CAAC,QAAN,CAA6B,IAA7B,CAAhC;EAAA,IAAC,WAAW,GAAA,EAAA,CAAA,CAAA,CAAZ;EAAA,IAAc,cAAc,GAAA,EAAA,CAAA,CAAA,CAA5B;;EACA,IAAA,EAAA,GAA4C,KAAK,CAAC,QAAN,EAA5C;EAAA,IAAC,iBAAiB,GAAA,EAAA,CAAA,CAAA,CAAlB;EAAA,IAAoB,oBAAoB,GAAA,EAAA,CAAA,CAAA,CAAxC;;EAEA,IAAA,EAAA,GAAkF,UAAU,CAAC,KAAD,CAA5F;EAAA,IAAC,eAAe,GAAA,EAAA,CAAA,CAAA,CAAhB;EAAA,IAAkB,EAAA,GAAA,EAAA,CAAA,CAAA,CAAlB;EAAA,IAA4B,mBAAmB,GAAA,EAAA,CAAA,MAA/C;EAAA,IAA2D,iBAAiB,GAAA,EAAA,CAAA,QAA5E;;EAEN,IAAM,aAAa,GAAG,QAAQ,CAAsB,YAAA;IAAM,OAAC;MACzD,iBAAiB,EAAE,CADsC;MAEzD,oBAAoB,EAAA,oBAFqC;MAGzD,iBAAiB,EAAE,IAHsC;MAIzD,kBAAkB,EAAE,IAJqC;MAKzD,MAAM,EAAE,IAAI,UAAJ,CAAe,EAAf;IALiD,CAAD;EAMxD,CAN4B,CAA9B;EAQQ,IAAA,YAAY,GAAK,CAAA,WAAW,IAAK,EAAhB,EAAL,YAAZ;EACR,IAAM,WAAW,GAAG,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAY,UAAU,IAAI,CAAC,UAA/C;EAEA,IAAM,cAAc,GAAG,UAAU,KAAK,SAAf,GAA2B,EAA3B,GAAgC,UAAU,CAAC,SAAlE;EACA,IAAM,UAAU,GAAG,aAAa,CAAC,MAAD,EAAS;IACvC,KAAK,EAAE,KADgC;IAEvC,SAAS,EAAA,SAF8B;IAGvC,kBAAkB,EAAA,kBAHqB;IAIvC,0BAA0B,EAAA,0BAJa;IAKvC,MAAM,EAAA,MALiC;IAMvC,SAAS,EAAA,SAN8B;IAOvC,aAAa,EAAE,aAAa,CAAC,aAPU;IAQvC,iBAAiB,EAAA,iBARsB;IASvC,cAAc,EAAA,cATyB;IAUvC,UAAU,EAAA,UAV6B;IAWvC,cAAc,EAAA,cAXyB;IAYvC,iBAAiB,EAAE,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAG,KAAA,CAAH,GAAA,GAAG,CAAE,WAZe;IAavC,mBAAmB,EAAE,WAAW,IAAI,CAAC,WAAW,CAAC;EAbV,CAAT,CAAhC;;EAgBA,IAAM,gBAAgB,GAAA,QAAA,CAAA,QAAA,CAAA;IACpB,oBAAoB,EAAE;EADF,CAAA,EAEjB,UAFiB,CAAA,EAEP;IACb,eAAe,EAAE,UAAU,IAAI,UAAU,CAAC,eAAzB,GAA2C,UAAU,CAAC,eAAtD,GAAwE,eAD5E;IAEb,WAAW,EAAE,UAFA;IAGb,SAAS,EAAE,UAAU,CAAC;EAHT,CAFO,CAAtB,CAnFwB,CA2FxB;;;EACA,IAAM,kBAAkB,GAAG,KAAK,CAAC,WAAN,CACzB,UAAC,GAAD,EAA2B;IACzB,IAAI,GAAJ,EAAS;MACP,IAAI,aAAa,CAAC,oBAAlB,EAAwC;QACtC,wBAAwB,CAAC,GAAD,EAAM,aAAa,CAAC,MAApB,CAAxB;MACD,CAFD,MAEO;QACL,oBAAoB,CAAC,GAAD,EAAM,aAAa,CAAC,MAApB,CAApB;MACD;IACF,CAND,MAMO;MACL,aAAa,CAAC,MAAd,CAAqB,GAArB,CAAyB,aAAa,CAAC,iBAAvC;IACD;;IACD,aAAa,CAAC,iBAAd,GAAkC,GAAlC;EACD,CAZwB,EAazB,CAAC,aAAD,CAbyB,CAA3B;;EAgBA,IAAM,4BAA4B,GAAG,YAAA;IACnC,IAAM,UAAU,GAAG,gBAAgB,CAAC,OAApC;IACA,IAAM,cAAc,GAAG,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,qBAAZ,EAAvB;;IAEA,IAAI,cAAJ,EAAoB;MAClB,IAAI,cAAJ,EAAoB;QAClB,oBAAoB,CAAC,cAAc,CAAC,GAAhB,CAApB;MACD;;MAED,IAAI,YAAJ,EAAkB;QAChB;QACA,aAAa,CAAC,WAAd,GAA4B;UAAE,CAAC,EAAE,CAAC,cAAc,CAAC,IAArB;UAA2B,CAAC,EAAE,CAAC,cAAc,CAAC;QAA9C,CAA5B;QACA,aAAa,CAAC,WAAd,GAA4B;UAAE,CAAC,EAAE,cAAc,CAAC,IAApB;UAA0B,CAAC,EAAE,cAAc,CAAC;QAA5C,CAA5B;MACD;IACF;EACF,CAfD;EAiBA;;;;;AAKG;;;EACH,IAAM,cAAc,GAAG,KAAK,CAAC,WAAN,CACrB,UAAC,IAAD,EAA2B,QAA3B,EAA2C;IACjC,IAAA,WAAW,GAAkB,aAAa,CAA/B,WAAX;IAAA,IAAa,WAAW,GAAK,aAAa,CAAlB,WAAxB;;IACR,IAAI,YAAY,IAAI,WAAhB,IAA+B,WAAnC,EAAgD;MAC9C,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,IAAD,CAApB,EAA4B,QAA5B,CAAX;MACA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,IAAD,CAApB,EAA4B,QAA5B,CAAX;IACD;;IACD,OAAO,QAAP;EACD,CARoB,EASrB,CAAC,YAAD,EAAe,aAAf,CATqB,CAAvB;;EAYA,IAAM,gBAAgB,GAAG,YAAA;;;IACvB,aAAa,CAAC,kBAAd,GAAmC,IAAnC;IAEA,iBAAiB;IACjB,aAAa,CAAC,oBAAd,GAAqC,KAArC;IACA,cAAc,CAAC,KAAD,CAAd;IACA,cAAc,CAAC,IAAD,CAAd;IAEA,CAAA,EAAA,GAAA,aAAa,CAAC,cAAd,MAA4B,IAA5B,IAA4B,EAAA,KAAA,KAAA,CAA5B,GAA4B,KAAA,CAA5B,GAA4B,EAAA,CAAA,IAAA,CAA5B,aAA4B,CAA5B;IAEA,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,EAAX;EACD,CAXD;;EAaA,IAAM,eAAe,GAAG,KAAK,CAAC,WAAN,CAAkB,YAAA;IACxC,iBAAiB;IACjB,aAAa,CAAC,oBAAd,GAAqC,KAArC;EACD,CAHuB,EAGrB,CAAC,aAAD,EAAgB,iBAAhB,CAHqB,CAAxB;EAKA,IAAM,UAAU,GAAG,KAAK,CAAC,WAAN,CACjB,UAAC,EAAD,EAAoE,QAApE,EAAuF;IACrF,cAAc,CAAC,UAAA,SAAA,EAAS;MAAI,OAAC;QAC3B,CAAC,EAAE,cAAc,CAAC,GAAD,EAAM,SAAS,CAAC,CAAV,GAAc,QAAQ,CAAC,KAAT,CAAe,CAAnC,CADU;QAE3B,CAAC,EAAE,cAAc,CAAC,GAAD,EAAM,SAAS,CAAC,CAAV,GAAc,QAAQ,CAAC,KAAT,CAAe,CAAnC;MAFU,CAAD;IAG1B,CAHY,CAAd;EAID,CANgB,EAOjB,CAAC,cAAD,CAPiB,CAAnB;EAUA,IAAM,cAAc,GAAG,KAAK,CAAC,WAAN,CAAkB,YAAA;IACvC,IAAI,aAAa,CAAC,OAAlB,EAA2B;MACzB,aAAa,CAAC,OAAd,CAAsB,KAAtB;IACD;EACF,CAJsB,EAIpB,EAJoB,CAAvB;;EAMA,IAAM,2BAA2B,GAAG,YAAA;IAClC;IACA;IACA,IAAM,aAAa,GAAG,UAAC,EAAD,EAAqC;MACzD;MACA,IAAI,EAAE,CAAC,MAAH,IAAa,EAAE,CAAC,OAAhB,IAA2B,EAAE,CAAC,OAAH,KAAe,QAAQ,CAAC,KAAvD,EAA8D;QAC5D;QACA,EAAE,CAAC,cAAH;QACA,EAAE,CAAC,eAAH;QACA;MACD,CAPwD,CASzD;;;MACA,IAAM,QAAQ,GAAG,EAAE,CAAC,MAAH,IAAa,EAAE,CAAC,OAAH,KAAe,QAAQ,CAAC,MAAtD;;MACA,IAAI,eAAe,IAAI,QAAvB,EAAiC;QAC/B,iBAAiB;MAClB,CAbwD,CAezD;;;MACA,IAAI,aAAa,CAAC,oBAAd,KAAuC,EAAE,CAAC,OAAH,KAAe,QAAQ,CAAC,MAAxB,IAAkC,EAAE,CAAC,OAAH,KAAe,QAAQ,CAAC,KAAjG,CAAJ,EAA6G;QAC3G,aAAa,CAAC,oBAAd,GAAqC,KAArC;QACA,EAAE,CAAC,cAAH;QACA,EAAE,CAAC,eAAH;MACD;;MAED,IAAI,aAAa,CAAC,oBAAlB,EAAwC;QACtC,IAAI,YAAY,GAAG,IAAnB;QACA,IAAM,OAAK,GAAG,YAAY,CAAC,EAAD,CAA1B,CAFsC,CAItC;;QACA,QAAQ,EAAE,CAAC,OAAX;UACE;UACA,KAAK,QAAQ,CAAC,MAAd;YACE,cAAc,CAAC,aAAa,CAAC,kBAAf,CAAd;;UACF,KAAK,QAAQ,CAAC,KAAd;YAAqB;cACnB;;cACA;cACA,aAAa,CAAC,kBAAd,GAAmC,IAAnC,CAHmB,CAInB;;cACA;YACD;;UACD,KAAK,QAAQ,CAAC,EAAd;YAAkB;cAChB,cAAc,CAAC,UAAA,SAAA,EAAS;gBAAI,OAAC;kBAAE,CAAC,EAAE,SAAS,CAAC,CAAf;kBAAkB,CAAC,EAAE,cAAc,CAAC,GAAD,EAAM,SAAS,CAAC,CAAV,GAA1C,OAAoC;gBAAnC,CAAD;cAAiE,CAA/E,CAAd;cACA;YACD;;UACD,KAAK,QAAQ,CAAC,IAAd;YAAoB;cAClB,cAAc,CAAC,UAAA,SAAA,EAAS;gBAAI,OAAC;kBAAE,CAAC,EAAE,SAAS,CAAC,CAAf;kBAAkB,CAAC,EAAE,cAAc,CAAC,GAAD,EAAM,SAAS,CAAC,CAAV,GAA1C,OAAoC;gBAAnC,CAAD;cAAiE,CAA/E,CAAd;cACA;YACD;;UACD,KAAK,QAAQ,CAAC,IAAd;YAAoB;cAClB,cAAc,CAAC,UAAA,SAAA,EAAS;gBAAI,OAAC;kBAAE,CAAC,EAAE,cAAc,CAAC,GAAD,EAAM,SAAS,CAAC,CAAV,GAAc,OAApB,CAAnB;kBAA+C,CAAC,EAAE,SAAS,CAA5D;gBAAC,CAAD;cAAiE,CAA/E,CAAd;cACA;YACD;;UACD,KAAK,QAAQ,CAAC,KAAd;YAAqB;cACnB,cAAc,CAAC,UAAA,SAAA,EAAS;gBAAI,OAAC;kBAAE,CAAC,EAAE,cAAc,CAAC,GAAD,EAAM,SAAS,CAAC,CAAV,GAAc,OAApB,CAAnB;kBAA+C,CAAC,EAAE,SAAS,CAA5D;gBAAC,CAAD;cAAiE,CAA/E,CAAd;cACA;YACD;;UACD;YAAS;cACP,YAAY,GAAG,KAAf;YACD;QA7BH;;QA+BA,IAAI,YAAJ,EAAkB;UAChB,EAAE,CAAC,cAAH;UACA,EAAE,CAAC,eAAH;QACD;MACF;IACF,CA/DD;;IAiEA,aAAa,CAAC,kBAAd,GAAmC,WAAnC;IACA,iBAAiB;IACjB,aAAa,CAAC,oBAAd,GAAqC,IAArC;IAEA,aAAa,CAAC,MAAd,CAAqB,EAArB,CAAwB,GAAxB,EAA6B,SAA7B,EAAwC,aAAxC,EAAuD;IAAK;IAA5D;;IACA,aAAa,CAAC,gBAAd,GAAiC,YAAA;MAC/B,aAAa,CAAC,MAAd,CAAqB,GAArB,CAAyB,GAAzB,EAA8B,SAA9B,EAAyC,aAAzC,EAAwD;MAAK;MAA7D;MACA,aAAa,CAAC,gBAAd,GAAiC,SAAjC;IACD,CAHD;EAID,CA7ED;;EA+EA,IAAM,0BAA0B,GAAG,YAAA;;;IACjC,aAAa,CAAC,kBAAd,GAAmC,IAAnC;IACA,aAAa,CAAC,oBAAd,GAAqC,KAArC;IACA,CAAA,EAAA,GAAA,aAAa,CAAC,gBAAd,MAA8B,IAA9B,IAA8B,EAAA,KAAA,KAAA,CAA9B,GAA8B,KAAA,CAA9B,GAA8B,EAAA,CAAA,IAAA,CAA9B,aAA8B,CAA9B;EACD,CAJD;;EAMA,IAAM,gBAAgB,GAAG,YAAA;IACvB,IAAM,WAAW,GAAG,UAAC,EAAD,EAAqC;MACvD;MACA;MACA;MACA,IAAI,EAAE,CAAC,MAAH,IAAa,EAAE,CAAC,OAAhB,IAA2B,EAAE,CAAC,OAAH,KAAe,QAAQ,CAAC,KAAvD,EAA8D;QAC5D,IAAI,eAAe,CAAC,aAAa,CAAC,iBAAf,EAAkC,EAAE,CAAC,MAArC,CAAnB,EAAgF;UAC9E,mBAAmB;UACnB,EAAE,CAAC,cAAH;UACA,EAAE,CAAC,eAAH;QACD;MACF;IACF,CAXD;;IAaA,IAAI,CAAC,aAAa,CAAC,cAAnB,EAAmC;MACjC,aAAa,CAAC,MAAd,CAAqB,EAArB,CAAwB,GAAxB,EAA6B,OAA7B,EAAsC,WAAtC,EAAmD;MAAK;MAAxD;;MACA,aAAa,CAAC,cAAd,GAA+B,YAAA;QAC7B,aAAa,CAAC,MAAd,CAAqB,GAArB,CAAyB,GAAzB,EAA8B,OAA9B,EAAuC,WAAvC,EAAoD;QAAK;QAAzD;QACA,aAAa,CAAC,cAAd,GAA+B,SAA/B;MACD,CAHD;IAID;EACF,CArBD;;EAuBA,KAAK,CAAC,SAAN,CAAgB,YAAA;IACd,YAAY,CAAC,aAAa,CAAC,iBAAf,CAAZ,CADc,CAEd;;IACA,IAAI,MAAJ,EAAY;MACV;MACA,qBAAqB,CAAC,YAAA;QAAM,OAAA,UAAU,CAAC,4BAAD,EAAV,CAAU,CAAV;MAA2C,CAAlD,CAArB;MAEA,cAAc,CAAC,IAAD,CAAd,CAJU,CAMV;;MACA,IAAI,WAAJ,EAAiB;QACf,gBAAgB;MACjB;;MAED,aAAa,CAAC,aAAd,GAA8B,IAA9B;MACA,YAAY,CAAC,IAAD,CAAZ;IACD,CAhBa,CAkBd;;;IACA,IAAI,CAAC,MAAD,IAAW,WAAf,EAA4B;MAC1B,aAAa,CAAC,iBAAd,GAAkC,UAAU,CAAC,gBAAD,EAAmB,UAAU,CAAC,iBAAD,CAAV,GAAgC,IAAnD,CAA5C;MACA,YAAY,CAAC,KAAD,CAAZ;IACD,CAtBa,CAuBd;;EACD,CAxBD,EAwBG,CAAC,WAAD,EAAc,MAAd,CAxBH;EA0BA,UAAU,CAAC,YAAA;IACT,aAAa,CAAC,MAAd,CAAqB,OAArB;EACD,CAFS,CAAV;EAIA,eAAe,CAAC,KAAD,EAAQ,aAAR,CAAf;EACA,gBAAgB,CAAC,KAAD,CAAhB;EAEA,IAAM,YAAY,GAChB,KAAA,CAAA,aAAA,CAAC,aAAD,EAAc;IACZ,EAAE,EAAE,eADQ;IAEZ,GAAG,EAAE,gBAFO;IAGZ,YAAY,EAAE,aAHF;IAIZ,SAAS,EAAE,UAAU,CAAC,IAJV;IAKZ,uBAAuB,EAAE,uBALb;IAMZ,2BAA2B,EAAE,UAAU,IAAI,2BAAd,IAA6C,CAAC,UAN/D;IAOZ,sBAAsB,EAAE,sBAPZ;IAQZ,oBAAoB,EAAE,oBAAoB,IAAI,CAAC,UARnC;IASZ,sBAAsB,EAAE,sBATZ;IAUZ,kCAAkC,EAAA,IAVtB;IAWZ,MAAM,EAAE,aAAa,CAAC,oBAAd,GAAqC,0BAArC,GAAkE;EAX9D,CAAd,EAcG,WAAW,IAAI,aAAa,CAAC,oBAA7B,IACC,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;IAAK,SAAS,EAAE,UAAU,CAAC;EAA3B,CAAA,EACG,WAAW,CAAC,qBAAZ,GACC,KAAA,CAAA,aAAA,CAAC,IAAD,EAAK,QAAA,CAAA,EAAA,EAAK,WAAW,CAAC,qBAAjB,CAAL,CADD,GAGC,KAAA,CAAA,aAAA,CAAC,IAAD,EAAK;IAAC,QAAQ,EAAC,MAAV;IAAiB,SAAS,EAAE,UAAU,CAAC;EAAvC,CAAL,CAJJ,CAfJ,EAuBE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;IAAK,GAAG,EAAE,kBAAV;IAA8B,SAAS,EAAE,UAAU,CAAC,iBAApD;IAAqE,sBAAA;EAArE,CAAA,EACG,WAAW,IAAI,eAAf,IACC,KAAA,CAAA,aAAA,CAAC,WAAW,CAAC,IAAb,EAAiB;IACf,KAAK,EAAE,CACL;MAAE,GAAG,EAAE,MAAP;MAAe,IAAI,EAAE,WAAW,CAAC,gBAAjC;MAAmD,OAAO,EAAE;IAA5D,CADK,EAEL;MAAE,GAAG,EAAE,OAAP;MAAgB,IAAI,EAAE,WAAW,CAAC,iBAAlC;MAAqD,OAAO,EAAE;IAA9D,CAFK,CADQ;IAKf,SAAS,EAAE,iBALI;IAMf,eAAe,EAAA,IANA;IAOf,WAAW,EAAA,IAPI;IAQf,eAAe,EAAE,eAAe,CAAC,WARlB;IASf,oBAAoB,EAAA,IATL;IAUf,kBAAkB,EAAA,IAVH;IAWf,MAAM,EAAE,aAAa,CAAC;EAXP,CAAjB,CAFJ,EAgBG,QAhBH,CAvBF,CADF;EA6CA,OACG,WAAW,IAAI,mBAAoB,KAAK,cAAc,IAAI,cAAc,CAAC,KAAtC,CAAnC,IACC,KAAA,CAAA,aAAA,CAAC,KAAD,EAAM,QAAA,CAAA;IAAC,GAAG,EAAE;EAAN,CAAA,EAAqB,gBAArB,CAAN,EACE,KAAA,CAAA,aAAA,CAAC,KAAD,EAAM;IACJ,IAAI,EAAE,WAAW,GAAG,aAAH,GAAmB,QADhC;IAEJ,cAAc,EAAE,WAFZ;IAGJ,eAAe,EAAE,cAHb;IAIJ,SAAS,EAAE,SAJP;IAKJ,kBAAkB,EAAE,CAAC,sBALjB;IAMJ;IACA;IACA,wBAAwB,EAAE,wBARtB;IAQ8C,cACtC,CAAC;EATT,CAAN,EAWE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;IAAK,SAAS,EAAE,UAAU,CAAC,IAA3B;IAAiC,IAAI,EAAE,CAAC,UAAD,GAAc,UAAd,GAA2B;EAAlE,CAAA,EACG,CAAC,UAAD,IACC,KAAA,CAAA,aAAA,CAAC,OAAD,EAAQ,QAAA,CAAA;IAAA,eACO,IADP;IAEN,YAAY,EAAE,aAFR;IAGN,OAAO,EAAE,UAAU,GAAG,SAAH,GAAe,SAH5B;IAIN,oBAAoB,EAAE;EAJhB,CAAA,EAKF,OALE,CAAR,CAFJ,EAUG,WAAW,GACV,KAAA,CAAA,aAAA,CAAC,aAAD,EAAc;IACZ,cAAc,EAAE,WAAW,CAAC,kBAAZ,IAAkC,MAAI,eAD1C;IAEZ,mBAAmB,EAAC,QAFR;IAGZ,OAAO,EAAE,eAHG;IAIZ,YAAY,EAAE,UAJF;IAKZ,MAAM,EAAE,cALI;IAMZ,QAAQ,EAAE;EANE,CAAd,EAQG,YARH,CADU,GAYV,YAtBJ,CAXF,CADF,CADF,IAyCA,IA1CF;AA4CD,CAxZ4D,CAAxD;AA0ZP,SAAS,CAAC,WAAV,GAAwB,OAAxB;;AAEA,SAAS,gBAAT,CAA0B,KAA1B,EAA4C;EAC1C,IAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA7B,EAA2C;IACzC;IACA,WAAW,CAAC;MACV,IAAI,EAAE,OADI;MAEV,KAAK,EAAA,KAFK;MAGV,YAAY,EAAE;QAAE,eAAe,EAAE;MAAnB;IAHJ,CAAD,CAAX;EAKD;AACF","sourcesContent":["import * as React from 'react';\nimport {\n  classNamesFunction,\n  allowScrollOnElement,\n  allowOverscrollOnElement,\n  getPropsWithDefaults,\n  KeyCodes,\n  elementContains,\n  EventGroup,\n} from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport {\n  useBoolean,\n  useMergedRefs,\n  useWarnings,\n  useConst,\n  useSetTimeout,\n  useId,\n  useUnmount,\n} from '@fluentui/react-hooks';\nimport type { IFocusTrapZone } from '../../FocusTrapZone';\nimport type { IDragOptions, IModalProps, IModalStyleProps, IModalStyles } from './Modal.types';\nimport type { ILayerProps } from '../../Layer';\nimport type { ICoordinates, IDragData } from '../../utilities/DraggableZone/index';\n\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\ninterface IModalInternalState {\n  onModalCloseTimer: number;\n  allowTouchBodyScroll?: boolean;\n  scrollableContent: HTMLDivElement | null;\n  lastSetCoordinates: ICoordinates;\n  /** Minimum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  minPosition?: ICoordinates;\n  /** Maximum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  maxPosition?: ICoordinates;\n  events: EventGroup;\n  /** Ensures we dispose the same keydown callback as was registered */\n  disposeOnKeyDown?: () => void;\n  /** Ensures we dispose the same keyup callback as was registered (also tracks whether keyup has been registered) */\n  disposeOnKeyUp?: () => void;\n  isInKeyboardMoveMode?: boolean;\n  hasBeenOpened?: boolean;\n}\n\nconst ZERO: ICoordinates = { x: 0, y: 0 };\n\nconst DEFAULT_PROPS: Partial<IModalProps> = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true,\n};\n\nconst getClassNames = classNamesFunction<IModalStyleProps, IModalStyles>();\n\nconst getMoveDelta = (ev: React.KeyboardEvent<HTMLElement>): number => {\n  let delta = 10;\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nconst useComponentRef = (props: IModalProps, focusTrapZone: React.RefObject<IFocusTrapZone>) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      },\n    }),\n    [focusTrapZone],\n  );\n};\n\nexport const ModalBase: React.FunctionComponent<IModalProps> = React.forwardRef<HTMLDivElement, IModalProps>(\n  (propsWithoutDefaults, ref) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const {\n      allowTouchBodyScroll,\n      className,\n      children,\n      containerClassName,\n      scrollableContentClassName,\n      elementToFocusOnDismiss,\n      firstFocusableSelector,\n      forceFocusInsideTrap,\n      ignoreExternalFocusing,\n      isBlocking,\n      isAlert,\n      isClickableOutsideFocusTrap,\n      isDarkOverlay,\n      onDismiss,\n      layerProps,\n      overlay,\n      isOpen,\n      titleAriaId,\n      styles,\n      subtitleAriaId,\n      theme,\n      topOffsetFixed,\n      responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount,\n      isModeless,\n      dragOptions,\n      onDismissed,\n      // eslint-disable-next-line deprecation/deprecation\n      enableAriaHiddenSiblings,\n    } = props;\n\n    const rootRef = React.useRef<HTMLDivElement>(null);\n    const focusTrapZone = React.useRef<IFocusTrapZone>(null);\n    const focusTrapZoneElm = React.useRef<HTMLDivElement>(null);\n    const mergedRef = useMergedRefs(rootRef, ref);\n\n    const modalResponsiveMode = useResponsiveMode(mergedRef);\n\n    const focusTrapZoneId = useId('ModalFocusTrapZone');\n\n    const win = useWindow();\n\n    const { setTimeout, clearTimeout } = useSetTimeout();\n\n    const [isModalOpen, setIsModalOpen] = React.useState(isOpen);\n    const [isVisible, setIsVisible] = React.useState(isOpen);\n    const [coordinates, setCoordinates] = React.useState<ICoordinates>(ZERO);\n    const [modalRectangleTop, setModalRectangleTop] = React.useState<number | undefined>();\n\n    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = useBoolean(false);\n\n    const internalState = useConst<IModalInternalState>(() => ({\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({}),\n    }));\n\n    const { keepInBounds } = dragOptions || ({} as IDragOptions);\n    const isAlertRole = isAlert ?? (isBlocking && !isModeless);\n\n    const layerClassName = layerProps === undefined ? '' : layerProps.className;\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      isOpen,\n      isVisible,\n      hasBeenOpened: internalState.hasBeenOpened,\n      modalRectangleTop,\n      topOffsetFixed,\n      isModeless,\n      layerClassName,\n      windowInnerHeight: win?.innerHeight,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,\n    });\n\n    const mergedLayerProps: ILayerProps = {\n      eventBubblingEnabled: false,\n      ...layerProps,\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer,\n    };\n\n    // Allow the user to scroll within the modal but not on the body\n    const allowScrollOnModal = React.useCallback(\n      (elt: HTMLDivElement | null): void => {\n        if (elt) {\n          if (internalState.allowTouchBodyScroll) {\n            allowOverscrollOnElement(elt, internalState.events);\n          } else {\n            allowScrollOnElement(elt, internalState.events);\n          }\n        } else {\n          internalState.events.off(internalState.scrollableContent);\n        }\n        internalState.scrollableContent = elt;\n      },\n      [internalState],\n    );\n\n    const registerInitialModalPosition = (): void => {\n      const dialogMain = focusTrapZoneElm.current;\n      const modalRectangle = dialogMain?.getBoundingClientRect();\n\n      if (modalRectangle) {\n        if (topOffsetFixed) {\n          setModalRectangleTop(modalRectangle.top);\n        }\n\n        if (keepInBounds) {\n          // x/y are unavailable in IE, so use the equivalent left/top\n          internalState.minPosition = { x: -modalRectangle.left, y: -modalRectangle.top };\n          internalState.maxPosition = { x: modalRectangle.left, y: modalRectangle.top };\n        }\n      }\n    };\n\n    /**\n     * Clamps an axis to a specified min and max position.\n     *\n     * @param axis A string that represents the axis (x/y).\n     * @param position The position on the axis.\n     */\n    const getClampedAxis = React.useCallback(\n      (axis: keyof ICoordinates, position: number) => {\n        const { minPosition, maxPosition } = internalState;\n        if (keepInBounds && minPosition && maxPosition) {\n          position = Math.max(minPosition[axis], position);\n          position = Math.min(maxPosition[axis], position);\n        }\n        return position;\n      },\n      [keepInBounds, internalState],\n    );\n\n    const handleModalClose = (): void => {\n      internalState.lastSetCoordinates = ZERO;\n\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n      setIsModalOpen(false);\n      setCoordinates(ZERO);\n\n      internalState.disposeOnKeyUp?.();\n\n      onDismissed?.();\n    };\n\n    const handleDragStart = React.useCallback((): void => {\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n    }, [internalState, setModalMenuClose]);\n\n    const handleDrag = React.useCallback(\n      (ev: React.MouseEvent<HTMLElement> & React.TouchEvent<HTMLElement>, dragData: IDragData): void => {\n        setCoordinates(prevValue => ({\n          x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n          y: getClampedAxis('y', prevValue.y + dragData.delta.y),\n        }));\n      },\n      [getClampedAxis],\n    );\n\n    const handleDragStop = React.useCallback((): void => {\n      if (focusTrapZone.current) {\n        focusTrapZone.current.focus();\n      }\n    }, []);\n\n    const handleEnterKeyboardMoveMode = () => {\n      // We need a global handleKeyDown event when we are in the move mode so that we can\n      // handle the key presses and the components inside the modal do not get the events\n      const handleKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          // CTRL + ALT + SPACE is handled during keyUp\n          ev.preventDefault();\n          ev.stopPropagation();\n          return;\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        const newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n        if (isModalMenuOpen && newLocal) {\n          setModalMenuClose();\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n          internalState.isInKeyboardMoveMode = false;\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        if (internalState.isInKeyboardMoveMode) {\n          let handledEvent = true;\n          const delta = getMoveDelta(ev);\n\n          // eslint-disable-next-line deprecation/deprecation\n          switch (ev.keyCode) {\n            /* eslint-disable no-fallthrough */\n            case KeyCodes.escape:\n              setCoordinates(internalState.lastSetCoordinates);\n            case KeyCodes.enter: {\n              // TODO: determine if fallthrough was intentional\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO;\n              // setIsInKeyboardMoveMode(false);\n              break;\n            }\n            case KeyCodes.up: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y - delta) }));\n              break;\n            }\n            case KeyCodes.down: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y + delta) }));\n              break;\n            }\n            case KeyCodes.left: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x - delta), y: prevValue.y }));\n              break;\n            }\n            case KeyCodes.right: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x + delta), y: prevValue.y }));\n              break;\n            }\n            default: {\n              handledEvent = false;\n            }\n          }\n          if (handledEvent) {\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      internalState.lastSetCoordinates = coordinates;\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = true;\n\n      internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);\n      internalState.disposeOnKeyDown = () => {\n        internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);\n        internalState.disposeOnKeyDown = undefined;\n      };\n    };\n\n    const handleExitKeyboardMoveMode = () => {\n      internalState.lastSetCoordinates = ZERO;\n      internalState.isInKeyboardMoveMode = false;\n      internalState.disposeOnKeyDown?.();\n    };\n\n    const registerForKeyUp = (): void => {\n      const handleKeyUp = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          if (elementContains(internalState.scrollableContent, ev.target as HTMLElement)) {\n            toggleModalMenuOpen();\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      if (!internalState.disposeOnKeyUp) {\n        internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);\n        internalState.disposeOnKeyUp = () => {\n          internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);\n          internalState.disposeOnKeyUp = undefined;\n        };\n      }\n    };\n\n    React.useEffect(() => {\n      clearTimeout(internalState.onModalCloseTimer);\n      // Opening the dialog\n      if (isOpen) {\n        // This must be done after the modal content has rendered\n        requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));\n\n        setIsModalOpen(true);\n\n        // Add a keyUp handler for all key up events once the dialog is open.\n        if (dragOptions) {\n          registerForKeyUp();\n        }\n\n        internalState.hasBeenOpened = true;\n        setIsVisible(true);\n      }\n\n      // Closing the dialog\n      if (!isOpen && isModalOpen) {\n        internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n        setIsVisible(false);\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n    }, [isModalOpen, isOpen]);\n\n    useUnmount(() => {\n      internalState.events.dispose();\n    });\n\n    useComponentRef(props, focusTrapZone);\n    useDebugWarnings(props);\n\n    const modalContent = (\n      <FocusTrapZone\n        id={focusTrapZoneId}\n        ref={focusTrapZoneElm}\n        componentRef={focusTrapZone}\n        className={classNames.main}\n        elementToFocusOnDismiss={elementToFocusOnDismiss}\n        isClickableOutsideFocusTrap={isModeless || isClickableOutsideFocusTrap || !isBlocking}\n        ignoreExternalFocusing={ignoreExternalFocusing}\n        forceFocusInsideTrap={forceFocusInsideTrap && !isModeless}\n        firstFocusableSelector={firstFocusableSelector}\n        focusPreviouslyFocusedInnerElement\n        onBlur={internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined}\n        // enableAriaHiddenSiblings is handled by the Popup\n      >\n        {dragOptions && internalState.isInKeyboardMoveMode && (\n          <div className={classNames.keyboardMoveIconContainer}>\n            {dragOptions.keyboardMoveIconProps ? (\n              <Icon {...dragOptions.keyboardMoveIconProps} />\n            ) : (\n              <Icon iconName=\"move\" className={classNames.keyboardMoveIcon} />\n            )}\n          </div>\n        )}\n        <div ref={allowScrollOnModal} className={classNames.scrollableContent} data-is-scrollable>\n          {dragOptions && isModalMenuOpen && (\n            <dragOptions.menu\n              items={[\n                { key: 'move', text: dragOptions.moveMenuItemText, onClick: handleEnterKeyboardMoveMode },\n                { key: 'close', text: dragOptions.closeMenuItemText, onClick: handleModalClose },\n              ]}\n              onDismiss={setModalMenuClose}\n              alignTargetEdge\n              coverTarget\n              directionalHint={DirectionalHint.topLeftEdge}\n              directionalHintFixed\n              shouldFocusOnMount\n              target={internalState.scrollableContent}\n            />\n          )}\n          {children}\n        </div>\n      </FocusTrapZone>\n    );\n\n    return (\n      (isModalOpen && modalResponsiveMode! >= (responsiveMode || ResponsiveMode.small) && (\n        <Layer ref={mergedRef} {...mergedLayerProps}>\n          <Popup\n            role={isAlertRole ? 'alertdialog' : 'dialog'}\n            ariaLabelledBy={titleAriaId}\n            ariaDescribedBy={subtitleAriaId}\n            onDismiss={onDismiss}\n            shouldRestoreFocus={!ignoreExternalFocusing}\n            // Modeless modals shouldn't hide siblings.\n            // Popup will automatically handle this based on the aria-modal setting.\n            enableAriaHiddenSiblings={enableAriaHiddenSiblings}\n            aria-modal={!isModeless}\n          >\n            <div className={classNames.root} role={!isModeless ? 'document' : undefined}>\n              {!isModeless && (\n                <Overlay\n                  aria-hidden={true}\n                  isDarkThemed={isDarkOverlay}\n                  onClick={isBlocking ? undefined : onDismiss}\n                  allowTouchBodyScroll={allowTouchBodyScroll}\n                  {...overlay}\n                />\n              )}\n              {dragOptions ? (\n                <DraggableZone\n                  handleSelector={dragOptions.dragHandleSelector || `#${focusTrapZoneId}`}\n                  preventDragSelector=\"button\"\n                  onStart={handleDragStart}\n                  onDragChange={handleDrag}\n                  onStop={handleDragStop}\n                  position={coordinates}\n                >\n                  {modalContent}\n                </DraggableZone>\n              ) : (\n                modalContent\n              )}\n            </div>\n          </Popup>\n        </Layer>\n      )) ||\n      null\n    );\n  },\n);\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props: IModalProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props,\n      deprecations: { onLayerDidMount: 'layerProps.onLayerDidMount' },\n    });\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}