{"ast":null,"code":"/**\n * Determines the distance between two points.\n *\n * @public\n */\n\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1, point2) {\n  var left1 = point1.left || point1.x || 0;\n  var top1 = point1.top || point1.y || 0;\n  var left2 = point2.left || point2.x || 0;\n  var top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  var distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n  return distance;\n}\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\n\nexport function fitContentToBounds(options) {\n  var contentSize = options.contentSize,\n      boundsSize = options.boundsSize,\n      _a = options.mode,\n      mode = _a === void 0 ? 'contain' : _a,\n      _b = options.maxScale,\n      maxScale = _b === void 0 ? 1 : _b;\n  var contentAspectRatio = contentSize.width / contentSize.height;\n  var boundsAspectRatio = boundsSize.width / boundsSize.height;\n  var scale;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  var finalScale = Math.min(maxScale, scale);\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale\n  };\n}\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\n\nexport function calculatePrecision(value) {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  var groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n\n  if (!groups) {\n    return 0;\n  }\n\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n\n  if (groups[2]) {\n    return groups[2].length;\n  }\n\n  return 0;\n}\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\n\nexport function precisionRound(value, precision, base) {\n  if (base === void 0) {\n    base = 10;\n  }\n\n  var exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}","map":{"version":3,"sources":["math.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Point } from './Point';\nimport type { ISize } from './ISize';\n\n/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1: Point, point2: Point): number {\n  const left1 = point1.left || point1.x || 0;\n  const top1 = point1.top || point1.y || 0;\n  const left2 = point2.left || point2.x || 0;\n  const top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  let distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n\n  return distance;\n}\n\n/**\n * The available fit modes. These should match the fit modes for CSS.\n */\nexport type FitMode = 'contain' | 'cover';\n\n/**\n * Options for fitting content sizes into bounding sizes.\n */\nexport interface IFitContentToBoundsOptions {\n  /**\n   * The size of the content to fit to the bounds.\n   * The output will be proportional to this value.\n   */\n  contentSize: ISize;\n  /**\n   * The size of the bounds.\n   */\n  boundsSize: ISize;\n  /**\n   * The fit mode to apply, either 'contain' or 'cover'.\n   */\n  mode: FitMode;\n  /**\n   * An optional maximum scale factor to apply. The default is 1.\n   * Use Infinity for an unbounded resize.\n   */\n  maxScale?: number;\n}\n\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options: IFitContentToBoundsOptions): ISize {\n  const { contentSize, boundsSize, mode = 'contain', maxScale = 1 } = options;\n\n  const contentAspectRatio = contentSize.width / contentSize.height;\n  const boundsAspectRatio = boundsSize.width / boundsSize.height;\n\n  let scale: number;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  const finalScale = Math.min(maxScale, scale);\n\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale,\n  };\n}\n\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value: number | string): number {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  const groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value: number, precision: number, base: number = 10): number {\n  const exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}