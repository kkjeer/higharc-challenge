{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, initializeComponentRef, warnDeprecations, warn } from '../../Utilities';\nimport { TextField } from '../../TextField';\nimport { TooltipHost } from '../../Tooltip';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ColorRectangle } from './ColorRectangle/ColorRectangle';\nimport { ColorSlider } from './ColorSlider/ColorSlider';\nimport { MAX_COLOR_ALPHA, MAX_COLOR_RGB, MAX_HEX_LENGTH, MAX_RGBA_LENGTH, MIN_HEX_LENGTH, MIN_RGBA_LENGTH, HEX_REGEX, RGBA_REGEX } from '../../utilities/color/consts'; // These imports are separated to help with bundling\n\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { getColorFromRGBA } from '../../utilities/color/getColorFromRGBA';\nimport { clamp } from '../../utilities/color/clamp';\nimport { updateA } from '../../utilities/color/updateA';\nimport { updateT } from '../../utilities/color/updateT';\nimport { updateH } from '../../utilities/color/updateH';\nimport { correctRGB } from '../../utilities/color/correctRGB';\nimport { correctHex } from '../../utilities/color/correctHex';\nimport { ColorRectangleBase } from './ColorRectangle/ColorRectangle.base';\nvar getClassNames = classNamesFunction();\nvar allColorComponents = ['hex', 'r', 'g', 'b', 'a', 't'];\nvar errorKeys = {\n  hex: 'hexError',\n  r: 'redError',\n  g: 'greenError',\n  b: 'blueError',\n  a: 'alphaError',\n  t: 'transparencyError'\n};\n/**\n * {@docCategory ColorPicker}\n */\n\nvar ColorPickerBase =\n/** @class */\nfunction (_super) {\n  __extends(ColorPickerBase, _super);\n\n  function ColorPickerBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._onSVChanged = function (ev, color) {\n      _this._updateColor(ev, color);\n    };\n\n    _this._onHChanged = function (ev, h) {\n      _this._updateColor(ev, updateH(_this.state.color, h));\n    };\n    /** Callback for when the alpha/transparency slider changes */\n\n\n    _this._onATChanged = function (ev, value) {\n      var updater = _this.props.alphaType === 'transparency' ? updateT : updateA;\n\n      _this._updateColor(ev, updater(_this.state.color, Math.round(value)));\n    };\n\n    _this._onBlur = function (event) {\n      var _a;\n\n      var _b = _this.state,\n          color = _b.color,\n          editingColor = _b.editingColor;\n\n      if (!editingColor) {\n        return;\n      } // If there was an intermediate incorrect value (such as too large or empty), correct it.\n\n\n      var value = editingColor.value,\n          component = editingColor.component;\n      var isHex = component === 'hex';\n      var isAlpha = component === 'a';\n      var isTransparency = component === 't';\n      var minLength = isHex ? MIN_HEX_LENGTH : MIN_RGBA_LENGTH;\n\n      if (value.length >= minLength && (isHex || !isNaN(Number(value)))) {\n        // Real value. Clamp to appropriate length (hex) or range (rgba).\n        var newColor = void 0;\n\n        if (isHex) {\n          newColor = getColorFromString('#' + correctHex(value));\n        } else if (isAlpha || isTransparency) {\n          var updater = isAlpha ? updateA : updateT;\n          newColor = updater(color, clamp(Number(value), MAX_COLOR_ALPHA));\n        } else {\n          newColor = getColorFromRGBA(correctRGB(__assign(__assign({}, color), (_a = {}, _a[component] = Number(value), _a))));\n        } // Update state and call onChange\n\n\n        _this._updateColor(event, newColor);\n      } else {\n        // Intermediate value was an empty string or too short (hex only).\n        // Just clear the intermediate state and revert to the previous value.\n        _this.setState({\n          editingColor: undefined\n        });\n      }\n    };\n\n    initializeComponentRef(_this);\n    var strings = props.strings; // always defined since it's in defaultProps\n\n    warnDeprecations('ColorPicker', props, {\n      hexLabel: 'strings.hex',\n      redLabel: 'strings.red',\n      greenLabel: 'strings.green',\n      blueLabel: 'strings.blue',\n      alphaLabel: 'strings.alpha',\n      alphaSliderHidden: 'alphaType'\n    }); // eslint-disable-next-line deprecation/deprecation\n\n    if (strings.hue) {\n      // warnDeprecations can't handle nested deprecated props\n      warn(\"ColorPicker property 'strings.hue' was used but has been deprecated. Use 'strings.hueAriaLabel' instead.\");\n    }\n\n    _this.state = {\n      color: _getColorFromProps(props) || getColorFromString('#ffffff')\n    };\n    _this._textChangeHandlers = {};\n\n    for (var _i = 0, allColorComponents_1 = allColorComponents; _i < allColorComponents_1.length; _i++) {\n      var component = allColorComponents_1[_i];\n      _this._textChangeHandlers[component] = _this._onTextChange.bind(_this, component);\n    }\n\n    var defaultStrings = ColorPickerBase.defaultProps.strings;\n    _this._textLabels = {\n      /* eslint-disable deprecation/deprecation */\n      r: props.redLabel || strings.red || defaultStrings.red,\n      g: props.greenLabel || strings.green || defaultStrings.green,\n      b: props.blueLabel || strings.blue || defaultStrings.blue,\n      a: props.alphaLabel || strings.alpha || defaultStrings.alpha,\n      hex: props.hexLabel || strings.hex || defaultStrings.hex,\n      t: strings.transparency || defaultStrings.transparency\n      /* eslint-enable deprecation/deprecation */\n\n    };\n    _this._strings = __assign(__assign(__assign({}, defaultStrings), {\n      // these aria labels default to the visible labels\n      alphaAriaLabel: _this._textLabels.a,\n      transparencyAriaLabel: _this._textLabels.t\n    }), strings);\n    return _this;\n  }\n\n  Object.defineProperty(ColorPickerBase.prototype, \"color\", {\n    get: function () {\n      return this.state.color;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ColorPickerBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // if props changed (as opposed to a state update), update the color\n    if (prevProps !== this.props) {\n      var color = _getColorFromProps(this.props);\n\n      if (color) {\n        this._updateColor(undefined, color);\n      }\n    }\n  };\n\n  ColorPickerBase.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var strings = this._strings;\n    var textLabels = this._textLabels;\n    var theme = props.theme,\n        className = props.className,\n        styles = props.styles,\n        alphaType = props.alphaType,\n        // eslint-disable-next-line deprecation/deprecation\n    _a = props.alphaSliderHidden,\n        // eslint-disable-next-line deprecation/deprecation\n    alphaSliderHidden = _a === void 0 ? alphaType === 'none' : _a,\n        tooltipProps = props.tooltipProps;\n    var color = this.state.color;\n    var useTransparency = alphaType === 'transparency';\n    var colorComponents = ['hex', 'r', 'g', 'b', useTransparency ? 't' : 'a'];\n    var atValue = useTransparency ? color.t : color.a;\n    var atLabel = useTransparency ? textLabels.t : textLabels.a;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      alphaType: alphaType\n    });\n    var selectedColorAriaParts = [textLabels.r, color.r, textLabels.g, color.g, textLabels.b, color.b];\n\n    if (!alphaSliderHidden && typeof atValue === 'number') {\n      selectedColorAriaParts.push(atLabel, atValue + \"%\");\n    }\n\n    var ariaLabel = strings.rootAriaLabelFormat.replace('{0}', selectedColorAriaParts.join(' '));\n    return React.createElement(\"div\", {\n      className: classNames.root,\n      role: \"group\",\n      \"aria-label\": ariaLabel\n    }, React.createElement(\"div\", {\n      className: classNames.panel\n    }, React.createElement(ColorRectangle, {\n      color: color,\n      onChange: this._onSVChanged,\n      ariaLabel: strings.svAriaLabel,\n      ariaDescription: strings.svAriaDescription,\n      ariaValueFormat: strings.svAriaValueFormat,\n      className: classNames.colorRectangle\n    }), React.createElement(\"div\", {\n      className: classNames.flexContainer\n    }, React.createElement(\"div\", {\n      className: classNames.flexSlider\n    }, React.createElement(ColorSlider, {\n      className: \"is-hue\",\n      type: \"hue\",\n      // eslint-disable-next-line deprecation/deprecation\n      ariaLabel: strings.hue || strings.hueAriaLabel,\n      value: color.h,\n      onChange: this._onHChanged\n    }), !alphaSliderHidden && React.createElement(ColorSlider, {\n      className: \"is-alpha\",\n      type: alphaType,\n      ariaLabel: useTransparency ? strings.transparencyAriaLabel : strings.alphaAriaLabel,\n      overlayColor: color.hex,\n      value: atValue,\n      onChange: this._onATChanged\n    })), props.showPreview && React.createElement(\"div\", {\n      className: classNames.flexPreviewBox\n    }, React.createElement(\"div\", {\n      className: classNames.colorSquare + ' is-preview',\n      style: {\n        backgroundColor: color.str\n      }\n    }))), React.createElement(\"table\", {\n      className: classNames.table,\n      role: \"group\",\n      cellPadding: \"0\",\n      cellSpacing: \"0\"\n    }, React.createElement(\"thead\", null, React.createElement(\"tr\", {\n      className: classNames.tableHeader\n    }, React.createElement(\"td\", {\n      className: classNames.tableHexCell\n    }, textLabels.hex), React.createElement(\"td\", null, textLabels.r), React.createElement(\"td\", null, textLabels.g), React.createElement(\"td\", null, textLabels.b), !alphaSliderHidden && React.createElement(\"td\", {\n      className: classNames.tableAlphaCell\n    }, atLabel))), React.createElement(\"tbody\", null, React.createElement(\"tr\", null, colorComponents.map(function (comp) {\n      if ((comp === 'a' || comp === 't') && alphaSliderHidden) {\n        return null;\n      }\n\n      var tooltipContent = _this._getTooltipValue(comp);\n\n      return React.createElement(\"td\", {\n        key: comp\n      }, React.createElement(TooltipHost, __assign({\n        content: tooltipContent,\n        directionalHint: DirectionalHint.bottomCenter,\n        role: \"alert\"\n      }, tooltipProps), React.createElement(TextField, {\n        className: classNames.input,\n        onChange: _this._textChangeHandlers[comp],\n        onBlur: _this._onBlur,\n        value: _this._getDisplayValue(comp),\n        spellCheck: false,\n        ariaLabel: textLabels[comp],\n        autoComplete: \"off\",\n        invalid: !!tooltipContent\n      })));\n    }))))));\n  };\n\n  ColorPickerBase.prototype._getDisplayValue = function (component) {\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor;\n\n    if (editingColor && editingColor.component === component) {\n      return editingColor.value;\n    }\n\n    if (component === 'hex') {\n      return color[component] || '';\n    } else if (typeof color[component] === 'number' && !isNaN(color[component])) {\n      return String(color[component]);\n    }\n\n    return '';\n  };\n  /* Get the error tooltip value for a component if the component is in an invalid state */\n\n\n  ColorPickerBase.prototype._getTooltipValue = function (component) {\n    var editingColor = this.state.editingColor; // if the component does not have an interim value, it is valid\n\n    if (!editingColor || editingColor.component !== component) {\n      return undefined;\n    }\n\n    var value = editingColor.value; // for hex, do not show a tooltip if the value is between 3-6 characters\n\n    if (component === 'hex' && value.length >= MIN_HEX_LENGTH && value.length <= MAX_HEX_LENGTH) {\n      return undefined;\n    }\n\n    var errorKey = errorKeys[component];\n    return this._strings[errorKey];\n  };\n\n  ColorPickerBase.prototype._onTextChange = function (component, event, newValue) {\n    var _a;\n\n    var color = this.state.color;\n    var isHex = component === 'hex';\n    var isAlpha = component === 'a';\n    var isTransparency = component === 't';\n    newValue = (newValue || '').substr(0, isHex ? MAX_HEX_LENGTH : MAX_RGBA_LENGTH); // Ignore what the user typed if it contains invalid characters\n\n    var validCharsRegex = isHex ? HEX_REGEX : RGBA_REGEX;\n\n    if (!validCharsRegex.test(newValue)) {\n      return;\n    } // Determine if the entry is valid (different methods for hex, alpha, and RGB)\n\n\n    var isValid;\n\n    if (newValue === '') {\n      // Empty string is obviously not valid\n      isValid = false;\n    } else if (isHex) {\n      // Technically hex values of length 3 are also valid, but committing the value here would\n      // cause it to be automatically converted to a value of length 6, which may not be what the\n      // user wanted if they're not finished typing. (Values of length 3 will be committed on blur.)\n      isValid = newValue.length === MAX_HEX_LENGTH;\n    } else if (isAlpha || isTransparency) {\n      isValid = Number(newValue) <= MAX_COLOR_ALPHA;\n    } else {\n      isValid = Number(newValue) <= MAX_COLOR_RGB;\n    }\n\n    if (!isValid) {\n      // If the new value is an empty string or other invalid value, save that to display.\n      // (if the user still hasn't entered anything on blur, the last value is restored)\n      this.setState({\n        editingColor: {\n          component: component,\n          value: newValue\n        }\n      });\n    } else if (String(color[component]) === newValue) {\n      // If the new value is the same as the current value, mostly ignore it.\n      // Exception is that if the user was previously editing the value (but hadn't yet entered\n      // a new valid value), we should clear the intermediate value.\n      if (this.state.editingColor) {\n        this.setState({\n          editingColor: undefined\n        });\n      }\n    } else {\n      // Should be a valid color. Update the value.\n      var newColor = isHex ? getColorFromString('#' + newValue) : isTransparency ? updateT(color, Number(newValue)) : getColorFromRGBA(__assign(__assign({}, color), (_a = {}, _a[component] = Number(newValue), _a)));\n\n      this._updateColor(event, newColor);\n    }\n  };\n  /**\n   * Update the displayed color and call change handlers if appropriate.\n   * @param ev - Event if call was triggered by an event (undefined if triggered by props change)\n   * @param newColor - Updated color\n   */\n\n\n  ColorPickerBase.prototype._updateColor = function (ev, newColor) {\n    if (!newColor) {\n      return;\n    }\n\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor; // For black or white, the hue can change without changing the string.\n\n    var isDifferentColor = newColor.h !== color.h || newColor.str !== color.str;\n\n    if (isDifferentColor || editingColor) {\n      // If ev is undefined, it's an update from props (which should be unconditionally respected\n      // and not call onChange).\n      if (ev && this.props.onChange) {\n        this.props.onChange(ev, newColor);\n\n        if (ev.defaultPrevented) {\n          return;\n        }\n      }\n\n      this.setState({\n        color: newColor,\n        editingColor: undefined\n      });\n    }\n  };\n\n  ColorPickerBase.defaultProps = {\n    alphaType: 'alpha',\n    strings: {\n      rootAriaLabelFormat: 'Color picker, {0} selected.',\n      hex: 'Hex',\n      red: 'Red',\n      green: 'Green',\n      blue: 'Blue',\n      alpha: 'Alpha',\n      transparency: 'Transparency',\n      hueAriaLabel: 'Hue',\n      svAriaLabel: ColorRectangleBase.defaultProps.ariaLabel,\n      svAriaValueFormat: ColorRectangleBase.defaultProps.ariaValueFormat,\n      svAriaDescription: ColorRectangleBase.defaultProps.ariaDescription,\n      hexError: 'Hex values must be between 3 and 6 characters long',\n      alphaError: 'Alpha must be between 0 and 100',\n      transparencyError: 'Transparency must be between 0 and 100',\n      redError: 'Red must be between 0 and 255',\n      greenError: 'Green must be between 0 and 255',\n      blueError: 'Blue must be between 0 and 255'\n    }\n  };\n  return ColorPickerBase;\n}(React.Component);\n\nexport { ColorPickerBase };\n\nfunction _getColorFromProps(props) {\n  var color = props.color;\n  return typeof color === 'string' ? getColorFromString(color) : color;\n}","map":{"version":3,"sources":["components/ColorPicker/ColorPicker.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, initializeComponentRef, warnDeprecations, warn } from '../../Utilities';\nimport { TextField } from '../../TextField';\nimport { TooltipHost } from '../../Tooltip';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ColorRectangle } from './ColorRectangle/ColorRectangle';\nimport { ColorSlider } from './ColorSlider/ColorSlider';\nimport {\n  MAX_COLOR_ALPHA,\n  MAX_COLOR_RGB,\n  MAX_HEX_LENGTH,\n  MAX_RGBA_LENGTH,\n  MIN_HEX_LENGTH,\n  MIN_RGBA_LENGTH,\n  HEX_REGEX,\n  RGBA_REGEX,\n} from '../../utilities/color/consts';\n// These imports are separated to help with bundling\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { getColorFromRGBA } from '../../utilities/color/getColorFromRGBA';\nimport { clamp } from '../../utilities/color/clamp';\nimport { updateA } from '../../utilities/color/updateA';\nimport { updateT } from '../../utilities/color/updateT';\nimport { updateH } from '../../utilities/color/updateH';\nimport { correctRGB } from '../../utilities/color/correctRGB';\nimport { correctHex } from '../../utilities/color/correctHex';\nimport { ColorRectangleBase } from './ColorRectangle/ColorRectangle.base';\nimport type {\n  IColorPickerProps,\n  IColorPickerStyleProps,\n  IColorPickerStyles,\n  IColorPicker,\n  IColorPickerStrings,\n} from './ColorPicker.types';\nimport type { IColor, IRGB } from '../../utilities/color/interfaces';\n\ntype ColorComponent = keyof Pick<IColor, 'r' | 'g' | 'b' | 'a' | 't' | 'hex'>;\ntype ColorErrorKeys = keyof Pick<\n  IColorPickerStrings,\n  'hexError' | 'alphaError' | 'transparencyError' | 'redError' | 'greenError' | 'blueError'\n>;\n\nexport interface IColorPickerState {\n  /** Most recently selected color */\n  color: IColor;\n  /** Color component currently being edited via a text field (if intermediate value is invalid) */\n  editingColor?: {\n    /** Which color component is being edited */\n    component: ColorComponent;\n    /** Currently entered value, which is not valid */\n    value: string;\n  };\n}\n\nconst getClassNames = classNamesFunction<IColorPickerStyleProps, IColorPickerStyles>();\n\nconst allColorComponents: ColorComponent[] = ['hex', 'r', 'g', 'b', 'a', 't'];\n\nconst errorKeys: { [component in ColorComponent]: ColorErrorKeys } = {\n  hex: 'hexError',\n  r: 'redError',\n  g: 'greenError',\n  b: 'blueError',\n  a: 'alphaError',\n  t: 'transparencyError',\n};\n\n/**\n * {@docCategory ColorPicker}\n */\nexport class ColorPickerBase extends React.Component<IColorPickerProps, IColorPickerState> implements IColorPicker {\n  public static defaultProps: Partial<IColorPickerProps> = {\n    alphaType: 'alpha',\n    strings: {\n      rootAriaLabelFormat: 'Color picker, {0} selected.',\n      hex: 'Hex',\n      red: 'Red',\n      green: 'Green',\n      blue: 'Blue',\n      alpha: 'Alpha',\n      transparency: 'Transparency',\n      hueAriaLabel: 'Hue',\n      svAriaLabel: ColorRectangleBase.defaultProps.ariaLabel!,\n      svAriaValueFormat: ColorRectangleBase.defaultProps.ariaValueFormat!,\n      svAriaDescription: ColorRectangleBase.defaultProps.ariaDescription!,\n      hexError: 'Hex values must be between 3 and 6 characters long',\n      alphaError: 'Alpha must be between 0 and 100',\n      transparencyError: 'Transparency must be between 0 and 100',\n      redError: 'Red must be between 0 and 255',\n      greenError: 'Green must be between 0 and 255',\n      blueError: 'Blue must be between 0 and 255',\n    },\n  };\n\n  private _textChangeHandlers: {\n    [K in ColorComponent]: (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, newValue?: string) => void;\n  };\n  /**\n   * Strings displayed in the UI as text field labels (these are in a separate object for convenient\n   * indexing by short color component name).\n   */\n  private _textLabels: { [K in ColorComponent]: string };\n\n  /** Strings besides red/green/blue/alpha/hex, with defaults for all values except the deprecated `hue` */\n  private _strings: Required<Omit<IColorPickerStrings, ColorComponent | 'hue'>> & Pick<IColorPickerStrings, 'hue'>;\n\n  constructor(props: IColorPickerProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    const strings = props.strings!; // always defined since it's in defaultProps\n\n    warnDeprecations('ColorPicker', props, {\n      hexLabel: 'strings.hex',\n      redLabel: 'strings.red',\n      greenLabel: 'strings.green',\n      blueLabel: 'strings.blue',\n      alphaLabel: 'strings.alpha',\n      alphaSliderHidden: 'alphaType',\n    });\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (strings.hue) {\n      // warnDeprecations can't handle nested deprecated props\n      warn(\"ColorPicker property 'strings.hue' was used but has been deprecated. Use 'strings.hueAriaLabel' instead.\");\n    }\n\n    this.state = {\n      color: _getColorFromProps(props) || getColorFromString('#ffffff')!,\n    };\n\n    this._textChangeHandlers = {} as any;\n    for (const component of allColorComponents) {\n      this._textChangeHandlers[component] = this._onTextChange.bind(this, component);\n    }\n\n    const defaultStrings = ColorPickerBase.defaultProps.strings as Required<IColorPickerStrings>;\n\n    this._textLabels = {\n      /* eslint-disable deprecation/deprecation */\n      r: props.redLabel || strings.red || defaultStrings.red,\n      g: props.greenLabel || strings.green || defaultStrings.green,\n      b: props.blueLabel || strings.blue || defaultStrings.blue,\n      a: props.alphaLabel || strings.alpha || defaultStrings.alpha,\n      hex: props.hexLabel || strings.hex || defaultStrings.hex,\n      t: strings.transparency || defaultStrings.transparency,\n      /* eslint-enable deprecation/deprecation */\n    };\n\n    this._strings = {\n      ...defaultStrings,\n      // these aria labels default to the visible labels\n      alphaAriaLabel: this._textLabels.a,\n      transparencyAriaLabel: this._textLabels.t,\n      ...strings,\n    };\n  }\n\n  public get color(): IColor {\n    return this.state.color;\n  }\n\n  public componentDidUpdate(prevProps: Readonly<IColorPickerProps>, prevState: Readonly<IColorPickerState>): void {\n    // if props changed (as opposed to a state update), update the color\n    if (prevProps !== this.props) {\n      const color = _getColorFromProps(this.props);\n      if (color) {\n        this._updateColor(undefined, color);\n      }\n    }\n  }\n\n  public render(): JSX.Element {\n    const props = this.props;\n    const strings = this._strings;\n    const textLabels = this._textLabels;\n    const {\n      theme,\n      className,\n      styles,\n      alphaType,\n      // eslint-disable-next-line deprecation/deprecation\n      alphaSliderHidden = alphaType === 'none',\n      tooltipProps,\n    } = props;\n    const { color } = this.state;\n    const useTransparency = alphaType === 'transparency';\n    const colorComponents = ['hex', 'r', 'g', 'b', useTransparency ? 't' : 'a'];\n    const atValue = useTransparency ? color.t : color.a;\n    const atLabel = useTransparency ? textLabels.t : textLabels.a;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      alphaType,\n    });\n\n    const selectedColorAriaParts = [textLabels.r, color.r, textLabels.g, color.g, textLabels.b, color.b];\n    if (!alphaSliderHidden && typeof atValue === 'number') {\n      selectedColorAriaParts.push(atLabel, `${atValue}%`);\n    }\n    const ariaLabel = strings.rootAriaLabelFormat.replace('{0}', selectedColorAriaParts.join(' '));\n\n    return (\n      <div className={classNames.root} role=\"group\" aria-label={ariaLabel}>\n        <div className={classNames.panel}>\n          <ColorRectangle\n            color={color}\n            onChange={this._onSVChanged}\n            ariaLabel={strings.svAriaLabel}\n            ariaDescription={strings.svAriaDescription}\n            ariaValueFormat={strings.svAriaValueFormat}\n            className={classNames.colorRectangle}\n          />\n          <div className={classNames.flexContainer}>\n            <div className={classNames.flexSlider}>\n              <ColorSlider\n                className=\"is-hue\"\n                type=\"hue\"\n                // eslint-disable-next-line deprecation/deprecation\n                ariaLabel={strings.hue || strings.hueAriaLabel}\n                value={color.h}\n                onChange={this._onHChanged}\n              />\n              {!alphaSliderHidden && (\n                <ColorSlider\n                  className=\"is-alpha\"\n                  type={alphaType as 'alpha' | 'transparency'}\n                  ariaLabel={useTransparency ? strings.transparencyAriaLabel : strings.alphaAriaLabel}\n                  overlayColor={color.hex}\n                  value={atValue}\n                  onChange={this._onATChanged}\n                />\n              )}\n            </div>\n            {props.showPreview && (\n              <div className={classNames.flexPreviewBox}>\n                <div\n                  className={classNames.colorSquare + ' is-preview'}\n                  style={{\n                    backgroundColor: color.str,\n                  }}\n                />\n              </div>\n            )}\n          </div>\n\n          {/* Give the table role=group to prevent it from being read as a table (ideally we should\n          just get rid of the table, but this has the potential of breaking consumers) */}\n          <table className={classNames.table} role=\"group\" cellPadding=\"0\" cellSpacing=\"0\">\n            <thead>\n              <tr className={classNames.tableHeader}>\n                <td className={classNames.tableHexCell}>{textLabels.hex}</td>\n                <td>{textLabels.r}</td>\n                <td>{textLabels.g}</td>\n                <td>{textLabels.b}</td>\n                {!alphaSliderHidden && <td className={classNames.tableAlphaCell}>{atLabel}</td>}\n              </tr>\n            </thead>\n            <tbody>\n              <tr>\n                {colorComponents.map((comp: ColorComponent) => {\n                  if ((comp === 'a' || comp === 't') && alphaSliderHidden) {\n                    return null;\n                  }\n                  const tooltipContent = this._getTooltipValue(comp);\n                  return (\n                    <td key={comp}>\n                      <TooltipHost\n                        content={tooltipContent}\n                        directionalHint={DirectionalHint.bottomCenter}\n                        role=\"alert\"\n                        {...tooltipProps}\n                      >\n                        <TextField\n                          className={classNames.input}\n                          onChange={this._textChangeHandlers[comp]}\n                          onBlur={this._onBlur}\n                          value={this._getDisplayValue(comp)}\n                          spellCheck={false}\n                          ariaLabel={textLabels[comp]}\n                          autoComplete=\"off\"\n                          invalid={!!tooltipContent}\n                        />\n                      </TooltipHost>\n                    </td>\n                  );\n                })}\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    );\n  }\n\n  private _getDisplayValue(component: ColorComponent): string {\n    const { color, editingColor } = this.state;\n    if (editingColor && editingColor.component === component) {\n      return editingColor.value;\n    }\n    if (component === 'hex') {\n      return color[component] || '';\n    } else if (typeof color[component] === 'number' && !isNaN(color[component] as number)) {\n      return String(color[component]);\n    }\n    return '';\n  }\n\n  /* Get the error tooltip value for a component if the component is in an invalid state */\n  private _getTooltipValue(component: ColorComponent): string | undefined {\n    const { editingColor } = this.state;\n    // if the component does not have an interim value, it is valid\n    if (!editingColor || editingColor.component !== component) {\n      return undefined;\n    }\n\n    const { value } = editingColor;\n    // for hex, do not show a tooltip if the value is between 3-6 characters\n    if (component === 'hex' && value.length >= MIN_HEX_LENGTH && value.length <= MAX_HEX_LENGTH) {\n      return undefined;\n    }\n\n    const errorKey: ColorErrorKeys = errorKeys[component];\n\n    return this._strings[errorKey];\n  }\n\n  private _onSVChanged = (ev: React.MouseEvent<HTMLElement>, color: IColor): void => {\n    this._updateColor(ev, color);\n  };\n\n  private _onHChanged = (ev: React.MouseEvent<HTMLElement>, h: number): void => {\n    this._updateColor(ev, updateH(this.state.color, h));\n  };\n\n  /** Callback for when the alpha/transparency slider changes */\n  private _onATChanged = (ev: React.MouseEvent<HTMLElement>, value: number): void => {\n    const updater = this.props.alphaType === 'transparency' ? updateT : updateA;\n    this._updateColor(ev, updater(this.state.color, Math.round(value)));\n  };\n\n  private _onTextChange(component: ColorComponent, event: React.FormEvent<HTMLInputElement>, newValue?: string): void {\n    const color = this.state.color;\n    const isHex = component === 'hex';\n    const isAlpha = component === 'a';\n    const isTransparency = component === 't';\n    newValue = (newValue || '').substr(0, isHex ? MAX_HEX_LENGTH : MAX_RGBA_LENGTH);\n\n    // Ignore what the user typed if it contains invalid characters\n    const validCharsRegex = isHex ? HEX_REGEX : RGBA_REGEX;\n    if (!validCharsRegex.test(newValue)) {\n      return;\n    }\n\n    // Determine if the entry is valid (different methods for hex, alpha, and RGB)\n    let isValid: boolean;\n    if (newValue === '') {\n      // Empty string is obviously not valid\n      isValid = false;\n    } else if (isHex) {\n      // Technically hex values of length 3 are also valid, but committing the value here would\n      // cause it to be automatically converted to a value of length 6, which may not be what the\n      // user wanted if they're not finished typing. (Values of length 3 will be committed on blur.)\n      isValid = newValue.length === MAX_HEX_LENGTH;\n    } else if (isAlpha || isTransparency) {\n      isValid = Number(newValue) <= MAX_COLOR_ALPHA;\n    } else {\n      isValid = Number(newValue) <= MAX_COLOR_RGB;\n    }\n\n    if (!isValid) {\n      // If the new value is an empty string or other invalid value, save that to display.\n      // (if the user still hasn't entered anything on blur, the last value is restored)\n      this.setState({ editingColor: { component, value: newValue } });\n    } else if (String(color[component]) === newValue) {\n      // If the new value is the same as the current value, mostly ignore it.\n      // Exception is that if the user was previously editing the value (but hadn't yet entered\n      // a new valid value), we should clear the intermediate value.\n      if (this.state.editingColor) {\n        this.setState({ editingColor: undefined });\n      }\n    } else {\n      // Should be a valid color. Update the value.\n      const newColor = isHex\n        ? getColorFromString('#' + newValue)\n        : isTransparency\n        ? updateT(color, Number(newValue))\n        : getColorFromRGBA({\n            ...color,\n            // Overwrite whichever key is being updated with the new value\n            [component]: Number(newValue),\n          });\n      this._updateColor(event, newColor);\n    }\n  }\n\n  private _onBlur = (event: React.FocusEvent<HTMLInputElement>) => {\n    const { color, editingColor } = this.state;\n    if (!editingColor) {\n      return;\n    }\n\n    // If there was an intermediate incorrect value (such as too large or empty), correct it.\n    const { value, component } = editingColor;\n    const isHex = component === 'hex';\n    const isAlpha = component === 'a';\n    const isTransparency = component === 't';\n    const minLength = isHex ? MIN_HEX_LENGTH : MIN_RGBA_LENGTH;\n    if (value.length >= minLength && (isHex || !isNaN(Number(value)))) {\n      // Real value. Clamp to appropriate length (hex) or range (rgba).\n      let newColor: IColor | undefined;\n      if (isHex) {\n        newColor = getColorFromString('#' + correctHex(value));\n      } else if (isAlpha || isTransparency) {\n        const updater = isAlpha ? updateA : updateT;\n        newColor = updater(color, clamp(Number(value), MAX_COLOR_ALPHA));\n      } else {\n        newColor = getColorFromRGBA(\n          correctRGB({\n            ...color,\n            [component]: Number(value),\n          } as IRGB),\n        );\n      }\n\n      // Update state and call onChange\n      this._updateColor(event, newColor);\n    } else {\n      // Intermediate value was an empty string or too short (hex only).\n      // Just clear the intermediate state and revert to the previous value.\n      this.setState({ editingColor: undefined });\n    }\n  };\n\n  /**\n   * Update the displayed color and call change handlers if appropriate.\n   * @param ev - Event if call was triggered by an event (undefined if triggered by props change)\n   * @param newColor - Updated color\n   */\n  private _updateColor(ev: React.SyntheticEvent<HTMLElement> | undefined, newColor: IColor | undefined): void {\n    if (!newColor) {\n      return;\n    }\n\n    const { color, editingColor } = this.state;\n    // For black or white, the hue can change without changing the string.\n    const isDifferentColor = newColor.h !== color.h || newColor.str !== color.str;\n\n    if (isDifferentColor || editingColor) {\n      // If ev is undefined, it's an update from props (which should be unconditionally respected\n      // and not call onChange).\n      if (ev && this.props.onChange) {\n        this.props.onChange(ev, newColor);\n        if (ev.defaultPrevented) {\n          return;\n        }\n      }\n      this.setState({ color: newColor, editingColor: undefined });\n    }\n  }\n}\n\nfunction _getColorFromProps(props: IColorPickerProps): IColor | undefined {\n  const { color } = props;\n  return typeof color === 'string' ? getColorFromString(color) : color;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}