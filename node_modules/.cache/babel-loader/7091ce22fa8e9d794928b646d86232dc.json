{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\nvar eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\n\nvar DraggableZone =\n/** @class */\nfunction (_super) {\n  __extends(DraggableZone, _super);\n\n  function DraggableZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._currentEventType = eventMapping.mouse;\n    _this._events = [];\n\n    _this._onMouseDown = function (event) {\n      var onMouseDown = React.Children.only(_this.props.children).props.onMouseDown;\n\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStart(event);\n    };\n\n    _this._onMouseUp = function (event) {\n      var onMouseUp = React.Children.only(_this.props.children).props.onMouseUp;\n\n      if (onMouseUp) {\n        onMouseUp(event);\n      }\n\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStop(event);\n    };\n\n    _this._onTouchStart = function (event) {\n      var onTouchStart = React.Children.only(_this.props.children).props.onTouchStart;\n\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n\n      _this._currentEventType = eventMapping.touch;\n      return _this._onDragStart(event);\n    };\n\n    _this._onTouchEnd = function (event) {\n      var onTouchEnd = React.Children.only(_this.props.children).props.onTouchEnd;\n\n      if (onTouchEnd) {\n        onTouchEnd(event);\n      }\n\n      _this._currentEventType = eventMapping.touch;\n\n      _this._onDragStop(event);\n    };\n\n    _this._onDragStart = function (event) {\n      // Only handle left click for dragging\n      if (typeof event.button === 'number' && event.button !== 0) {\n        return false;\n      } // If the target doesn't match the handleSelector OR\n      // if the target does match the preventDragSelector, bail out\n\n\n      if (_this.props.handleSelector && !_this._matchesSelector(event.target, _this.props.handleSelector) || _this.props.preventDragSelector && _this._matchesSelector(event.target, _this.props.preventDragSelector)) {\n        return;\n      } // Remember the touch identifier if this is a touch event so we can\n      // distinguish between individual touches in multitouch scenarios\n      // by remembering which touch point we were given\n\n\n      _this._touchId = _this._getTouchId(event);\n\n      var position = _this._getControlPosition(event);\n\n      if (position === undefined) {\n        return;\n      }\n\n      var dragData = _this._createDragDataFromPosition(position);\n\n      _this.props.onStart && _this.props.onStart(event, dragData);\n\n      _this.setState({\n        isDragging: true,\n        lastPosition: position\n      }); // hook up the appropriate mouse/touch events to the body to ensure\n      // smooth dragging\n\n\n      _this._events = [on(document.body, _this._currentEventType.move, _this._onDrag, true\n      /* use capture phase */\n      ), on(document.body, _this._currentEventType.stop, _this._onDragStop, true\n      /* use capture phase */\n      )];\n    };\n\n    _this._onDrag = function (event) {\n      // Prevent scrolling on mobile devices\n      if (event.type === 'touchmove') {\n        event.preventDefault();\n      }\n\n      var position = _this._getControlPosition(event);\n\n      if (!position) {\n        return;\n      } // create the updated drag data from the position data\n\n\n      var updatedData = _this._createUpdatedDragData(_this._createDragDataFromPosition(position));\n\n      var updatedPosition = updatedData.position;\n      _this.props.onDragChange && _this.props.onDragChange(event, updatedData);\n\n      _this.setState({\n        position: updatedPosition,\n        lastPosition: position\n      });\n    };\n\n    _this._onDragStop = function (event) {\n      if (!_this.state.isDragging) {\n        return;\n      }\n\n      var position = _this._getControlPosition(event);\n\n      if (!position) {\n        return;\n      }\n\n      var baseDragData = _this._createDragDataFromPosition(position); // Set dragging to false and reset the lastPosition\n\n\n      _this.setState({\n        isDragging: false,\n        lastPosition: undefined\n      });\n\n      _this.props.onStop && _this.props.onStop(event, baseDragData);\n\n      if (_this.props.position) {\n        _this.setState({\n          position: _this.props.position\n        });\n      } // Remove event handlers\n\n\n      _this._events.forEach(function (dispose) {\n        return dispose();\n      });\n    };\n\n    _this.state = {\n      isDragging: false,\n      position: _this.props.position || {\n        x: 0,\n        y: 0\n      },\n      lastPosition: undefined\n    };\n    return _this;\n  }\n\n  DraggableZone.prototype.componentDidUpdate = function (prevProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({\n        position: this.props.position\n      });\n    }\n  };\n\n  DraggableZone.prototype.componentWillUnmount = function () {\n    this._events.forEach(function (dispose) {\n      return dispose();\n    });\n  };\n\n  DraggableZone.prototype.render = function () {\n    var child = React.Children.only(this.props.children);\n    var props = child.props;\n    var position = this.props.position;\n    var _a = this.state,\n        statePosition = _a.position,\n        isDragging = _a.isDragging;\n    var x = statePosition.x;\n    var y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: __assign(__assign({}, props.style), {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }),\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd\n    });\n  };\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n\n\n  DraggableZone.prototype._getControlPosition = function (event) {\n    var touchObj = this._getActiveTouch(event); // did we get the right touch?\n\n\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    var eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY\n    };\n  };\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n\n\n  DraggableZone.prototype._getActiveTouch = function (event) {\n    return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);\n  };\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n\n\n  DraggableZone.prototype._getTouchId = function (event) {\n    var touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];\n\n    if (touch) {\n      return touch.identifier;\n    }\n  };\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n\n\n  DraggableZone.prototype._matchesSelector = function (element, selector) {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    var matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;\n    /* for IE */\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  };\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n\n\n  DraggableZone.prototype._findTouchInTouchList = function (touchList) {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (var i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n\n\n  DraggableZone.prototype._createDragDataFromPosition = function (position) {\n    var lastPosition = this.state.lastPosition; // If we have no lastPosition, use the given position\n    // for last position\n\n    if (lastPosition === undefined) {\n      return {\n        delta: {\n          x: 0,\n          y: 0\n        },\n        lastPosition: position,\n        position: position\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y\n      },\n      lastPosition: lastPosition,\n      position: position\n    };\n  };\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n\n\n  DraggableZone.prototype._createUpdatedDragData = function (baseDragData) {\n    var position = this.state.position;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y\n      },\n      delta: baseDragData.delta,\n      lastPosition: position\n    };\n  };\n\n  return DraggableZone;\n}(React.Component);\n\nexport { DraggableZone };","map":{"version":3,"sources":["utilities/DraggableZone/DraggableZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\nimport type { IDraggableZoneProps, ICoordinates, IDragData } from './DraggableZone.types';\n\nexport interface IDraggableZoneState {\n  isDragging: boolean;\n  position: ICoordinates;\n  lastPosition?: ICoordinates;\n}\n\nconst eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend',\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup',\n  },\n};\n\n// These are needed so that we can generalize the events\n// and so we have access to clientX and clientY in the touch events\ntype MouseTouchEvent<T> = React.MouseEvent<T> & React.TouchEvent<T> & Event;\n\nexport class DraggableZone extends React.Component<IDraggableZoneProps, IDraggableZoneState> {\n  private _touchId?: number;\n  private _currentEventType = eventMapping.mouse;\n  private _events: (() => void)[] = [];\n\n  constructor(props: IDraggableZoneProps) {\n    super(props);\n\n    this.state = {\n      isDragging: false,\n      position: this.props.position || { x: 0, y: 0 },\n      lastPosition: undefined,\n    };\n  }\n\n  public componentDidUpdate(prevProps: IDraggableZoneProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({ position: this.props.position });\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.forEach(dispose => dispose());\n  }\n\n  public render() {\n    const child: any = React.Children.only(this.props.children);\n    const { props } = child;\n    const { position } = this.props;\n    const { position: statePosition, isDragging } = this.state;\n    let x = statePosition.x;\n    let y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: {\n        ...props.style,\n        transform: `translate(${x}px, ${y}px)`,\n      },\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd,\n    });\n  }\n\n  private _onMouseDown = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseDown = (React.Children.only(this.props.children) as any).props.onMouseDown;\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStart(event);\n  };\n\n  private _onMouseUp = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseUp = (React.Children.only(this.props.children) as any).props.onMouseUp;\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStop(event);\n  };\n\n  private _onTouchStart = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchStart = (React.Children.only(this.props.children) as any).props.onTouchStart;\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    return this._onDragStart(event);\n  };\n\n  private _onTouchEnd = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchEnd = (React.Children.only(this.props.children) as any).props.onTouchEnd;\n    if (onTouchEnd) {\n      onTouchEnd(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    this._onDragStop(event);\n  };\n\n  private _onDragStart = (event: MouseTouchEvent<HTMLElement>) => {\n    // Only handle left click for dragging\n    if (typeof event.button === 'number' && event.button !== 0) {\n      return false;\n    }\n\n    // If the target doesn't match the handleSelector OR\n    // if the target does match the preventDragSelector, bail out\n    if (\n      (this.props.handleSelector && !this._matchesSelector(event.target as HTMLElement, this.props.handleSelector)) ||\n      (this.props.preventDragSelector &&\n        this._matchesSelector(event.target as HTMLElement, this.props.preventDragSelector))\n    ) {\n      return;\n    }\n\n    // Remember the touch identifier if this is a touch event so we can\n    // distinguish between individual touches in multitouch scenarios\n    // by remembering which touch point we were given\n    this._touchId = this._getTouchId(event);\n\n    const position = this._getControlPosition(event);\n    if (position === undefined) {\n      return;\n    }\n\n    const dragData = this._createDragDataFromPosition(position);\n    this.props.onStart && this.props.onStart(event, dragData);\n\n    this.setState({\n      isDragging: true,\n      lastPosition: position,\n    });\n\n    // hook up the appropriate mouse/touch events to the body to ensure\n    // smooth dragging\n    this._events = [\n      on(document.body, this._currentEventType.move, this._onDrag, true /* use capture phase */),\n      on(document.body, this._currentEventType.stop, this._onDragStop, true /* use capture phase */),\n    ];\n  };\n\n  private _onDrag = (event: MouseTouchEvent<HTMLElement>) => {\n    // Prevent scrolling on mobile devices\n    if (event.type === 'touchmove') {\n      event.preventDefault();\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    // create the updated drag data from the position data\n    const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));\n    const updatedPosition = updatedData.position;\n\n    this.props.onDragChange && this.props.onDragChange(event, updatedData);\n\n    this.setState({\n      position: updatedPosition,\n      lastPosition: position,\n    });\n  };\n\n  private _onDragStop = (event: MouseTouchEvent<HTMLElement>) => {\n    if (!this.state.isDragging) {\n      return;\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    const baseDragData = this._createDragDataFromPosition(position);\n\n    // Set dragging to false and reset the lastPosition\n    this.setState({\n      isDragging: false,\n      lastPosition: undefined,\n    });\n\n    this.props.onStop && this.props.onStop(event, baseDragData);\n\n    if (this.props.position) {\n      this.setState({\n        position: this.props.position,\n      });\n    }\n\n    // Remove event handlers\n    this._events.forEach(dispose => dispose());\n  };\n\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n  private _getControlPosition(event: MouseTouchEvent<HTMLElement>): ICoordinates | undefined {\n    const touchObj = this._getActiveTouch(event);\n\n    // did we get the right touch?\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    const eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY,\n    };\n  }\n\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n  private _getActiveTouch(event: MouseTouchEvent<HTMLElement>): React.Touch | undefined {\n    return (\n      (event.targetTouches && this._findTouchInTouchList(event.targetTouches)) ||\n      (event.changedTouches && this._findTouchInTouchList(event.changedTouches))\n    );\n  }\n\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n  private _getTouchId(event: MouseTouchEvent<HTMLElement>): number | undefined {\n    const touch: React.Touch | undefined =\n      (event.targetTouches && event.targetTouches[0]) || (event.changedTouches && event.changedTouches[0]);\n\n    if (touch) {\n      return touch.identifier;\n    }\n  }\n\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n  private _matchesSelector(element: HTMLElement | null, selector: string): boolean {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    const matchesSelectorFn: Function =\n      element.matches || element.webkitMatchesSelector || (element as any).msMatchesSelector; /* for IE */\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  }\n\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n  private _findTouchInTouchList(touchList: React.TouchList): React.Touch | undefined {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n  private _createDragDataFromPosition(position: ICoordinates): IDragData {\n    const { lastPosition } = this.state;\n\n    // If we have no lastPosition, use the given position\n    // for last position\n    if (lastPosition === undefined) {\n      return {\n        delta: { x: 0, y: 0 },\n        lastPosition: position,\n        position,\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y,\n      },\n      lastPosition,\n      position,\n    };\n  }\n\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n  private _createUpdatedDragData(baseDragData: IDragData): IDragData {\n    const { position } = this.state;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y,\n      },\n      delta: baseDragData.delta,\n      lastPosition: position,\n    };\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}