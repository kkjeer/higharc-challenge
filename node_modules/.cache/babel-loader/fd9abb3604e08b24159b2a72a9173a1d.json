{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { divProperties, getNativeProps } from '../../Utilities';\nimport { ResizeGroupDirection } from './ResizeGroup.types';\nimport { useConst, useMergedRefs, useAsync, useOnEvent, useWarnings } from '@fluentui/react-hooks';\nimport { useWindow } from '../../WindowProvider';\nvar RESIZE_DELAY = 16;\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\n\nexport var getMeasurementCache = function () {\n  var measurementsCache = {};\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: function (data) {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: function (data, measurement) {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    }\n  };\n};\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\n\nexport var getNextResizeGroupStateProvider = function (measurementCache) {\n  if (measurementCache === void 0) {\n    measurementCache = getMeasurementCache();\n  }\n\n  var _measurementCache = measurementCache;\n\n  var _containerDimension;\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _getMeasuredDimension(measuredData, getElementToMeasureDimension) {\n    var cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    var measuredDimension = getElementToMeasureDimension();\n\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n\n    return measuredDimension;\n  }\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureDimension) {\n    var dataToMeasure = data;\n\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension) {\n      var nextMeasuredData = onReduceData(dataToMeasure); // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData); // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink'\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined\n    };\n  }\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureDimension, onReduceData) {\n    var dataToMeasure = data;\n\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension) {\n      var nextMeasuredData = onGrowData(dataToMeasure); // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData); // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    } // Once the loop is done, we should now shrink until the contents fit.\n\n\n    return __assign({\n      resizeDirection: 'shrink'\n    }, _shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension));\n  }\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n\n\n  function _updateContainerDimension(newDimension, fullDimensionData, renderedData, onGrowData) {\n    var nextState;\n\n    if (newDimension > _containerDimension) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData)\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData\n      };\n    }\n\n    _containerDimension = newDimension;\n    return __assign(__assign({}, nextState), {\n      measureContainer: false\n    });\n  }\n\n  function getNextState(props, currentState, getElementToMeasureDimension, newContainerDimension) {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return __assign(__assign({}, currentState), _updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData));\n      } // If we are just setting the container width/height for the first time, we can't do any optimizations\n\n\n      _containerDimension = newContainerDimension;\n    }\n\n    var nextState = __assign(__assign({}, currentState), {\n      measureContainer: false\n    });\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = __assign(__assign({}, nextState), _growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureDimension, props.onReduceData));\n      } else {\n        nextState = __assign(__assign({}, nextState), _shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension));\n      }\n    }\n\n    return nextState;\n  }\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n\n\n  function shouldRenderDataForMeasurement(dataToMeasure) {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data) {\n    return {\n      dataToMeasure: __assign({}, data),\n      resizeDirection: 'grow',\n      measureContainer: true\n    };\n  }\n\n  return {\n    getNextState: getNextState,\n    shouldRenderDataForMeasurement: shouldRenderDataForMeasurement,\n    getInitialResizeGroupState: getInitialResizeGroupState\n  };\n}; // Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\n\nexport var MeasuredContext = React.createContext({\n  isMeasured: false\n}); // Styles for the hidden div used for measurement\n\nvar hiddenDivStyles = {\n  position: 'fixed',\n  visibility: 'hidden'\n};\nvar hiddenParentStyles = {\n  position: 'relative'\n};\nvar COMPONENT_NAME = 'ResizeGroup';\n/**\n * Use useReducer instead of userState because React is not batching the state updates\n * when state is set in callbacks of setTimeout or requestAnimationFrame.\n * See issue: https://github.com/facebook/react/issues/14259\n */\n\nfunction resizeDataReducer(state, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'resizeData':\n      return __assign({}, action.value);\n\n    case 'dataToMeasure':\n      return __assign(__assign({}, state), {\n        dataToMeasure: action.value,\n        resizeDirection: 'grow',\n        measureContainer: true\n      });\n\n    default:\n      return __assign(__assign({}, state), (_a = {}, _a[action.type] = action.value, _a));\n  }\n}\n\nfunction useResizeState(props, nextResizeGroupStateProvider, rootRef) {\n  var initialStateData = useConst(function () {\n    return nextResizeGroupStateProvider.getInitialResizeGroupState(props.data);\n  });\n\n  var _a = React.useReducer(resizeDataReducer, initialStateData),\n      resizeData = _a[0],\n      dispatchResizeDataAction = _a[1]; // Reset state when new data is provided\n\n\n  React.useEffect(function () {\n    dispatchResizeDataAction({\n      type: 'dataToMeasure',\n      value: props.data\n    });\n  }, [props.data]); // Because it's possible that we may force more than one re-render per animation frame, we\n  // want to make sure that the RAF request is using the most recent data.\n\n  var stateRef = React.useRef(initialStateData);\n  stateRef.current = __assign({}, resizeData);\n  var updateResizeState = React.useCallback(function (nextState) {\n    if (nextState) {\n      dispatchResizeDataAction({\n        type: 'resizeData',\n        value: nextState\n      });\n    }\n  }, []);\n  var remeasure = React.useCallback(function () {\n    if (rootRef.current) {\n      dispatchResizeDataAction({\n        type: 'measureContainer',\n        value: true\n      });\n    }\n  }, [rootRef]);\n  return [stateRef, updateResizeState, remeasure];\n}\n\nfunction useResizingBehavior(props, rootRef) {\n  var nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider); // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n  // of the component being measured for the initial render.\n\n  var initialHiddenDiv = React.useRef(null); // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n  // div without unmounting the currently visible content.\n\n  var updateHiddenDiv = React.useRef(null); // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n  // for the initial render.\n\n  var hasRenderedContent = React.useRef(false);\n  var async = useAsync();\n\n  var _a = useResizeState(props, nextResizeGroupStateProvider, rootRef),\n      stateRef = _a[0],\n      updateResizeState = _a[1],\n      remeasure = _a[2];\n\n  React.useEffect(function () {\n    var _a;\n\n    if (stateRef.current.renderedData) {\n      hasRenderedContent.current = true;\n      (_a = props.dataDidRender) === null || _a === void 0 ? void 0 : _a.call(props, stateRef.current.renderedData);\n    }\n  });\n  React.useEffect(function () {\n    async.requestAnimationFrame(function () {\n      var containerDimension = undefined;\n\n      if (stateRef.current.measureContainer && rootRef.current) {\n        var boundingRect = rootRef.current.getBoundingClientRect();\n        containerDimension = props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n\n      var nextState = nextResizeGroupStateProvider.getNextState(props, stateRef.current, function () {\n        var refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;\n\n        if (!refToMeasure.current) {\n          return 0;\n        }\n\n        var measuredBoundingRect = refToMeasure.current.getBoundingClientRect();\n        return props.direction === ResizeGroupDirection.vertical ? measuredBoundingRect.height : measuredBoundingRect.width;\n      }, containerDimension);\n      updateResizeState(nextState);\n    }, rootRef.current);\n  });\n  var win = useWindow();\n  useOnEvent(win, 'resize', async.debounce(remeasure, RESIZE_DELAY, {\n    leading: true\n  }));\n  var dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(stateRef.current.dataToMeasure);\n  var isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;\n  return [stateRef.current.dataToMeasure, stateRef.current.renderedData, remeasure, initialHiddenDiv, updateHiddenDiv, dataNeedsMeasuring, isInitialMeasure];\n}\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      deprecations: {\n        styles: 'className'\n      }\n    });\n  }\n}\n\nvar measuredContextValue = {\n  isMeasured: true\n};\nexport var ResizeGroupBase = React.forwardRef(function (props, forwardedRef) {\n  var rootRef = React.useRef(null); // The root div which is the container inside of which we are trying to fit content.\n\n  var mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n  var _a = useResizingBehavior(props, rootRef),\n      dataToMeasure = _a[0],\n      renderedData = _a[1],\n      remeasure = _a[2],\n      initialHiddenDiv = _a[3],\n      updateHiddenDiv = _a[4],\n      dataNeedsMeasuring = _a[5],\n      isInitialMeasure = _a[6];\n\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      remeasure: remeasure\n    };\n  }, [remeasure]);\n  useDebugWarnings(props);\n  var className = props.className,\n      onRenderData = props.onRenderData;\n  var divProps = getNativeProps(props, divProperties, ['data']); // We only ever render the final content to the user. All measurements are done in a hidden div.\n  // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n  // version of the component for measurement and the final render. For renders that update what is on screen, we\n  // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n  // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n  // leave the rendered content untouched until we know the next state to show to the user.\n\n  return React.createElement(\"div\", __assign({}, divProps, {\n    className: className,\n    ref: mergedRootRef\n  }), React.createElement(\"div\", {\n    style: hiddenParentStyles\n  }, dataNeedsMeasuring && !isInitialMeasure && React.createElement(\"div\", {\n    style: hiddenDivStyles,\n    ref: updateHiddenDiv\n  }, React.createElement(MeasuredContext.Provider, {\n    value: measuredContextValue\n  }, onRenderData(dataToMeasure))), React.createElement(\"div\", {\n    ref: initialHiddenDiv,\n    style: isInitialMeasure ? hiddenDivStyles : undefined,\n    \"data-automation-id\": \"visibleContent\"\n  }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData))));\n});\nResizeGroupBase.displayName = 'ResizeGroupBase';","map":{"version":3,"sources":["components/ResizeGroup/ResizeGroup.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Async, divProperties, getNativeProps } from '../../Utilities';\nimport { ResizeGroupDirection } from './ResizeGroup.types';\nimport { useConst, useMergedRefs, useAsync, useOnEvent, useWarnings } from '@fluentui/react-hooks';\nimport { useWindow } from '../../WindowProvider';\nimport type { IResizeGroupProps } from './ResizeGroup.types';\n\nconst RESIZE_DELAY = 16;\n\nexport interface IResizeGroupState {\n  /**\n   * Final data used to render proper sized component\n   */\n  renderedData?: any;\n\n  /**\n   * Data to render in a hidden div for measurement\n   */\n  dataToMeasure?: any;\n\n  /**\n   * Set to true when the content container might have new dimensions and should\n   * be remeasured.\n   */\n  measureContainer?: boolean;\n\n  /**\n   * Are we resizing to accommodate having more or less available space?\n   * The 'grow' direction is when the container may have more room than the last render,\n   * such as when a window resize occurs. This means we will try to fit more content in the window.\n   * The 'shrink' direction is when the contents don't fit in the container and we need\n   * to find a transformation of the data that makes everything fit.\n   */\n  resizeDirection?: 'grow' | 'shrink';\n}\n\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\nexport const getMeasurementCache = () => {\n  const measurementsCache: { [key: string]: number } = {};\n\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: (data: any): number | undefined => {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: (data: any, measurement: number): void => {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    },\n  };\n};\n\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\n  const _measurementCache = measurementCache;\n  let _containerDimension: number | undefined;\n\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _getMeasuredDimension(measuredData: any, getElementToMeasureDimension: () => number): number {\n    const cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    const measuredDimension = getElementToMeasureDimension();\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n    return measuredDimension;\n  }\n\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _shrinkContentsUntilTheyFit(\n    data: any,\n    onReduceData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension!) {\n      const nextMeasuredData = onReduceData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink',\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined,\n    };\n  }\n\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _growDataUntilItDoesNotFit(\n    data: any,\n    onGrowData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n    onReduceData: (prevData: any) => any,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension!) {\n      const nextMeasuredData = onGrowData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    // Once the loop is done, we should now shrink until the contents fit.\n    return {\n      resizeDirection: 'shrink',\n      ..._shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension),\n    };\n  }\n\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n  function _updateContainerDimension(\n    newDimension: number,\n    fullDimensionData: any,\n    renderedData: any,\n    onGrowData?: (prevData: any) => any,\n  ): IResizeGroupState {\n    let nextState: IResizeGroupState;\n    if (newDimension > _containerDimension!) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData),\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData,\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData,\n      };\n    }\n    _containerDimension = newDimension;\n    return { ...nextState, measureContainer: false };\n  }\n\n  function getNextState(\n    props: IResizeGroupProps,\n    currentState: IResizeGroupState,\n    getElementToMeasureDimension: () => number,\n    newContainerDimension?: number,\n  ): IResizeGroupState | undefined {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return {\n          ...currentState,\n          ..._updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData),\n        };\n      }\n\n      // If we are just setting the container width/height for the first time, we can't do any optimizations\n      _containerDimension = newContainerDimension;\n    }\n\n    let nextState: IResizeGroupState = {\n      ...currentState,\n      measureContainer: false,\n    };\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = {\n          ...nextState,\n          ..._growDataUntilItDoesNotFit(\n            currentState.dataToMeasure,\n            props.onGrowData,\n            getElementToMeasureDimension,\n            props.onReduceData,\n          ),\n        };\n      } else {\n        nextState = {\n          ...nextState,\n          ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension),\n        };\n      }\n    }\n\n    return nextState;\n  }\n\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n  function shouldRenderDataForMeasurement(dataToMeasure: any | undefined): boolean {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data: any): IResizeGroupState {\n    return {\n      dataToMeasure: { ...data },\n      resizeDirection: 'grow',\n      measureContainer: true,\n    };\n  }\n\n  return {\n    getNextState,\n    shouldRenderDataForMeasurement,\n    getInitialResizeGroupState,\n  };\n};\n\n// Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\nexport const MeasuredContext = React.createContext({ isMeasured: false });\n\n// Styles for the hidden div used for measurement\nconst hiddenDivStyles: React.CSSProperties = { position: 'fixed', visibility: 'hidden' };\nconst hiddenParentStyles: React.CSSProperties = { position: 'relative' };\nconst COMPONENT_NAME = 'ResizeGroup';\n\ntype ResizeDataAction = {\n  type: 'resizeData' | keyof IResizeGroupState;\n  value: IResizeGroupState[keyof IResizeGroupState] | IResizeGroupState;\n};\n\n/**\n * Use useReducer instead of userState because React is not batching the state updates\n * when state is set in callbacks of setTimeout or requestAnimationFrame.\n * See issue: https://github.com/facebook/react/issues/14259\n */\nfunction resizeDataReducer(state: IResizeGroupState, action: ResizeDataAction): IResizeGroupState {\n  switch (action.type) {\n    case 'resizeData':\n      return { ...action.value };\n    case 'dataToMeasure':\n      return { ...state, dataToMeasure: action.value, resizeDirection: 'grow', measureContainer: true };\n    default:\n      return { ...state, [action.type]: action.value };\n  }\n}\n\nfunction useResizeState(\n  props: IResizeGroupProps,\n  nextResizeGroupStateProvider: ReturnType<typeof getNextResizeGroupStateProvider>,\n  rootRef: React.RefObject<HTMLDivElement | null>,\n) {\n  const initialStateData = useConst(() => nextResizeGroupStateProvider.getInitialResizeGroupState(props.data));\n  const [resizeData, dispatchResizeDataAction] = React.useReducer(resizeDataReducer, initialStateData);\n\n  // Reset state when new data is provided\n  React.useEffect(() => {\n    dispatchResizeDataAction({\n      type: 'dataToMeasure',\n      value: props.data,\n    });\n  }, [props.data]);\n\n  // Because it's possible that we may force more than one re-render per animation frame, we\n  // want to make sure that the RAF request is using the most recent data.\n  const stateRef = React.useRef<IResizeGroupState>(initialStateData);\n  stateRef.current = { ...resizeData };\n\n  const updateResizeState = React.useCallback((nextState?: IResizeGroupState) => {\n    if (nextState) {\n      dispatchResizeDataAction({\n        type: 'resizeData',\n        value: nextState,\n      });\n    }\n  }, []);\n\n  const remeasure: () => void = React.useCallback(() => {\n    if (rootRef.current) {\n      dispatchResizeDataAction({\n        type: 'measureContainer',\n        value: true,\n      });\n    }\n  }, [rootRef]);\n\n  return [stateRef, updateResizeState, remeasure] as const;\n}\n\nfunction useResizingBehavior(props: IResizeGroupProps, rootRef: React.RefObject<HTMLDivElement | null>) {\n  const nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider);\n\n  // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n  // of the component being measured for the initial render.\n  const initialHiddenDiv = React.useRef<HTMLDivElement | null>(null);\n  // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n  // div without unmounting the currently visible content.\n  const updateHiddenDiv = React.useRef<HTMLDivElement | null>(null);\n\n  // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n  // for the initial render.\n  const hasRenderedContent = React.useRef(false);\n\n  const async: Async = useAsync();\n\n  const [stateRef, updateResizeState, remeasure] = useResizeState(props, nextResizeGroupStateProvider, rootRef);\n\n  React.useEffect(() => {\n    if (stateRef.current.renderedData) {\n      hasRenderedContent.current = true;\n      props.dataDidRender?.(stateRef.current.renderedData);\n    }\n  });\n\n  React.useEffect((): void => {\n    async.requestAnimationFrame(() => {\n      let containerDimension = undefined;\n      if (stateRef.current.measureContainer && rootRef.current) {\n        const boundingRect = rootRef.current.getBoundingClientRect();\n        containerDimension =\n          props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n      const nextState = nextResizeGroupStateProvider.getNextState(\n        props,\n        stateRef.current,\n        () => {\n          const refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;\n          if (!refToMeasure.current) {\n            return 0;\n          }\n          const measuredBoundingRect = refToMeasure.current.getBoundingClientRect();\n          return props.direction === ResizeGroupDirection.vertical\n            ? measuredBoundingRect.height\n            : measuredBoundingRect.width;\n        },\n        containerDimension,\n      );\n\n      updateResizeState(nextState);\n    }, rootRef.current);\n  });\n\n  const win = useWindow();\n  useOnEvent(win, 'resize', async.debounce(remeasure, RESIZE_DELAY, { leading: true }));\n\n  const dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(\n    stateRef.current.dataToMeasure,\n  );\n\n  const isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;\n\n  return [\n    stateRef.current.dataToMeasure,\n    stateRef.current.renderedData,\n    remeasure,\n    initialHiddenDiv,\n    updateHiddenDiv,\n    dataNeedsMeasuring,\n    isInitialMeasure,\n  ] as const;\n}\n\nfunction useDebugWarnings(props: IResizeGroupProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      deprecations: { styles: 'className' },\n    });\n  }\n}\n\nconst measuredContextValue = { isMeasured: true };\n\nexport const ResizeGroupBase: React.FunctionComponent<IResizeGroupProps> = React.forwardRef<\n  HTMLDivElement,\n  IResizeGroupProps\n>((props, forwardedRef) => {\n  const rootRef = React.useRef<HTMLDivElement | null>(null);\n  // The root div which is the container inside of which we are trying to fit content.\n  const mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n  const [\n    dataToMeasure,\n    renderedData,\n    remeasure,\n    initialHiddenDiv,\n    updateHiddenDiv,\n    dataNeedsMeasuring,\n    isInitialMeasure,\n  ] = useResizingBehavior(props, rootRef);\n\n  React.useImperativeHandle(props.componentRef, () => ({ remeasure }), [remeasure]);\n\n  useDebugWarnings(props);\n\n  const { className, onRenderData } = props;\n  const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties, ['data']);\n\n  // We only ever render the final content to the user. All measurements are done in a hidden div.\n  // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n  // version of the component for measurement and the final render. For renders that update what is on screen, we\n  // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n  // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n  // leave the rendered content untouched until we know the next state to show to the user.\n  return (\n    <div {...divProps} className={className} ref={mergedRootRef}>\n      <div style={hiddenParentStyles}>\n        {dataNeedsMeasuring && !isInitialMeasure && (\n          <div style={hiddenDivStyles} ref={updateHiddenDiv}>\n            <MeasuredContext.Provider value={measuredContextValue}>\n              {onRenderData(dataToMeasure)}\n            </MeasuredContext.Provider>\n          </div>\n        )}\n\n        <div\n          ref={initialHiddenDiv}\n          style={isInitialMeasure ? hiddenDivStyles : undefined}\n          data-automation-id=\"visibleContent\"\n        >\n          {isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)}\n        </div>\n      </div>\n    </div>\n  );\n});\nResizeGroupBase.displayName = 'ResizeGroupBase';\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}