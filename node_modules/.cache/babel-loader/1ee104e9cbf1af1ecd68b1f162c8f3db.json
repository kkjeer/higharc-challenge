{"ast":null,"code":"import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\n\nvar mountCounters = new WeakMap();\n\nfunction setMountCounters(key, delta) {\n  var newValue;\n  var currValue = mountCounters.get(key);\n\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\n\n\nexport function useFocusRects(rootRef) {\n  React.useEffect(function () {\n    var _a;\n\n    var win = getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);\n\n    if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n      return undefined;\n    }\n\n    var count = setMountCounters(win, 1);\n\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return function () {\n      var _a;\n\n      if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\n\nexport var FocusRects = function (props) {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev) {\n  setFocusVisibility(false, ev.target);\n}\n\nfunction _onPointerDown(ev) {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target);\n  }\n}\n\nfunction _onKeyDown(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target);\n  }\n}","map":{"version":3,"sources":["useFocusRects.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\nlet mountCounters = new WeakMap<Window, number>();\n\nfunction setMountCounters(key: Window, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let count = setMountCounters(win, 1);\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent): void {\n  setFocusVisibility(false, ev.target as Element);\n}\n\nfunction _onPointerDown(ev: PointerEvent): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element);\n  }\n}\n\nfunction _onKeyDown(ev: KeyboardEvent): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element);\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}