{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, AutoScroll, classNamesFunction, findScrollableParent, getDistanceBetweenPoints, getRTL, initializeComponentRef } from '../../Utilities';\nvar getClassNames = classNamesFunction(); // We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\n\nvar MIN_DRAG_DISTANCE = 5;\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\n\nvar MarqueeSelectionBase =\n/** @class */\nfunction (_super) {\n  __extends(MarqueeSelectionBase, _super);\n\n  function MarqueeSelectionBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n\n    _this._onMouseDown = function (ev) {\n      var _a = _this.props,\n          isEnabled = _a.isEnabled,\n          onShouldStartSelection = _a.onShouldStartSelection; // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n\n      if (_this._isMouseEventOnScrollbar(ev)) {\n        return;\n      }\n\n      if (_this._isInSelectionToggle(ev)) {\n        return;\n      }\n\n      if (!_this._isTouch && isEnabled && !_this._isDragStartInSelection(ev) && (!onShouldStartSelection || onShouldStartSelection(ev))) {\n        if (_this._scrollableSurface && ev.button === 0 && _this._root.current) {\n          _this._selectedIndicies = {};\n          _this._preservedIndicies = undefined;\n\n          _this._events.on(window, 'mousemove', _this._onAsyncMouseMove, true);\n\n          _this._events.on(_this._scrollableParent, 'scroll', _this._onAsyncMouseMove);\n\n          _this._events.on(window, 'click', _this._onMouseUp, true);\n\n          _this._autoScroll = new AutoScroll(_this._root.current);\n          _this._scrollTop = _this._scrollableSurface.scrollTop;\n          _this._scrollLeft = _this._scrollableSurface.scrollLeft;\n          _this._rootRect = _this._root.current.getBoundingClientRect();\n\n          _this._onMouseMove(ev);\n        }\n      }\n    };\n\n    _this._onTouchStart = function (ev) {\n      _this._isTouch = true;\n\n      _this._async.setTimeout(function () {\n        _this._isTouch = false;\n      }, 0);\n    };\n\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._isTouch = true;\n\n        _this._async.setTimeout(function () {\n          _this._isTouch = false;\n        }, 0);\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      dragRect: undefined\n    };\n    return _this;\n  }\n\n  MarqueeSelectionBase.prototype.componentDidMount = function () {\n    this._scrollableParent = findScrollableParent(this._root.current);\n    this._scrollableSurface = this._scrollableParent === window ? document.body : this._scrollableParent; // When scroll events come from window, we need to read scrollTop values from the body.\n\n    var hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  };\n\n  MarqueeSelectionBase.prototype.componentWillUnmount = function () {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  MarqueeSelectionBase.prototype.render = function () {\n    var _a = this.props,\n        rootProps = _a.rootProps,\n        children = _a.children,\n        theme = _a.theme,\n        className = _a.className,\n        styles = _a.styles;\n    var dragRect = this.state.dragRect;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    return React.createElement(\"div\", __assign({}, rootProps, {\n      className: classNames.root,\n      ref: this._root\n    }), children, dragRect && React.createElement(\"div\", {\n      className: classNames.dragMask\n    }), dragRect && React.createElement(\"div\", {\n      className: classNames.box,\n      style: dragRect\n    }, React.createElement(\"div\", {\n      className: classNames.boxFill\n    })));\n  };\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n\n\n  MarqueeSelectionBase.prototype._isMouseEventOnScrollbar = function (ev) {\n    var targetElement = ev.target;\n    var targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n    var targetScrollbarHeight = targetElement.offsetHeight - targetElement.clientHeight;\n\n    if (targetScrollbarWidth || targetScrollbarHeight) {\n      var targetRect = targetElement.getBoundingClientRect(); // Check vertical scroll\n\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      } // Check horizontal scroll\n\n\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._getRootRect = function () {\n    return {\n      left: this._rootRect.left + (this._scrollableSurface ? this._scrollLeft - this._scrollableSurface.scrollLeft : this._scrollLeft),\n      top: this._rootRect.top + (this._scrollableSurface ? this._scrollTop - this._scrollableSurface.scrollTop : this._scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height\n    };\n  };\n\n  MarqueeSelectionBase.prototype._onAsyncMouseMove = function (ev) {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      _this._onMouseMove(ev);\n    });\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  MarqueeSelectionBase.prototype._onMouseMove = function (ev) {\n    if (!this._autoScroll) {\n      return;\n    }\n\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n\n    var rootRect = this._getRootRect();\n\n    var currentPoint = {\n      left: ev.clientX - rootRect.left,\n      top: ev.clientY - rootRect.top\n    };\n\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          var selection = this.props.selection;\n\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        } // We need to constrain the current point to the rootRect boundaries.\n\n\n        var constrainedPoint = this.props.isDraggingConstrainedToRoot ? {\n          left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent.clientX - rootRect.left)),\n          top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent.clientY - rootRect.top))\n        } : {\n          left: this._lastMouseEvent.clientX - rootRect.left,\n          top: this._lastMouseEvent.clientY - rootRect.top\n        };\n        var dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0))\n        };\n\n        this._evaluateSelection(dragRect, rootRect);\n\n        this.setState({\n          dragRect: dragRect\n        });\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._onMouseUp = function (ev) {\n    this._events.off(window);\n\n    this._events.off(this._scrollableParent, 'scroll');\n\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined\n      });\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  MarqueeSelectionBase.prototype._isPointInRectangle = function (rectangle, point) {\n    return !!point.top && rectangle.top < point.top && rectangle.bottom > point.top && !!point.left && rectangle.left < point.left && rectangle.right > point.left;\n  };\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n\n\n  MarqueeSelectionBase.prototype._isDragStartInSelection = function (ev) {\n    var selection = this.props.selection;\n\n    if (!this._root.current || selection && selection.getSelectedCount() === 0) {\n      return false;\n    }\n\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = Number(element.getAttribute('data-selection-index'));\n\n      if (selection.isIndexSelected(index)) {\n        var itemRect = element.getBoundingClientRect();\n\n        if (this._isPointInRectangle(itemRect, {\n          left: ev.clientX,\n          top: ev.clientY\n        })) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._isInSelectionToggle = function (ev) {\n    var element = ev.target;\n\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n\n      element = element.parentElement;\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._evaluateSelection = function (dragRect, rootRect) {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n\n    var selection = this.props.selection;\n\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = element.getAttribute('data-selection-index'); // Pull the memoized rectangle for the item, or the get the rect and memoize.\n\n      var itemRect = this._itemRectCache[index];\n\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect(); // Normalize the item rect to the dragRect coordinates.\n\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height\n        };\n\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n\n      if (itemRect.top < dragRect.top + dragRect.height && itemRect.bottom > dragRect.top && itemRect.left < dragRect.left + dragRect.width && itemRect.right > dragRect.left) {\n        this._selectedIndicies[index] = true;\n      } else {\n        delete this._selectedIndicies[index];\n      }\n    } // set previousSelectedIndices to be all of the selected indices from last time\n\n\n    var previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {}; // set all indices that are supposed to be selected in _allSelectedIndices\n\n    for (var index in this._selectedIndicies) {\n      if (this._selectedIndicies.hasOwnProperty(index)) {\n        this._allSelectedIndices[index] = true;\n      }\n    }\n\n    if (this._preservedIndicies) {\n      for (var _i = 0, _a = this._preservedIndicies; _i < _a.length; _i++) {\n        var index = _a[_i];\n        this._allSelectedIndices[index] = true;\n      }\n    } // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n\n\n    var needToUpdate = false;\n\n    for (var index in this._allSelectedIndices) {\n      if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n\n    if (!needToUpdate) {\n      for (var index in previousSelectedIndices) {\n        if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    } // only update selection when needed\n\n\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      for (var _b = 0, _c = Object.keys(this._allSelectedIndices); _b < _c.length; _b++) {\n        var index = _c[_b];\n        selection.setIndexSelected(Number(index), true, false);\n      }\n\n      selection.setChangeEvents(true);\n    }\n  };\n\n  MarqueeSelectionBase.defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true\n  };\n  return MarqueeSelectionBase;\n}(React.Component);\n\nexport { MarqueeSelectionBase };","map":{"version":3,"sources":["components/MarqueeSelection/MarqueeSelection.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport {\n  Async,\n  EventGroup,\n  AutoScroll,\n  classNamesFunction,\n  findScrollableParent,\n  getDistanceBetweenPoints,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport type { Point, IRectangle } from '../../Utilities';\nimport type {\n  IMarqueeSelectionProps,\n  IMarqueeSelectionStyleProps,\n  IMarqueeSelectionStyles,\n} from './MarqueeSelection.types';\n\nconst getClassNames = classNamesFunction<IMarqueeSelectionStyleProps, IMarqueeSelectionStyles>();\n\nexport interface IMarqueeSelectionState {\n  dragOrigin?: Point;\n  dragRect?: IRectangle;\n}\n\n// We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\nconst MIN_DRAG_DISTANCE = 5;\n\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\nexport class MarqueeSelectionBase extends React.Component<IMarqueeSelectionProps, IMarqueeSelectionState> {\n  public static defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _dragOrigin: Point | undefined;\n  private _rootRect: IRectangle;\n  private _lastMouseEvent: MouseEvent | undefined;\n  private _autoScroll: AutoScroll | undefined;\n  private _selectedIndicies: { [key: string]: boolean } | undefined;\n  private _preservedIndicies: number[] | undefined;\n  private _itemRectCache: { [key: string]: IRectangle } | undefined;\n  private _allSelectedIndices: { [key: string]: boolean } | undefined;\n  private _scrollableParent?: HTMLElement;\n  private _scrollableSurface?: HTMLElement;\n  private _scrollTop: number;\n  private _scrollLeft: number;\n  private _isTouch: boolean;\n\n  constructor(props: IMarqueeSelectionProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      dragRect: undefined,\n    };\n  }\n\n  public componentDidMount(): void {\n    this._scrollableParent = findScrollableParent(this._root.current) as HTMLElement;\n    this._scrollableSurface = this._scrollableParent === (window as any) ? document.body : this._scrollableParent;\n    // When scroll events come from window, we need to read scrollTop values from the body.\n\n    const hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  }\n\n  public componentWillUnmount(): void {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { rootProps, children, theme, className, styles } = this.props;\n    const { dragRect } = this.state;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    return (\n      <div {...rootProps} className={classNames.root} ref={this._root}>\n        {children}\n        {dragRect && <div className={classNames.dragMask} />}\n        {dragRect && (\n          <div className={classNames.box} style={dragRect}>\n            <div className={classNames.boxFill} />\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n  private _isMouseEventOnScrollbar(ev: MouseEvent): boolean {\n    const targetElement = ev.target as HTMLElement;\n    const targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n    const targetScrollbarHeight = targetElement.offsetHeight - targetElement.clientHeight;\n\n    if (targetScrollbarWidth || targetScrollbarHeight) {\n      const targetRect = targetElement.getBoundingClientRect();\n\n      // Check vertical scroll\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      }\n\n      // Check horizontal scroll\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseDown = (ev: MouseEvent): void => {\n    const { isEnabled, onShouldStartSelection } = this.props;\n\n    // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n    if (this._isMouseEventOnScrollbar(ev)) {\n      return;\n    }\n\n    if (this._isInSelectionToggle(ev)) {\n      return;\n    }\n\n    if (\n      !this._isTouch &&\n      isEnabled &&\n      !this._isDragStartInSelection(ev) &&\n      (!onShouldStartSelection || onShouldStartSelection(ev))\n    ) {\n      if (this._scrollableSurface && ev.button === 0 && this._root.current) {\n        this._selectedIndicies = {};\n        this._preservedIndicies = undefined;\n        this._events.on(window, 'mousemove', this._onAsyncMouseMove, true);\n        this._events.on(this._scrollableParent, 'scroll', this._onAsyncMouseMove);\n        this._events.on(window, 'click', this._onMouseUp, true);\n\n        this._autoScroll = new AutoScroll(this._root.current);\n        this._scrollTop = this._scrollableSurface.scrollTop;\n        this._scrollLeft = this._scrollableSurface.scrollLeft;\n        this._rootRect = this._root.current.getBoundingClientRect();\n\n        this._onMouseMove(ev);\n      }\n    }\n  };\n\n  private _onTouchStart = (ev: TouchEvent): void => {\n    this._isTouch = true;\n\n    this._async.setTimeout(() => {\n      this._isTouch = false;\n    }, 0);\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._isTouch = true;\n\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 0);\n    }\n  };\n\n  private _getRootRect(): IRectangle {\n    return {\n      left:\n        this._rootRect.left +\n        (this._scrollableSurface ? this._scrollLeft - this._scrollableSurface.scrollLeft : this._scrollLeft),\n      top:\n        this._rootRect.top +\n        (this._scrollableSurface ? this._scrollTop - this._scrollableSurface.scrollTop : this._scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height,\n    };\n  }\n\n  private _onAsyncMouseMove(ev: MouseEvent): void {\n    this._async.requestAnimationFrame(() => {\n      this._onMouseMove(ev);\n    });\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  }\n\n  private _onMouseMove(ev: MouseEvent): boolean | undefined {\n    if (!this._autoScroll) {\n      return;\n    }\n\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n\n    const rootRect = this._getRootRect();\n    const currentPoint = { left: ev.clientX - rootRect.left, top: ev.clientY - rootRect.top };\n\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          const { selection } = this.props;\n\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        }\n\n        // We need to constrain the current point to the rootRect boundaries.\n        const constrainedPoint = this.props.isDraggingConstrainedToRoot\n          ? {\n              left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent!.clientX - rootRect.left)),\n              top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent!.clientY - rootRect.top)),\n            }\n          : {\n              left: this._lastMouseEvent!.clientX - rootRect.left,\n              top: this._lastMouseEvent!.clientY - rootRect.top,\n            };\n\n        const dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0)),\n        };\n\n        this._evaluateSelection(dragRect, rootRect);\n\n        this.setState({ dragRect });\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseUp(ev: MouseEvent): void {\n    this._events.off(window);\n    this._events.off(this._scrollableParent, 'scroll');\n\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined,\n      });\n\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _isPointInRectangle(rectangle: IRectangle, point: Point): boolean {\n    return (\n      !!point.top &&\n      rectangle.top < point.top &&\n      rectangle.bottom! > point.top &&\n      !!point.left &&\n      rectangle.left < point.left &&\n      rectangle.right! > point.left\n    );\n  }\n\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n  private _isDragStartInSelection(ev: MouseEvent): boolean {\n    const selection = this.props.selection;\n    if (!this._root.current || (selection && selection.getSelectedCount() === 0)) {\n      return false;\n    }\n\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = Number(element.getAttribute('data-selection-index'));\n      if (selection.isIndexSelected(index)) {\n        const itemRect = element.getBoundingClientRect();\n        if (this._isPointInRectangle(itemRect, { left: ev.clientX, top: ev.clientY })) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private _isInSelectionToggle(ev: MouseEvent): boolean {\n    let element: HTMLElement | null = ev.target as HTMLElement;\n\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n\n      element = element.parentElement;\n    }\n\n    return false;\n  }\n\n  private _evaluateSelection(dragRect: IRectangle, rootRect: IRectangle): void {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n\n    const { selection } = this.props;\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = element.getAttribute('data-selection-index') as string;\n\n      // Pull the memoized rectangle for the item, or the get the rect and memoize.\n      let itemRect = this._itemRectCache[index];\n\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect();\n\n        // Normalize the item rect to the dragRect coordinates.\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height,\n        };\n\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n\n      if (\n        itemRect.top < dragRect.top + dragRect.height &&\n        itemRect.bottom! > dragRect.top &&\n        itemRect.left < dragRect.left + dragRect.width &&\n        itemRect.right! > dragRect.left\n      ) {\n        this._selectedIndicies![index] = true;\n      } else {\n        delete this._selectedIndicies![index];\n      }\n    }\n\n    // set previousSelectedIndices to be all of the selected indices from last time\n    const previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {};\n\n    // set all indices that are supposed to be selected in _allSelectedIndices\n    for (const index in this._selectedIndicies!) {\n      if (this._selectedIndicies!.hasOwnProperty(index)) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    if (this._preservedIndicies) {\n      for (const index of this._preservedIndicies!) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n    let needToUpdate = false;\n    for (const index in this._allSelectedIndices!) {\n      if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n\n    if (!needToUpdate) {\n      for (const index in previousSelectedIndices!) {\n        if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    }\n\n    // only update selection when needed\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      for (const index of Object.keys(this._allSelectedIndices!)) {\n        selection.setIndexSelected(Number(index), true, false);\n      }\n\n      selection.setChangeEvents(true);\n    }\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}