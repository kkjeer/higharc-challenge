{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction, divProperties, getNativeProps, getRTL, initializeComponentRef } from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nvar getClassNames = classNamesFunction();\n\nvar ScrollablePaneBase =\n/** @class */\nfunction (_super) {\n  __extends(ScrollablePaneBase, _super);\n\n  function ScrollablePaneBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._stickyAboveRef = React.createRef();\n    _this._stickyBelowRef = React.createRef();\n    _this._contentContainer = React.createRef();\n\n    _this.subscribe = function (handler) {\n      _this._subscribers.add(handler);\n    };\n\n    _this.unsubscribe = function (handler) {\n      _this._subscribers.delete(handler);\n    };\n\n    _this.addSticky = function (sticky) {\n      _this._stickies.add(sticky); // If ScrollablePane is mounted, then sort sticky in correct place\n\n\n      if (_this.contentContainer) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n\n        _this.sortSticky(sticky);\n      }\n    };\n\n    _this.removeSticky = function (sticky) {\n      _this._stickies.delete(sticky);\n\n      _this._removeStickyFromContainers(sticky);\n\n      _this.notifySubscribers();\n    };\n\n    _this.sortSticky = function (sticky, sortAgain) {\n      if (_this.stickyAbove && _this.stickyBelow) {\n        if (sortAgain) {\n          _this._removeStickyFromContainers(sticky);\n        }\n\n        if (sticky.canStickyTop && sticky.stickyContentTop) {\n          _this._addToStickyContainer(sticky, _this.stickyAbove, sticky.stickyContentTop);\n        }\n\n        if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n          _this._addToStickyContainer(sticky, _this.stickyBelow, sticky.stickyContentBottom);\n        }\n      }\n    };\n\n    _this.updateStickyRefHeights = function () {\n      var stickyItems = _this._stickies;\n      var stickyTopHeight = 0;\n      var stickyBottomHeight = 0;\n      stickyItems.forEach(function (sticky) {\n        var _a = sticky.state,\n            isStickyTop = _a.isStickyTop,\n            isStickyBottom = _a.isStickyBottom;\n\n        if (sticky.nonStickyContent) {\n          if (isStickyTop) {\n            stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          if (isStickyBottom) {\n            stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          _this._checkStickyStatus(sticky);\n        }\n      });\n\n      _this.setState({\n        stickyTopHeight: stickyTopHeight,\n        stickyBottomHeight: stickyBottomHeight\n      });\n    };\n\n    _this.notifySubscribers = function () {\n      if (_this.contentContainer) {\n        _this._subscribers.forEach(function (handle) {\n          // this.stickyBelow is passed in for calculating distance to determine Sticky status\n          handle(_this.contentContainer, _this.stickyBelow);\n        });\n      }\n    };\n\n    _this.getScrollPosition = function () {\n      if (_this.contentContainer) {\n        return _this.contentContainer.scrollTop;\n      }\n\n      return 0;\n    };\n\n    _this.syncScrollSticky = function (sticky) {\n      if (sticky && _this.contentContainer) {\n        sticky.syncScroll(_this.contentContainer);\n      }\n    };\n\n    _this._getScrollablePaneContext = function () {\n      return {\n        scrollablePane: {\n          subscribe: _this.subscribe,\n          unsubscribe: _this.unsubscribe,\n          addSticky: _this.addSticky,\n          removeSticky: _this.removeSticky,\n          updateStickyRefHeights: _this.updateStickyRefHeights,\n          sortSticky: _this.sortSticky,\n          notifySubscribers: _this.notifySubscribers,\n          syncScrollSticky: _this.syncScrollSticky\n        }\n      };\n    };\n\n    _this._addToStickyContainer = function (sticky, stickyContainer, stickyContentToAdd) {\n      // If there's no children, append child to list, otherwise, sort though array and append at correct position\n      if (!stickyContainer.children.length) {\n        stickyContainer.appendChild(stickyContentToAdd);\n      } else {\n        // If stickyContentToAdd isn't a child element of target container, then append\n        if (!stickyContainer.contains(stickyContentToAdd)) {\n          var stickyChildrenElements_1 = [].slice.call(stickyContainer.children);\n          var stickyList_1 = []; // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n          // filter by elements that are in the stickyContainer already.\n\n          _this._stickies.forEach(function (stickyItem) {\n            if (stickyContainer === _this.stickyAbove && sticky.canStickyTop) {\n              stickyList_1.push(stickyItem);\n            } else if (sticky.canStickyBottom) {\n              stickyList_1.push(stickyItem);\n            }\n          });\n\n          var stickyListSorted = stickyList_1.sort(function (a, b) {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          }).filter(function (item) {\n            var stickyContent = stickyContainer === _this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n\n            if (stickyContent) {\n              return stickyChildrenElements_1.indexOf(stickyContent) > -1;\n            }\n\n            return false;\n          }); // Get first element that has a distance from top that is further than our sticky that is being added\n\n          var targetStickyToAppendBefore = undefined;\n\n          for (var _i = 0, stickyListSorted_1 = stickyListSorted; _i < stickyListSorted_1.length; _i++) {\n            var stickyListItem = stickyListSorted_1[_i];\n\n            if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n              targetStickyToAppendBefore = stickyListItem;\n              break;\n            }\n          } // If target element to append before is known, grab respective stickyContentTop/Bottom element\n          // and insert before\n\n\n          var targetContainer = null;\n\n          if (targetStickyToAppendBefore) {\n            targetContainer = stickyContainer === _this.stickyAbove ? targetStickyToAppendBefore.stickyContentTop : targetStickyToAppendBefore.stickyContentBottom;\n          }\n\n          stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n        }\n      }\n    };\n\n    _this._removeStickyFromContainers = function (sticky) {\n      if (_this.stickyAbove && sticky.stickyContentTop && _this.stickyAbove.contains(sticky.stickyContentTop)) {\n        _this.stickyAbove.removeChild(sticky.stickyContentTop);\n      }\n\n      if (_this.stickyBelow && sticky.stickyContentBottom && _this.stickyBelow.contains(sticky.stickyContentBottom)) {\n        _this.stickyBelow.removeChild(sticky.stickyContentBottom);\n      }\n    };\n\n    _this._onWindowResize = function () {\n      var scrollbarWidth = _this._getScrollbarWidth();\n\n      var scrollbarHeight = _this._getScrollbarHeight();\n\n      _this.setState({\n        scrollbarWidth: scrollbarWidth,\n        scrollbarHeight: scrollbarHeight\n      });\n\n      _this.notifySubscribers();\n    };\n\n    _this._getStickyContainerStyle = function (height, isTop) {\n      return __assign(__assign({\n        height: height\n      }, getRTL(_this.props.theme) ? {\n        right: '0',\n        left: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      } : {\n        left: '0',\n        right: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      }), isTop ? {\n        top: '0'\n      } : {\n        bottom: (_this.state.scrollbarHeight || _this._getScrollbarHeight() || 0) + \"px\"\n      });\n    };\n\n    _this._onScroll = function () {\n      var contentContainer = _this.contentContainer;\n\n      if (contentContainer) {\n        _this._stickies.forEach(function (sticky) {\n          sticky.syncScroll(contentContainer);\n        });\n      }\n\n      _this._notifyThrottled();\n    };\n\n    _this._subscribers = new Set();\n    _this._stickies = new Set();\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0\n    };\n    _this._notifyThrottled = _this._async.throttle(_this.notifySubscribers, 50);\n    return _this;\n  }\n\n  Object.defineProperty(ScrollablePaneBase.prototype, \"root\", {\n    get: function () {\n      return this._root.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyAbove\", {\n    get: function () {\n      return this._stickyAboveRef.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyBelow\", {\n    get: function () {\n      return this._stickyBelowRef.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"contentContainer\", {\n    get: function () {\n      return this._contentContainer.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ScrollablePaneBase.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n\n    this._events.on(window, 'resize', this._onWindowResize);\n\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Set sticky distances from top property, then sort in correct order and notify subscribers\n\n\n    this.setStickiesDistanceFromTop();\n\n    this._stickies.forEach(function (sticky) {\n      _this.sortSticky(sticky);\n    });\n\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(function (mutation) {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord) {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n\n          return false;\n        } // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n\n\n        var scrollbarHeight = _this._getScrollbarHeight(); // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n\n\n        if (scrollbarHeight !== _this.state.scrollbarHeight) {\n          _this.setState({\n            scrollbarHeight: scrollbarHeight\n          });\n        } // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n\n\n        _this.notifySubscribers(); // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n\n\n        if (mutation.some(checkIfMutationIsSticky.bind(_this))) {\n          _this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          var stickyList_2 = [];\n\n          _this._stickies.forEach(function (sticky) {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList_2.push(sticky);\n            }\n          });\n\n          if (stickyList_2.length) {\n            stickyList_2.forEach(function (sticky) {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true\n        });\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }; // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n\n\n  ScrollablePaneBase.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return this.props.children !== nextProps.children || this.props.initialScrollPosition !== nextProps.initialScrollPosition || this.props.className !== nextProps.className || this.state.stickyTopHeight !== nextState.stickyTopHeight || this.state.stickyBottomHeight !== nextState.stickyBottomHeight || this.state.scrollbarWidth !== nextState.scrollbarWidth || this.state.scrollbarHeight !== nextState.scrollbarHeight;\n  };\n\n  ScrollablePaneBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    if (this.contentContainer && typeof initialScrollPosition === 'number' && prevProps.initialScrollPosition !== initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n\n\n    if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  };\n\n  ScrollablePaneBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        scrollContainerFocus = _a.scrollContainerFocus,\n        scrollContainerAriaLabel = _a.scrollContainerAriaLabel,\n        theme = _a.theme,\n        styles = _a.styles,\n        onScroll = _a.onScroll;\n    var _b = this.state,\n        stickyTopHeight = _b.stickyTopHeight,\n        stickyBottomHeight = _b.stickyBottomHeight;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      scrollbarVisibility: this.props.scrollbarVisibility\n    });\n    var scrollContainerProps = scrollContainerFocus ? {\n      role: 'group',\n      tabIndex: 0,\n      'aria-label': scrollContainerAriaLabel,\n      onScroll: onScroll\n    } : {\n      onScroll: onScroll\n    };\n    return React.createElement(\"div\", __assign({}, getNativeProps(__assign({}, this.props), divProperties, // on React 17 onScroll is not being invoked on root element,\n    // as a fix this method will be provided to the container element\n    ['onScroll']), {\n      ref: this._root,\n      className: classNames.root\n    }), React.createElement(\"div\", {\n      ref: this._stickyAboveRef,\n      className: classNames.stickyAbove,\n      style: this._getStickyContainerStyle(stickyTopHeight, true)\n    }), React.createElement(\"div\", __assign({\n      ref: this._contentContainer\n    }, scrollContainerProps, {\n      className: classNames.contentContainer,\n      \"data-is-scrollable\": true\n    }), React.createElement(ScrollablePaneContext.Provider, {\n      value: this._getScrollablePaneContext()\n    }, this.props.children)), React.createElement(\"div\", {\n      className: classNames.stickyBelow,\n      style: this._getStickyContainerStyle(stickyBottomHeight, false)\n    }, React.createElement(\"div\", {\n      ref: this._stickyBelowRef,\n      className: classNames.stickyBelowItems\n    })));\n  };\n\n  ScrollablePaneBase.prototype.setStickiesDistanceFromTop = function () {\n    var _this = this;\n\n    if (this.contentContainer) {\n      this._stickies.forEach(function (sticky) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n      });\n    }\n  };\n\n  ScrollablePaneBase.prototype.forceLayoutUpdate = function () {\n    this._onWindowResize();\n  };\n\n  ScrollablePaneBase.prototype._checkStickyStatus = function (sticky) {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarWidth = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarHeight = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  };\n\n  return ScrollablePaneBase;\n}(React.Component);\n\nexport { ScrollablePaneBase };","map":{"version":3,"sources":["components/ScrollablePane/ScrollablePane.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  classNamesFunction,\n  divProperties,\n  getNativeProps,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nimport { Sticky } from '../../Sticky';\nimport type {\n  IScrollablePane,\n  IScrollablePaneContext,\n  IScrollablePaneProps,\n  IScrollablePaneStyleProps,\n  IScrollablePaneStyles,\n} from './ScrollablePane.types';\n\nexport interface IScrollablePaneState {\n  stickyTopHeight: number;\n  stickyBottomHeight: number;\n  scrollbarWidth: number;\n  scrollbarHeight: number;\n}\n\nconst getClassNames = classNamesFunction<IScrollablePaneStyleProps, IScrollablePaneStyles>();\n\nexport class ScrollablePaneBase\n  extends React.Component<IScrollablePaneProps, IScrollablePaneState>\n  implements IScrollablePane {\n  private _root = React.createRef<HTMLDivElement>();\n  private _stickyAboveRef = React.createRef<HTMLDivElement>();\n  private _stickyBelowRef = React.createRef<HTMLDivElement>();\n  private _contentContainer = React.createRef<HTMLDivElement>();\n  private _subscribers: Set<Function>;\n  private _stickies: Set<Sticky>;\n  private _mutationObserver: MutationObserver;\n  private _notifyThrottled: () => void;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IScrollablePaneProps) {\n    super(props);\n    this._subscribers = new Set<Function>();\n    this._stickies = new Set<Sticky>();\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0,\n    };\n\n    this._notifyThrottled = this._async.throttle(this.notifySubscribers, 50);\n  }\n\n  public get root(): HTMLDivElement | null {\n    return this._root.current;\n  }\n\n  public get stickyAbove(): HTMLDivElement | null {\n    return this._stickyAboveRef.current;\n  }\n\n  public get stickyBelow(): HTMLDivElement | null {\n    return this._stickyBelowRef.current;\n  }\n\n  public get contentContainer(): HTMLDivElement | null {\n    return this._contentContainer.current;\n  }\n\n  public componentDidMount() {\n    const { initialScrollPosition } = this.props;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(sticky => {\n      this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(mutation => {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord: MutationRecord): boolean {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        const scrollbarHeight = this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== this.state.scrollbarHeight) {\n          this.setState({\n            scrollbarHeight: scrollbarHeight,\n          });\n        }\n\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        this.notifySubscribers();\n\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(this))) {\n          this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          const stickyList: Sticky[] = [];\n          this._stickies.forEach(sticky => {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList.push(sticky);\n            }\n          });\n          if (stickyList.length) {\n            stickyList.forEach(sticky => {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true,\n        });\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.dispose();\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }\n\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  public shouldComponentUpdate(nextProps: IScrollablePaneProps, nextState: IScrollablePaneState): boolean {\n    return (\n      this.props.children !== nextProps.children ||\n      this.props.initialScrollPosition !== nextProps.initialScrollPosition ||\n      this.props.className !== nextProps.className ||\n      this.state.stickyTopHeight !== nextState.stickyTopHeight ||\n      this.state.stickyBottomHeight !== nextState.stickyBottomHeight ||\n      this.state.scrollbarWidth !== nextState.scrollbarWidth ||\n      this.state.scrollbarHeight !== nextState.scrollbarHeight\n    );\n  }\n\n  public componentDidUpdate(prevProps: IScrollablePaneProps, prevState: IScrollablePaneState) {\n    const initialScrollPosition = this.props.initialScrollPosition;\n    if (\n      this.contentContainer &&\n      typeof initialScrollPosition === 'number' &&\n      prevProps.initialScrollPosition !== initialScrollPosition\n    ) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (\n      prevState.stickyTopHeight !== this.state.stickyTopHeight ||\n      prevState.stickyBottomHeight !== this.state.stickyBottomHeight\n    ) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  }\n\n  public render(): JSX.Element {\n    const { className, scrollContainerFocus, scrollContainerAriaLabel, theme, styles, onScroll } = this.props;\n    const { stickyTopHeight, stickyBottomHeight } = this.state;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      scrollbarVisibility: this.props.scrollbarVisibility,\n    });\n\n    const scrollContainerProps = scrollContainerFocus\n      ? {\n          role: 'group',\n          tabIndex: 0,\n          'aria-label': scrollContainerAriaLabel,\n          onScroll,\n        }\n      : {\n          onScroll,\n        };\n\n    return (\n      <div\n        {...getNativeProps(\n          {\n            ...this.props,\n          },\n          divProperties,\n          // on React 17 onScroll is not being invoked on root element,\n          // as a fix this method will be provided to the container element\n          ['onScroll'],\n        )}\n        ref={this._root}\n        className={classNames.root}\n      >\n        <div\n          ref={this._stickyAboveRef}\n          className={classNames.stickyAbove}\n          style={this._getStickyContainerStyle(stickyTopHeight, true)}\n        />\n        <div\n          ref={this._contentContainer}\n          {...scrollContainerProps}\n          className={classNames.contentContainer}\n          data-is-scrollable={true}\n        >\n          <ScrollablePaneContext.Provider value={this._getScrollablePaneContext()}>\n            {this.props.children}\n          </ScrollablePaneContext.Provider>\n        </div>\n        <div className={classNames.stickyBelow} style={this._getStickyContainerStyle(stickyBottomHeight, false)}>\n          <div ref={this._stickyBelowRef} className={classNames.stickyBelowItems} />\n        </div>\n      </div>\n    );\n  }\n\n  public setStickiesDistanceFromTop(): void {\n    if (this.contentContainer) {\n      this._stickies.forEach(sticky => {\n        sticky.setDistanceFromTop(this.contentContainer as HTMLDivElement);\n      });\n    }\n  }\n\n  public forceLayoutUpdate() {\n    this._onWindowResize();\n  }\n\n  public subscribe = (handler: Function): void => {\n    this._subscribers.add(handler);\n  };\n\n  public unsubscribe = (handler: Function): void => {\n    this._subscribers.delete(handler);\n  };\n\n  public addSticky = (sticky: Sticky): void => {\n    this._stickies.add(sticky);\n\n    // If ScrollablePane is mounted, then sort sticky in correct place\n    if (this.contentContainer) {\n      sticky.setDistanceFromTop(this.contentContainer);\n      this.sortSticky(sticky);\n    }\n  };\n\n  public removeSticky = (sticky: Sticky): void => {\n    this._stickies.delete(sticky);\n    this._removeStickyFromContainers(sticky);\n    this.notifySubscribers();\n  };\n\n  public sortSticky = (sticky: Sticky, sortAgain?: boolean): void => {\n    if (this.stickyAbove && this.stickyBelow) {\n      if (sortAgain) {\n        this._removeStickyFromContainers(sticky);\n      }\n      if (sticky.canStickyTop && sticky.stickyContentTop) {\n        this._addToStickyContainer(sticky, this.stickyAbove, sticky.stickyContentTop);\n      }\n\n      if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n        this._addToStickyContainer(sticky, this.stickyBelow, sticky.stickyContentBottom);\n      }\n    }\n  };\n\n  public updateStickyRefHeights = (): void => {\n    const stickyItems = this._stickies;\n\n    let stickyTopHeight = 0;\n    let stickyBottomHeight = 0;\n\n    stickyItems.forEach((sticky: Sticky) => {\n      const { isStickyTop, isStickyBottom } = sticky.state;\n      if (sticky.nonStickyContent) {\n        if (isStickyTop) {\n          stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        if (isStickyBottom) {\n          stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        this._checkStickyStatus(sticky);\n      }\n    });\n\n    this.setState({\n      stickyTopHeight: stickyTopHeight,\n      stickyBottomHeight: stickyBottomHeight,\n    });\n  };\n\n  public notifySubscribers = (): void => {\n    if (this.contentContainer) {\n      this._subscribers.forEach(handle => {\n        // this.stickyBelow is passed in for calculating distance to determine Sticky status\n        handle(this.contentContainer, this.stickyBelow);\n      });\n    }\n  };\n\n  public getScrollPosition = (): number => {\n    if (this.contentContainer) {\n      return this.contentContainer.scrollTop;\n    }\n\n    return 0;\n  };\n\n  public syncScrollSticky = (sticky: Sticky): void => {\n    if (sticky && this.contentContainer) {\n      sticky.syncScroll(this.contentContainer);\n    }\n  };\n\n  private _getScrollablePaneContext = (): IScrollablePaneContext => {\n    return {\n      scrollablePane: {\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        addSticky: this.addSticky,\n        removeSticky: this.removeSticky,\n        updateStickyRefHeights: this.updateStickyRefHeights,\n        sortSticky: this.sortSticky,\n        notifySubscribers: this.notifySubscribers,\n        syncScrollSticky: this.syncScrollSticky,\n      },\n    };\n  };\n\n  private _checkStickyStatus(sticky: Sticky): void {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (\n          sticky.state.isStickyTop &&\n          !this.stickyAbove.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentTop\n        ) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (\n          sticky.state.isStickyBottom &&\n          !this.stickyBelow.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentBottom\n        ) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  }\n\n  private _addToStickyContainer = (\n    sticky: Sticky,\n    stickyContainer: HTMLDivElement,\n    stickyContentToAdd: HTMLDivElement,\n  ): void => {\n    // If there's no children, append child to list, otherwise, sort though array and append at correct position\n    if (!stickyContainer.children.length) {\n      stickyContainer.appendChild(stickyContentToAdd);\n    } else {\n      // If stickyContentToAdd isn't a child element of target container, then append\n      if (!stickyContainer.contains(stickyContentToAdd)) {\n        const stickyChildrenElements: Element[] = [].slice.call(stickyContainer.children);\n\n        const stickyList: Sticky[] = [];\n        // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n        // filter by elements that are in the stickyContainer already.\n        this._stickies.forEach(stickyItem => {\n          if (stickyContainer === this.stickyAbove && sticky.canStickyTop) {\n            stickyList.push(stickyItem);\n          } else if (sticky.canStickyBottom) {\n            stickyList.push(stickyItem);\n          }\n        });\n\n        const stickyListSorted = stickyList\n          .sort((a, b) => {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          })\n          .filter(item => {\n            const stickyContent =\n              stickyContainer === this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n\n        // Get first element that has a distance from top that is further than our sticky that is being added\n        let targetStickyToAppendBefore: Sticky | undefined = undefined;\n        for (const stickyListItem of stickyListSorted) {\n          if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n            targetStickyToAppendBefore = stickyListItem;\n            break;\n          }\n        }\n\n        // If target element to append before is known, grab respective stickyContentTop/Bottom element\n        // and insert before\n        let targetContainer: HTMLDivElement | null = null;\n        if (targetStickyToAppendBefore) {\n          targetContainer =\n            stickyContainer === this.stickyAbove\n              ? targetStickyToAppendBefore.stickyContentTop\n              : targetStickyToAppendBefore.stickyContentBottom;\n        }\n        stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n      }\n    }\n  };\n\n  private _removeStickyFromContainers = (sticky: Sticky): void => {\n    if (this.stickyAbove && sticky.stickyContentTop && this.stickyAbove.contains(sticky.stickyContentTop)) {\n      this.stickyAbove.removeChild(sticky.stickyContentTop);\n    }\n    if (this.stickyBelow && sticky.stickyContentBottom && this.stickyBelow.contains(sticky.stickyContentBottom)) {\n      this.stickyBelow.removeChild(sticky.stickyContentBottom);\n    }\n  };\n\n  private _onWindowResize = (): void => {\n    const scrollbarWidth = this._getScrollbarWidth();\n    const scrollbarHeight = this._getScrollbarHeight();\n\n    this.setState({\n      scrollbarWidth,\n      scrollbarHeight,\n    });\n\n    this.notifySubscribers();\n  };\n\n  private _getStickyContainerStyle = (height: number, isTop: boolean): React.CSSProperties => {\n    return {\n      height: height,\n      ...(getRTL(this.props.theme)\n        ? {\n            right: '0',\n            left: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }\n        : {\n            left: '0',\n            right: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }),\n      ...(isTop\n        ? {\n            top: '0',\n          }\n        : {\n            bottom: `${this.state.scrollbarHeight || this._getScrollbarHeight() || 0}px`,\n          }),\n    };\n  };\n\n  private _getScrollbarWidth(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  }\n\n  private _getScrollbarHeight(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  }\n\n  private _onScroll = () => {\n    const { contentContainer } = this;\n\n    if (contentContainer) {\n      this._stickies.forEach((sticky: Sticky) => {\n        sticky.syncScroll(contentContainer);\n      });\n    }\n\n    this._notifyThrottled();\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}