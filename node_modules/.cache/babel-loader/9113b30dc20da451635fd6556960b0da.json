{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction } from '../../Utilities';\nimport { initializeComponentRef } from '@fluentui/utilities';\nimport { DocumentCardContext } from './DocumentCard.base';\nvar getClassNames = classNamesFunction();\nvar TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;\n/**\n * {@docCategory DocumentCard}\n */\n\nvar DocumentCardTitleBase =\n/** @class */\nfunction (_super) {\n  __extends(DocumentCardTitleBase, _super);\n\n  function DocumentCardTitleBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._titleElement = React.createRef(); // Truncate logic here way can't handle the case that chars with different widths are mixed very well.\n    // Let _shrinkTitle take care of that.\n\n    _this._truncateTitle = function () {\n      if (!_this._needMeasurement) {\n        return;\n      }\n\n      _this._async.requestAnimationFrame(_this._truncateWhenInAnimation);\n    };\n\n    _this._truncateWhenInAnimation = function () {\n      var originalTitle = _this.props.title;\n      var element = _this._titleElement.current;\n\n      if (element) {\n        var style = getComputedStyle(element);\n\n        if (style.width && style.lineHeight && style.height) {\n          var clientWidth = element.clientWidth,\n              scrollWidth = element.scrollWidth;\n          _this._clientWidth = clientWidth;\n          var lines = Math.floor((parseInt(style.height, 10) + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD) / parseInt(style.lineHeight, 10));\n          element.style.whiteSpace = ''; // Use overflow to predict truncated length.\n          // Take an example.The text is: A text with A very long text that need to be truncated.ppt\n          // if container is like\n          // |A text with A very| long text that need to be truncated.ppt\n          // The scroll width is 58, (take two | out of length)\n          // The client width is 18\n          // the overflow rate is scrollWidth/clientWidth which should be close to length(overflowText)/length(visualText)\n          // And the length of remaining text should be truncated is (original Length)/(58/18) -3 = 15.\n          // So that the logic can predict truncated text well.\n          // first piece will be `A text `, * second piece will be `ated.ppt`\n          // |A text ...ated.ppt|\n\n          var overFlowRate = scrollWidth / (parseInt(style.width, 10) * lines);\n\n          if (overFlowRate > 1) {\n            var truncatedLength = originalTitle.length / overFlowRate - 3;\n            /** Saved for separator */\n\n            return _this.setState({\n              truncatedTitleFirstPiece: originalTitle.slice(0, truncatedLength / 2),\n              truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - truncatedLength / 2)\n            });\n          }\n        }\n      }\n    };\n\n    _this._shrinkTitle = function () {\n      var _a = _this.state,\n          truncatedTitleFirstPiece = _a.truncatedTitleFirstPiece,\n          truncatedTitleSecondPiece = _a.truncatedTitleSecondPiece;\n\n      if (truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n        var titleElement = _this._titleElement.current;\n\n        if (!titleElement) {\n          return;\n        }\n\n        if (titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD || titleElement.scrollWidth > titleElement.clientWidth) {\n          _this.setState({\n            truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),\n            truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1)\n          });\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this._clientWidth = undefined;\n    _this.state = {\n      truncatedTitleFirstPiece: undefined,\n      truncatedTitleSecondPiece: undefined\n    };\n    return _this;\n  }\n\n  DocumentCardTitleBase.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    if (this.props.title !== prevProps.title) {\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined\n      });\n    }\n\n    if (prevProps.shouldTruncate !== this.props.shouldTruncate) {\n      if (this.props.shouldTruncate) {\n        this._truncateTitle();\n\n        this._async.requestAnimationFrame(this._shrinkTitle);\n\n        this._events.on(window, 'resize', this._updateTruncation);\n      } else {\n        this._events.off(window, 'resize', this._updateTruncation);\n      }\n    } else if (this._needMeasurement) {\n      this._async.requestAnimationFrame(function () {\n        _this._truncateWhenInAnimation();\n\n        _this._shrinkTitle();\n      });\n    }\n  };\n\n  DocumentCardTitleBase.prototype.componentDidMount = function () {\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  };\n\n  DocumentCardTitleBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  DocumentCardTitleBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        title = _a.title,\n        shouldTruncate = _a.shouldTruncate,\n        showAsSecondaryTitle = _a.showAsSecondaryTitle,\n        styles = _a.styles,\n        theme = _a.theme,\n        className = _a.className;\n    var _b = this.state,\n        truncatedTitleFirstPiece = _b.truncatedTitleFirstPiece,\n        truncatedTitleSecondPiece = _b.truncatedTitleSecondPiece;\n    this._classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      showAsSecondaryTitle: showAsSecondaryTitle\n    });\n\n    if (shouldTruncate && truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      return React.createElement(DocumentCardContext.Consumer, null, function (_a) {\n        var role = _a.role,\n            tabIndex = _a.tabIndex;\n        return React.createElement(\"div\", {\n          className: _this._classNames.root,\n          ref: _this._titleElement,\n          title: title,\n          tabIndex: tabIndex,\n          role: role\n        }, truncatedTitleFirstPiece, \"\\u2026\", truncatedTitleSecondPiece);\n      });\n    } else {\n      return React.createElement(DocumentCardContext.Consumer, null, function (_a) {\n        var role = _a.role,\n            tabIndex = _a.tabIndex;\n        return React.createElement(\"div\", {\n          className: _this._classNames.root,\n          ref: _this._titleElement,\n          title: title,\n          tabIndex: tabIndex,\n          role: role,\n          style: _this._needMeasurement ? {\n            whiteSpace: 'nowrap'\n          } : undefined\n        }, title);\n      });\n    }\n  };\n\n  Object.defineProperty(DocumentCardTitleBase.prototype, \"_needMeasurement\", {\n    /**\n     * In measuring, it will render a same style text with whiteSpace: 'nowrap', to get overflow rate.\n     * So that the logic can predict truncated text well.\n     */\n    get: function () {\n      return !!this.props.shouldTruncate && this._clientWidth === undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DocumentCardTitleBase.prototype._updateTruncation = function () {\n    var _this = this;\n\n    if (this._timerId) {\n      return;\n    }\n\n    this._timerId = this._async.setTimeout(function () {\n      delete _this._timerId;\n      _this._clientWidth = undefined;\n\n      _this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined\n      });\n    }, 250);\n  };\n\n  return DocumentCardTitleBase;\n}(React.Component);\n\nexport { DocumentCardTitleBase };","map":{"version":3,"sources":["components/DocumentCard/DocumentCardTitle.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport { Async, EventGroup, classNamesFunction } from '../../Utilities';\nimport { initializeComponentRef } from '@fluentui/utilities';\nimport type {\n  IDocumentCardTitleProps,\n  IDocumentCardTitleStyleProps,\n  IDocumentCardTitleStyles,\n} from './DocumentCardTitle.types';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport { DocumentCardContext } from './DocumentCard.base';\n\nconst getClassNames = classNamesFunction<IDocumentCardTitleStyleProps, IDocumentCardTitleStyles>();\n\nexport interface IDocumentCardTitleState {\n  truncatedTitleFirstPiece?: string;\n  truncatedTitleSecondPiece?: string;\n}\n\nconst TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;\n\n/**\n * {@docCategory DocumentCard}\n */\nexport class DocumentCardTitleBase extends React.Component<IDocumentCardTitleProps, IDocumentCardTitleState> {\n  private _titleElement = React.createRef<HTMLDivElement>();\n  private _classNames: IProcessedStyleSet<IDocumentCardTitleStyles>;\n  private _async: Async;\n  private _events: EventGroup;\n  private _clientWidth: number | undefined;\n  private _timerId: number | undefined;\n\n  constructor(props: IDocumentCardTitleProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    this._clientWidth = undefined;\n\n    this.state = {\n      truncatedTitleFirstPiece: undefined,\n      truncatedTitleSecondPiece: undefined,\n    };\n  }\n\n  public componentDidUpdate(prevProps: IDocumentCardTitleProps): void {\n    if (this.props.title !== prevProps.title) {\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined,\n      });\n    }\n\n    if (prevProps.shouldTruncate !== this.props.shouldTruncate) {\n      if (this.props.shouldTruncate) {\n        this._truncateTitle();\n        this._async.requestAnimationFrame(this._shrinkTitle);\n        this._events.on(window, 'resize', this._updateTruncation);\n      } else {\n        this._events.off(window, 'resize', this._updateTruncation);\n      }\n    } else if (this._needMeasurement) {\n      this._async.requestAnimationFrame(() => {\n        this._truncateWhenInAnimation();\n        this._shrinkTitle();\n      });\n    }\n  }\n\n  public componentDidMount(): void {\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { title, shouldTruncate, showAsSecondaryTitle, styles, theme, className } = this.props;\n    const { truncatedTitleFirstPiece, truncatedTitleSecondPiece } = this.state;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      showAsSecondaryTitle,\n    });\n\n    if (shouldTruncate && truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      return (\n        <DocumentCardContext.Consumer>\n          {({ role, tabIndex }) => {\n            return (\n              <div\n                className={this._classNames.root}\n                ref={this._titleElement}\n                title={title}\n                tabIndex={tabIndex}\n                role={role}\n              >\n                {truncatedTitleFirstPiece}\n                &hellip;\n                {truncatedTitleSecondPiece}\n              </div>\n            );\n          }}\n        </DocumentCardContext.Consumer>\n      );\n    } else {\n      return (\n        <DocumentCardContext.Consumer>\n          {({ role, tabIndex }) => {\n            return (\n              <div\n                className={this._classNames.root}\n                ref={this._titleElement}\n                title={title}\n                tabIndex={tabIndex}\n                role={role}\n                style={this._needMeasurement ? { whiteSpace: 'nowrap' } : undefined}\n              >\n                {title}\n              </div>\n            );\n          }}\n        </DocumentCardContext.Consumer>\n      );\n    }\n  }\n\n  /**\n   * In measuring, it will render a same style text with whiteSpace: 'nowrap', to get overflow rate.\n   * So that the logic can predict truncated text well.\n   */\n  private get _needMeasurement(): boolean {\n    return !!this.props.shouldTruncate && this._clientWidth === undefined;\n  }\n\n  // Truncate logic here way can't handle the case that chars with different widths are mixed very well.\n  // Let _shrinkTitle take care of that.\n  private _truncateTitle = (): void => {\n    if (!this._needMeasurement) {\n      return;\n    }\n\n    this._async.requestAnimationFrame(this._truncateWhenInAnimation);\n  };\n\n  private _truncateWhenInAnimation: () => void = () => {\n    const originalTitle = this.props.title;\n    const element: HTMLDivElement | null = this._titleElement.current;\n\n    if (element) {\n      const style: CSSStyleDeclaration = getComputedStyle(element);\n      if (style.width && style.lineHeight && style.height) {\n        const { clientWidth, scrollWidth } = element;\n\n        this._clientWidth = clientWidth;\n\n        const lines: number = Math.floor(\n          (parseInt(style.height, 10) + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD) / parseInt(style.lineHeight, 10),\n        );\n\n        element.style.whiteSpace = '';\n\n        // Use overflow to predict truncated length.\n        // Take an example.The text is: A text with A very long text that need to be truncated.ppt\n        // if container is like\n        // |A text with A very| long text that need to be truncated.ppt\n        // The scroll width is 58, (take two | out of length)\n        // The client width is 18\n        // the overflow rate is scrollWidth/clientWidth which should be close to length(overflowText)/length(visualText)\n        // And the length of remaining text should be truncated is (original Length)/(58/18) -3 = 15.\n        // So that the logic can predict truncated text well.\n        // first piece will be `A text `, * second piece will be `ated.ppt`\n        // |A text ...ated.ppt|\n        const overFlowRate: number = scrollWidth / (parseInt(style.width, 10) * lines);\n\n        if (overFlowRate > 1) {\n          const truncatedLength: number = originalTitle.length / overFlowRate - 3; /** Saved for separator */\n          return this.setState({\n            truncatedTitleFirstPiece: originalTitle.slice(0, truncatedLength / 2),\n            truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - truncatedLength / 2),\n          });\n        }\n      }\n    }\n  };\n\n  private _shrinkTitle: () => void = () => {\n    const { truncatedTitleFirstPiece, truncatedTitleSecondPiece } = this.state;\n    if (truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      const titleElement = this._titleElement.current;\n\n      if (!titleElement) {\n        return;\n      }\n\n      if (\n        titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD ||\n        titleElement.scrollWidth > titleElement.clientWidth\n      ) {\n        this.setState({\n          truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),\n          truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1),\n        });\n      }\n    }\n  };\n\n  private _updateTruncation(): void {\n    if (this._timerId) {\n      return;\n    }\n\n    this._timerId = this._async.setTimeout(() => {\n      delete this._timerId;\n      this._clientWidth = undefined;\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined,\n      });\n    }, 250);\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}