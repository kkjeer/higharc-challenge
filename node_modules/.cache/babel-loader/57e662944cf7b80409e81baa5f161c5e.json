{"ast":null,"code":"/**\n * Rectangle helper class.\n *\n * @public\n * {@docCategory Rectangle}\n */\nvar Rectangle =\n/** @class */\nfunction () {\n  function Rectangle(left, right, top, bottom) {\n    if (left === void 0) {\n      left = 0;\n    }\n\n    if (right === void 0) {\n      right = 0;\n    }\n\n    if (top === void 0) {\n      top = 0;\n    }\n\n    if (bottom === void 0) {\n      bottom = 0;\n    }\n\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n  }\n\n  Object.defineProperty(Rectangle.prototype, \"width\", {\n    /**\n     * Calculated automatically by subtracting the right from left\n     */\n    get: function () {\n      return this.right - this.left;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Rectangle.prototype, \"height\", {\n    /**\n     * Calculated automatically by subtracting the bottom from top.\n     */\n    get: function () {\n      return this.bottom - this.top;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Tests if another rect is approximately equal to this rect (within 4 decimal places.)\n   */\n\n  Rectangle.prototype.equals = function (rect) {\n    // Fixing to 4 decimal places because it allows enough precision and will handle cases when something\n    // should be rounded, like .999999 should round to 1.\n    return parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) && parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) && parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) && parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4));\n  };\n\n  return Rectangle;\n}();\n\nexport { Rectangle };","map":{"version":3,"sources":["Rectangle.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AACH,IAAA,SAAA;AAAA;AAAA,YAAA;EAME,SAAA,SAAA,CAAY,IAAZ,EAA8B,KAA9B,EAAiD,GAAjD,EAAkE,MAAlE,EAAoF;IAAxE,IAAA,IAAA,KAAA,KAAA,CAAA,EAAA;MAAA,IAAA,GAAA,CAAA;IAAgB;;IAAE,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;MAAA,KAAA,GAAA,CAAA;IAAiB;;IAAE,IAAA,GAAA,KAAA,KAAA,CAAA,EAAA;MAAA,GAAA,GAAA,CAAA;IAAe;;IAAE,IAAA,MAAA,KAAA,KAAA,CAAA,EAAA;MAAA,MAAA,GAAA,CAAA;IAAkB;;IAClF,KAAK,GAAL,GAAW,GAAX;IACA,KAAK,MAAL,GAAc,MAAd;IACA,KAAK,IAAL,GAAY,IAAZ;IACA,KAAK,KAAL,GAAa,KAAb;EACD;;EAKD,MAAA,CAAA,cAAA,CAAW,SAAA,CAAA,SAAX,EAAW,OAAX,EAAgB;IAHhB;;AAEG;SACH,YAAA;MACE,OAAO,KAAK,KAAL,GAAa,KAAK,IAAzB;IACD,CAFe;qBAAA;;EAAA,CAAhB;EAOA,MAAA,CAAA,cAAA,CAAW,SAAA,CAAA,SAAX,EAAW,QAAX,EAAiB;IAHjB;;AAEG;SACH,YAAA;MACE,OAAO,KAAK,MAAL,GAAc,KAAK,GAA1B;IACD,CAFgB;qBAAA;;EAAA,CAAjB;EAIA;;AAEG;;EACI,SAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAA6B;IAC3B;IACA;IACA,OACE,UAAU,CAAC,KAAK,GAAL,CAAS,OAAT,CAAiB,CAAjB,CAAD,CAAV,KAAoC,UAAU,CAAC,IAAI,CAAC,GAAL,CAAS,OAAT,CAAiB,CAAjB,CAAD,CAA9C,IACA,UAAU,CAAC,KAAK,MAAL,CAAY,OAAZ,CAAoB,CAApB,CAAD,CAAV,KAAuC,UAAU,CAAC,IAAI,CAAC,MAAL,CAAY,OAAZ,CAAoB,CAApB,CAAD,CADjD,IAEA,UAAU,CAAC,KAAK,IAAL,CAAU,OAAV,CAAkB,CAAlB,CAAD,CAAV,KAAqC,UAAU,CAAC,IAAI,CAAC,IAAL,CAAU,OAAV,CAAkB,CAAlB,CAAD,CAF/C,IAGA,UAAU,CAAC,KAAK,KAAL,CAAW,OAAX,CAAmB,CAAnB,CAAD,CAAV,KAAsC,UAAU,CAAC,IAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,CAAnB,CAAD,CAJlD;EAMD,CATM;;EAUT,OAAA,SAAA;AAAC,CAxCD,EAAA","sourcesContent":["/**\n * Rectangle helper class.\n *\n * @public\n * {@docCategory Rectangle}\n */\nexport class Rectangle {\n  public top: number;\n  public bottom: number;\n  public left: number;\n  public right: number;\n\n  constructor(left: number = 0, right: number = 0, top: number = 0, bottom: number = 0) {\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n  }\n\n  /**\n   * Calculated automatically by subtracting the right from left\n   */\n  public get width(): number {\n    return this.right - this.left;\n  }\n\n  /**\n   * Calculated automatically by subtracting the bottom from top.\n   */\n  public get height(): number {\n    return this.bottom - this.top;\n  }\n\n  /**\n   * Tests if another rect is approximately equal to this rect (within 4 decimal places.)\n   */\n  public equals(rect: Rectangle): boolean {\n    // Fixing to 4 decimal places because it allows enough precision and will handle cases when something\n    // should be rounded, like .999999 should round to 1.\n    return (\n      parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&\n      parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&\n      parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&\n      parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4))\n    );\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}