{"ast":null,"code":"import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\n\nexport var useOverflow = function (_a) {\n  var onOverflowItemsChanged = _a.onOverflowItemsChanged,\n      rtl = _a.rtl,\n      pinnedIndex = _a.pinnedIndex;\n  var updateOverflowRef = React.useRef();\n  var containerWidthRef = React.useRef(); // Attach a resize observer to the container\n\n  var containerRef = useRefEffect(function (container) {\n    var cleanupObserver = observeResize(container, function (entries) {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n    return function () {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n  var menuButtonRef = useRefEffect(function (menuButton) {\n    containerRef(menuButton.parentElement);\n    return function () {\n      return containerRef(null);\n    };\n  });\n  useIsomorphicLayoutEffect(function () {\n    var container = containerRef.current;\n    var menuButton = menuButtonRef.current;\n\n    if (!container || !menuButton) {\n      return;\n    } // items contains the container's children, excluding the overflow menu button itself\n\n\n    var items = [];\n\n    for (var i = 0; i < container.children.length; i++) {\n      var item = container.children[i];\n\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    } // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n\n\n    var minContainerWidth = [];\n    var extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = function () {\n      var containerWidth = containerWidthRef.current;\n\n      if (containerWidth === undefined) {\n        return;\n      } // Iterate the items in reverse order until we find one that fits within the bounds of the container\n\n\n      for (var i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          var itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth; // If the item after this one is pinned, reserve space for it\n\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          } // Reserve space for the menu button after the first item was added to the overflow\n\n\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      } // If we got here, nothing fits outside the overflow\n\n\n      setOverflowIndex(0);\n    };\n\n    var prevOverflowIndex = items.length;\n\n    var setOverflowIndex = function (overflowIndex) {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(overflowIndex, items.map(function (ele, index) {\n          return {\n            ele: ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex\n          };\n        }));\n      }\n    };\n\n    var cancelAnimationFrame = undefined; // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n\n    if (containerWidthRef.current !== undefined) {\n      var win_1 = getWindow(container);\n\n      if (win_1) {\n        var animationFrameId_1 = win_1.requestAnimationFrame(updateOverflowRef.current);\n\n        cancelAnimationFrame = function () {\n          return win_1.cancelAnimationFrame(animationFrameId_1);\n        };\n      }\n    }\n\n    return function () {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      } // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n\n\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n  return {\n    menuButtonRef: menuButtonRef\n  };\n};","map":{"version":3,"sources":["utilities/useOverflow.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,yBAAT,EAAoC,YAApC,QAAwD,uBAAxD;AACA,SAAS,SAAT,QAA0B,qBAA1B;AACA,SAAS,aAAT,QAA8B,iBAA9B;AAiCA;;;;;;;;;;;;;;;;;AAiBG;;AACH,OAAO,IAAM,WAAW,GAAG,UAAC,EAAD,EAA6D;MAA1D,sBAAsB,GAAA,EAAA,CAAA,sB;MAAE,GAAG,GAAA,EAAA,CAAA,G;MAAE,WAAW,GAAA,EAAA,CAAA,W;EACpE,IAAM,iBAAiB,GAAG,KAAK,CAAC,MAAN,EAA1B;EACA,IAAM,iBAAiB,GAAG,KAAK,CAAC,MAAN,EAA1B,CAFsF,CAItF;;EACA,IAAM,YAAY,GAAG,YAAY,CAAc,UAAA,SAAA,EAAS;IACtD,IAAM,eAAe,GAAG,aAAa,CAAC,SAAD,EAAY,UAAA,OAAA,EAAO;MACtD,iBAAiB,CAAC,OAAlB,GAA4B,OAAO,GAAG,OAAO,CAAC,CAAD,CAAP,CAAW,WAAX,CAAuB,KAA1B,GAAkC,SAAS,CAAC,WAA/E;;MACA,IAAI,iBAAiB,CAAC,OAAtB,EAA+B;QAC7B,iBAAiB,CAAC,OAAlB;MACD;IACF,CALoC,CAArC;IAOA,OAAO,YAAA;MACL,eAAe;MACf,iBAAiB,CAAC,OAAlB,GAA4B,SAA5B;IACD,CAHD;EAID,CAZgC,CAAjC;EAcA,IAAM,aAAa,GAAG,YAAY,CAAc,UAAA,UAAA,EAAU;IACxD,YAAY,CAAC,UAAU,CAAC,aAAZ,CAAZ;IACA,OAAO,YAAA;MAAM,OAAA,YAAY,CAAZ,IAAY,CAAZ;IAAkB,CAA/B;EACD,CAHiC,CAAlC;EAKA,yBAAyB,CAAC,YAAA;IACxB,IAAM,SAAS,GAAG,YAAY,CAAC,OAA/B;IACA,IAAM,UAAU,GAAG,aAAa,CAAC,OAAjC;;IACA,IAAI,CAAC,SAAD,IAAc,CAAC,UAAnB,EAA+B;MAC7B;IACD,CALuB,CAOxB;;;IACA,IAAM,KAAK,GAAkB,EAA7B;;IACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,QAAV,CAAmB,MAAvC,EAA+C,CAAC,EAAhD,EAAoD;MAClD,IAAM,IAAI,GAAG,SAAS,CAAC,QAAV,CAAmB,CAAnB,CAAb;;MACA,IAAI,IAAI,YAAY,WAAhB,IAA+B,IAAI,KAAK,UAA5C,EAAwD;QACtD,KAAK,CAAC,IAAN,CAAW,IAAX;MACD;IACF,CAduB,CAgBxB;IACA;IACA;;;IACA,IAAM,iBAAiB,GAAa,EAApC;IACA,IAAI,UAAU,GAAG,CAAjB,CApBwB,CAoBJ;;IAEpB,iBAAiB,CAAC,OAAlB,GAA4B,YAAA;MAC1B,IAAM,cAAc,GAAG,iBAAiB,CAAC,OAAzC;;MACA,IAAI,cAAc,KAAK,SAAvB,EAAkC;QAChC;MACD,CAJyB,CAM1B;;;MACA,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAN,GAAe,CAA5B,EAA+B,CAAC,IAAI,CAApC,EAAuC,CAAC,EAAxC,EAA4C;QAC1C;QACA,IAAI,iBAAiB,CAAC,CAAD,CAAjB,KAAyB,SAA7B,EAAwC;UACtC,IAAM,aAAa,GAAG,GAAG,GAAG,cAAc,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,UAA7B,GAA0C,KAAK,CAAC,CAAD,CAAL,CAAS,UAAT,GAAsB,KAAK,CAAC,CAAD,CAAL,CAAS,WAAlG,CADsC,CAGtC;;UACA,IAAI,CAAC,GAAG,CAAJ,GAAQ,KAAK,CAAC,MAAd,IAAwB,CAAC,GAAG,CAAJ,KAAU,WAAtC,EAAmD;YACjD;YACA;YACA,UAAU,GAAG,iBAAiB,CAAC,CAAC,GAAG,CAAL,CAAjB,GAA2B,aAAxC;UACD,CARqC,CAUtC;;;UACA,IAAI,CAAC,KAAK,KAAK,CAAC,MAAN,GAAe,CAAzB,EAA4B;YAC1B,UAAU,IAAI,UAAU,CAAC,WAAzB;UACD;;UAED,iBAAiB,CAAC,CAAD,CAAjB,GAAuB,aAAa,GAAG,UAAvC;QACD;;QAED,IAAI,cAAc,GAAG,iBAAiB,CAAC,CAAD,CAAtC,EAA2C;UACzC,gBAAgB,CAAC,CAAC,GAAG,CAAL,CAAhB;UACA;QACD;MACF,CA/ByB,CAiC1B;;;MACA,gBAAgB,CAAC,CAAD,CAAhB;IACD,CAnCD;;IAqCA,IAAI,iBAAiB,GAAG,KAAK,CAAC,MAA9B;;IACA,IAAM,gBAAgB,GAAG,UAAC,aAAD,EAAsB;MAC7C,IAAI,iBAAiB,KAAK,aAA1B,EAAyC;QACvC,iBAAiB,GAAG,aAApB;QACA,sBAAsB,CACpB,aADoB,EAEpB,KAAK,CAAC,GAAN,CAAU,UAAC,GAAD,EAAM,KAAN,EAAW;UAAK,OAAC;YACzB,GAAG,EAAA,GADsB;YAEzB,aAAa,EAAE,KAAK,IAAI,aAAT,IAA0B,KAAK,KAAK;UAF1B,CAAD;QAGxB,CAHF,CAFoB,CAAtB;MAOD;IACF,CAXD;;IAaA,IAAI,oBAAoB,GAA6B,SAArD,CAzEwB,CA2ExB;IACA;;IACA,IAAI,iBAAiB,CAAC,OAAlB,KAA8B,SAAlC,EAA6C;MAC3C,IAAM,KAAG,GAAG,SAAS,CAAC,SAAD,CAArB;;MACA,IAAI,KAAJ,EAAS;QACP,IAAM,kBAAgB,GAAG,KAAG,CAAC,qBAAJ,CAA0B,iBAAiB,CAAC,OAA5C,CAAzB;;QACA,oBAAoB,GAAG,YAAA;UAAM,OAAA,KAAG,CAAC,oBAAJ,CAAA,kBAAA,CAAA;QAA0C,CAAvE;MACD;IACF;;IAED,OAAO,YAAA;MACL,IAAI,oBAAJ,EAA0B;QACxB,oBAAoB;MACrB,CAHI,CAKL;MACA;;;MACA,gBAAgB,CAAC,KAAK,CAAC,MAAP,CAAhB;MACA,iBAAiB,CAAC,OAAlB,GAA4B,SAA5B;IACD,CATD;EAUD,CA/FwB,CAAzB;EAiGA,OAAO;IAAE,aAAa,EAAA;EAAf,CAAP;AACD,CA1HM","sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\nimport type { RefCallback } from '@fluentui/react-hooks';\n\n/**\n * Callback to notify the user that the items in the overflow have changed. This should ensure that the overflow menu\n * is visible, and contains all of the overflowing items.\n *\n * @param overflowIndex - The index of the first item in the overflow, or items.length if nothing is overflowing.\n * @param items - The list of all items in the container, and whether that particular item is in the overflow\n */\nexport type OverflowItemsChangedCallback = (\n  overflowIndex: number,\n  items: { ele: HTMLElement; isOverflowing: boolean }[],\n) => void;\n\n/** Parameters for {@see useOverflow} */\nexport type OverflowParams = {\n  /** Callback to notify the user that the items in the overflow have changed. */\n  onOverflowItemsChanged: OverflowItemsChangedCallback;\n\n  /** True if the element containing overflowMenuButtonRef is in right-to-left order */\n  rtl: boolean;\n\n  /** Optional: Index of item that should never go into the overflow menu. */\n  pinnedIndex?: number;\n};\n\n/** Return value for {@see useOverflow} */\nexport type OverflowRefs = {\n  /** Set the overflow menu button's ref to this ref callback */\n  menuButtonRef: RefCallback<HTMLElement>;\n};\n\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport const useOverflow = ({ onOverflowItemsChanged, rtl, pinnedIndex }: OverflowParams): OverflowRefs => {\n  const updateOverflowRef = React.useRef<() => void>();\n  const containerWidthRef = React.useRef<number>();\n\n  // Attach a resize observer to the container\n  const containerRef = useRefEffect<HTMLElement>(container => {\n    const cleanupObserver = observeResize(container, entries => {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n\n    return () => {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n\n  const menuButtonRef = useRefEffect<HTMLElement>(menuButton => {\n    containerRef(menuButton.parentElement);\n    return () => containerRef(null);\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const container = containerRef.current;\n    const menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n\n    // items contains the container's children, excluding the overflow menu button itself\n    const items: HTMLElement[] = [];\n    for (let i = 0; i < container.children.length; i++) {\n      const item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    const minContainerWidth: number[] = [];\n    let extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = () => {\n      const containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (let i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          const itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n\n    let prevOverflowIndex = items.length;\n    const setOverflowIndex = (overflowIndex: number) => {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(\n          overflowIndex,\n          items.map((ele, index) => ({\n            ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex,\n          })),\n        );\n      }\n    };\n\n    let cancelAnimationFrame: (() => void) | undefined = undefined;\n\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      const win = getWindow(container);\n      if (win) {\n        const animationFrameId = win.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = () => win.cancelAnimationFrame(animationFrameId);\n      }\n    }\n\n    return () => {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n\n  return { menuButtonRef };\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}