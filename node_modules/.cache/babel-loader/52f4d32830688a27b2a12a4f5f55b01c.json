{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { anchorProperties, assign, buttonProperties, createMergedRef, css, getId, getNativeProps, initializeComponentRef, memoizeFunction, mergeAriaAttributeValues, nullRender, portalContainsElement, setFocusVisibility, warnConditionallyRequiredProps, warnDeprecations, Async, EventGroup, FocusRects, KeyCodes } from '../../Utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu } from '../../ContextualMenu';\nimport { getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getSplitButtonClassNames as getBaseSplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport { composeComponentAs } from '../../Utilities';\nvar TouchIdleDelay = 500;\n/* ms */\n\nvar COMPONENT_NAME = 'BaseButton';\n/**\n * {@docCategory Button}\n */\n\nvar BaseButton =\n/** @class */\nfunction (_super) {\n  __extends(BaseButton, _super);\n\n  function BaseButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._buttonElement = React.createRef();\n    _this._splitButtonContainer = React.createRef();\n    _this._mergedRef = createMergedRef();\n    _this._renderedVisibleMenu = false;\n    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n      return __assign(__assign({}, keytipProps), {\n        hasMenu: true\n      });\n    });\n\n    _this._onRenderIcon = function (buttonProps, defaultRender) {\n      var iconProps = _this.props.iconProps;\n\n      if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n        var className = iconProps.className,\n            imageProps = iconProps.imageProps,\n            rest = __rest(iconProps, [\"className\", \"imageProps\"]); // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon\n        // do not have this prop.\n\n\n        if (iconProps.styles) {\n          return React.createElement(Icon, __assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n\n        if (iconProps.iconName) {\n          return React.createElement(FontIcon, __assign({\n            className: css(_this._classNames.icon, className)\n          }, rest));\n        }\n\n        if (imageProps) {\n          return React.createElement(ImageIcon, __assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n      }\n\n      return null;\n    };\n\n    _this._onRenderTextContents = function () {\n      var _a = _this.props,\n          text = _a.text,\n          children = _a.children,\n          // eslint-disable-next-line deprecation/deprecation\n      _b = _a.secondaryText,\n          // eslint-disable-next-line deprecation/deprecation\n      secondaryText = _b === void 0 ? _this.props.description : _b,\n          _c = _a.onRenderText,\n          onRenderText = _c === void 0 ? _this._onRenderText : _c,\n          _d = _a.onRenderDescription,\n          onRenderDescription = _d === void 0 ? _this._onRenderDescription : _d;\n\n      if (text || typeof children === 'string' || secondaryText) {\n        return React.createElement(\"span\", {\n          className: _this._classNames.textContainer\n        }, onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription));\n      }\n\n      return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];\n    };\n\n    _this._onRenderText = function () {\n      var text = _this.props.text;\n      var children = _this.props.children; // For backwards compat, we should continue to take in the text content from children.\n\n      if (text === undefined && typeof children === 'string') {\n        text = children;\n      }\n\n      if (_this._hasText()) {\n        return React.createElement(\"span\", {\n          key: _this._labelId,\n          className: _this._classNames.label,\n          id: _this._labelId\n        }, text);\n      }\n\n      return null;\n    };\n\n    _this._onRenderChildren = function () {\n      var children = _this.props.children; // If children is just a string, either it or the text will be rendered via onRenderLabel\n      // If children is another component, it will be rendered after text\n\n      if (typeof children === 'string') {\n        return null;\n      }\n\n      return children;\n    };\n\n    _this._onRenderDescription = function (props) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = props.secondaryText,\n          secondaryText = _a === void 0 ? _this.props.description : _a; // ms-Button-description is only shown when the button type is compound.\n      // In other cases it will not be displayed.\n\n      return secondaryText ? React.createElement(\"span\", {\n        key: _this._descriptionId,\n        className: _this._classNames.description,\n        id: _this._descriptionId\n      }, secondaryText) : null;\n    };\n\n    _this._onRenderAriaDescription = function () {\n      var ariaDescription = _this.props.ariaDescription; // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n      // otherwise it will be assigned to descriptionSpan.\n\n      return ariaDescription ? React.createElement(\"span\", {\n        className: _this._classNames.screenReaderText,\n        id: _this._ariaDescriptionId\n      }, ariaDescription) : null;\n    };\n\n    _this._onRenderMenuIcon = function (props) {\n      var menuIconProps = _this.props.menuIconProps;\n      return React.createElement(FontIcon, __assign({\n        iconName: \"ChevronDown\"\n      }, menuIconProps, {\n        className: _this._classNames.menuIcon\n      }));\n    };\n\n    _this._onRenderMenu = function (menuProps) {\n      var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;\n      return React.createElement(MenuType, __assign({}, menuProps));\n    };\n\n    _this._onDismissMenu = function (ev) {\n      var menuProps = _this.props.menuProps;\n\n      if (menuProps && menuProps.onDismiss) {\n        menuProps.onDismiss(ev);\n      }\n\n      if (!ev || !ev.defaultPrevented) {\n        _this._dismissMenu();\n      }\n    };\n\n    _this._dismissMenu = function () {\n      _this._menuShouldFocusOnMount = undefined;\n      _this._menuShouldFocusOnContainer = undefined;\n\n      _this.setState({\n        menuHidden: true\n      });\n    };\n\n    _this._openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n      if (shouldFocusOnMount === void 0) {\n        shouldFocusOnMount = true;\n      }\n\n      if (_this.props.menuProps) {\n        _this._menuShouldFocusOnContainer = shouldFocusOnContainer;\n        _this._menuShouldFocusOnMount = shouldFocusOnMount;\n        _this._renderedVisibleMenu = true;\n\n        _this.setState({\n          menuHidden: false\n        });\n      }\n    };\n\n    _this._onToggleMenu = function (shouldFocusOnContainer) {\n      var shouldFocusOnMount = true;\n\n      if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {\n        shouldFocusOnMount = false;\n      }\n\n      _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();\n    };\n\n    _this._onSplitContainerFocusCapture = function (ev) {\n      var container = _this._splitButtonContainer.current; // If the target is coming from the portal we do not need to set focus on the container.\n\n      if (!container || ev.target && portalContainsElement(ev.target, container)) {\n        return;\n      } // We should never be able to focus the individual buttons in a split button. Focus\n      // should always remain on the container.\n\n\n      container.focus();\n    };\n\n    _this._onSplitButtonPrimaryClick = function (ev) {\n      if (!_this.state.menuHidden) {\n        _this._dismissMenu();\n      }\n\n      if (!_this._processingTouch && _this.props.onClick) {\n        _this.props.onClick(ev);\n      } else if (_this._processingTouch) {\n        _this._onMenuClick(ev);\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      // explicity cancelling event so click won't fire after this\n      // eslint-disable-next-line deprecation/deprecation\n      if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      } else if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuKeyDown(ev);\n        } else if (_this.props.onKeyDown !== undefined) {\n          _this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n\n        }\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onKeyUp !== undefined) {\n        _this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onKeyPress = function (ev) {\n      if (!_this.props.disabled && _this.props.onKeyPress !== undefined) {\n        _this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onMouseUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseUp !== undefined) {\n        _this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onMouseDown = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseDown !== undefined) {\n        _this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onClick = function (ev) {\n      if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuClick(ev);\n        } else if (_this.props.onClick !== undefined) {\n          _this.props.onClick(ev); // not cancelling event because it's not disabled\n\n        }\n      }\n    };\n\n    _this._onSplitButtonContainerKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n        if (_this._buttonElement.current) {\n          _this._buttonElement.current.click();\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      } else {\n        _this._onMenuKeyDown(ev);\n      }\n    };\n\n    _this._onMenuKeyDown = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var isUp = ev.which === KeyCodes.up; // eslint-disable-next-line deprecation/deprecation\n\n      var isDown = ev.which === KeyCodes.down;\n\n      if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {\n        var onMenuClick = _this.props.onMenuClick;\n\n        if (onMenuClick) {\n          onMenuClick(ev, _this.props);\n        }\n\n        _this._onToggleMenu(false);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n        // We manually set the focus visibility to true if opening via Enter or Space to account for the scenario where\n        // a user clicks on the button, closes the menu and then opens it via keyboard. In this scenario our default logic\n        // for setting focus visibility is not triggered since there is no keyboard navigation present beforehand.\n        setFocusVisibility(true, ev.target);\n      }\n\n      if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n        // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items\n        // We need to re-render the menu with shouldFocusOnMount as true.\n        if (!_this.state.menuHidden && _this.props.menuProps) {\n          var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== undefined ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;\n\n          if (!currentShouldFocusOnMount) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            _this._menuShouldFocusOnMount = true;\n\n            _this.forceUpdate();\n          }\n        }\n      }\n    };\n\n    _this._onTouchStart = function () {\n      if (_this._isSplitButton && _this._splitButtonContainer.current && !('onpointerdown' in _this._splitButtonContainer.current)) {\n        _this._handleTouchAndPointerEvent();\n      }\n    };\n\n    _this._onMenuClick = function (ev) {\n      var _a = _this.props,\n          onMenuClick = _a.onMenuClick,\n          menuProps = _a.menuProps;\n\n      if (onMenuClick) {\n        onMenuClick(ev, _this.props);\n      } // focus on the container by default when the menu is opened with a click event\n      // this differentiates from a keyboard interaction triggering the click event\n\n\n      var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === 'boolean' ? menuProps.shouldFocusOnContainer : ev.nativeEvent.pointerType === 'mouse';\n\n      if (!ev.defaultPrevented) {\n        _this._onToggleMenu(shouldFocusOnContainer);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnConditionallyRequiredProps(COMPONENT_NAME, props, ['menuProps', 'onClick'], 'split', _this.props.split);\n    warnDeprecations(COMPONENT_NAME, props, {\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked'\n    });\n    _this._labelId = getId();\n    _this._descriptionId = getId();\n    _this._ariaDescriptionId = getId();\n    _this.state = {\n      menuHidden: true\n    };\n    return _this;\n  }\n\n  Object.defineProperty(BaseButton.prototype, \"_isSplitButton\", {\n    get: function () {\n      return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  BaseButton.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        ariaDescription = _b.ariaDescription,\n        ariaLabel = _b.ariaLabel,\n        ariaHidden = _b.ariaHidden,\n        className = _b.className,\n        disabled = _b.disabled,\n        allowDisabledFocus = _b.allowDisabledFocus,\n        primaryDisabled = _b.primaryDisabled,\n        // eslint-disable-next-line deprecation/deprecation\n    _c = _b.secondaryText,\n        // eslint-disable-next-line deprecation/deprecation\n    secondaryText = _c === void 0 ? this.props.description : _c,\n        href = _b.href,\n        iconProps = _b.iconProps,\n        menuIconProps = _b.menuIconProps,\n        styles = _b.styles,\n        checked = _b.checked,\n        variantClassName = _b.variantClassName,\n        theme = _b.theme,\n        toggle = _b.toggle,\n        getClassNames = _b.getClassNames,\n        role = _b.role;\n    var menuHidden = this.state.menuHidden; // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled\n\n    var isPrimaryButtonDisabled = disabled || primaryDisabled;\n    this._classNames = getClassNames ? getClassNames(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);\n\n    var _d = this,\n        _ariaDescriptionId = _d._ariaDescriptionId,\n        _labelId = _d._labelId,\n        _descriptionId = _d._descriptionId; // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n\n\n    var renderAsAnchor = !isPrimaryButtonDisabled && !!href;\n    var tag = renderAsAnchor ? 'a' : 'button';\n    var nativeProps = getNativeProps( // eslint-disable-next-line deprecation/deprecation\n    assign(renderAsAnchor ? {} : {\n      type: 'button'\n    }, this.props.rootProps, this.props), renderAsAnchor ? anchorProperties : buttonProperties, ['disabled' // let disabled buttons be focused and styled as disabled.\n    ]); // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n\n    var resolvedAriaLabel = ariaLabel || nativeProps['aria-label']; // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of\n    // aria-describedby. Otherwise default to undefined so property does not appear in output.\n\n    var ariaDescribedBy = undefined;\n\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if (nativeProps['aria-describedby']) {\n      ariaDescribedBy = nativeProps['aria-describedby'];\n    } // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute)\n    // and no ariaLabel is specified, set the labelledby element.\n    // Otherwise, the button is labeled implicitly by the descendent text on the button (if it exists).\n\n\n    var ariaLabelledBy = undefined;\n\n    if (nativeProps['aria-labelledby']) {\n      ariaLabelledBy = nativeProps['aria-labelledby'];\n    } else if (ariaDescribedBy && !resolvedAriaLabel) {\n      ariaLabelledBy = this._hasText() ? _labelId : undefined;\n    }\n\n    var dataIsFocusable = this.props['data-is-focusable'] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;\n    var isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox'; // if isCheckboxTypeRole, always return a checked value.\n    // Otherwise only return checked value if toggle is set to true.\n    // This is because role=\"checkbox\" always needs to have an aria-checked value\n    // but our checked prop only sets aria-pressed if we mark the button as a toggle=\"true\"\n\n    var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;\n    var buttonProps = assign(nativeProps, (_a = {\n      className: this._classNames.root,\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._buttonElement),\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable\n    }, // aria-pressed attribute should only be present for toggle buttons\n    // aria-checked attribute should only be present for toggle buttons with checkbox type role\n    _a[isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed'] = checkedOrPressedValue, _a));\n\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      var _e = this.props.menuProps.id,\n          id = _e === void 0 ? this._labelId + \"-menu\" : _e;\n      assign(buttonProps, {\n        'aria-expanded': !menuHidden,\n        'aria-controls': !menuHidden ? id : null,\n        'aria-haspopup': true\n      });\n    }\n\n    return this._onRenderContent(tag, buttonProps);\n  };\n\n  BaseButton.prototype.componentDidMount = function () {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the\n    // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,\n    // because React does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      if ('onpointerdown' in this._splitButtonContainer.current) {\n        this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n      }\n\n      if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {\n        this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);\n      }\n    }\n  };\n\n  BaseButton.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // If Button's menu was closed, run onAfterMenuDismiss.\n    if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {\n      this.props.onAfterMenuDismiss();\n    }\n  };\n\n  BaseButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  BaseButton.prototype.focus = function () {\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      setFocusVisibility(true);\n\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      setFocusVisibility(true);\n\n      this._buttonElement.current.focus();\n    }\n  };\n\n  BaseButton.prototype.dismissMenu = function () {\n    this._dismissMenu();\n  };\n\n  BaseButton.prototype.openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  };\n\n  BaseButton.prototype._onRenderContent = function (tag, buttonProps) {\n    var _this = this;\n\n    var props = this.props;\n    var Tag = tag;\n    var menuIconProps = props.menuIconProps,\n        menuProps = props.menuProps,\n        _a = props.onRenderIcon,\n        onRenderIcon = _a === void 0 ? this._onRenderIcon : _a,\n        _b = props.onRenderAriaDescription,\n        onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b,\n        _c = props.onRenderChildren,\n        onRenderChildren = _c === void 0 ? this._onRenderChildren : _c,\n        // eslint-disable-next-line deprecation/deprecation\n    _d = props.onRenderMenu,\n        // eslint-disable-next-line deprecation/deprecation\n    onRenderMenu = _d === void 0 ? this._onRenderMenu : _d,\n        _e = props.onRenderMenuIcon,\n        onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e,\n        disabled = props.disabled;\n    var keytipProps = props.keytipProps;\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    var Button = function (keytipAttributes) {\n      return React.createElement(Tag, __assign({}, buttonProps, keytipAttributes), React.createElement(\"span\", {\n        className: _this._classNames.flexContainer,\n        \"data-automationid\": \"splitbuttonprimary\"\n      }, onRenderIcon(props, _this._onRenderIcon), _this._onRenderTextContents(), onRenderAriaDescription(props, _this._onRenderAriaDescription), onRenderChildren(props, _this._onRenderChildren), !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon), menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)));\n    };\n\n    var Content = keytipProps ? // If we're making a split button, we won't put the keytip here\n    React.createElement(KeytipData, {\n      keytipProps: !this._isSplitButton ? keytipProps : undefined,\n      ariaDescribedBy: buttonProps['aria-describedby'],\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return Button(keytipAttributes);\n    }) : Button();\n\n    if (menuProps && menuProps.doNotLayer) {\n      return React.createElement(React.Fragment, null, Content, this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu));\n    }\n\n    return React.createElement(React.Fragment, null, Content, React.createElement(FocusRects, null));\n  };\n  /**\n   * Method to help determine if the menu's component tree should\n   * be rendered. It takes into account whether the menu is expanded,\n   * whether it is a persisted menu and whether it has been shown to the user.\n   */\n\n\n  BaseButton.prototype._shouldRenderMenu = function () {\n    var menuHidden = this.state.menuHidden; // eslint-disable-next-line deprecation/deprecation\n\n    var _a = this.props,\n        persistMenu = _a.persistMenu,\n        renderPersistedMenuHiddenOnMount = _a.renderPersistedMenuHiddenOnMount;\n\n    if (!menuHidden) {\n      // Always should render a menu when it is expanded\n      return true;\n    } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {\n      // _renderedVisibleMenu ensures that the first rendering of\n      // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.\n      return true;\n    }\n\n    return false;\n  };\n\n  BaseButton.prototype._hasText = function () {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText\n    // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.\n    // text to be undefined in order for props.children to be used as a fallback.\n    // Purely a code maintainability/reuse issue, but logged as Issue #4979.\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  };\n\n  BaseButton.prototype._getMenuProps = function (menuProps) {\n    var persistMenu = this.props.persistMenu;\n    var menuHidden = this.state.menuHidden; // the accessible menu label (accessible name) has a relationship to the button.\n    // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n    // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n\n    if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {\n      menuProps = __assign(__assign({}, menuProps), {\n        labelElementId: this._labelId\n      });\n    }\n\n    return __assign(__assign({\n      id: this._labelId + '-menu',\n      directionalHint: DirectionalHint.bottomLeftEdge\n    }, menuProps), {\n      shouldFocusOnContainer: this._menuShouldFocusOnContainer,\n      shouldFocusOnMount: this._menuShouldFocusOnMount,\n      hidden: persistMenu ? menuHidden : undefined,\n      className: css('ms-BaseButton-menuhost', menuProps.className),\n      target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current,\n      onDismiss: this._onDismissMenu\n    });\n  };\n\n  BaseButton.prototype._onRenderSplitButtonContent = function (tag, buttonProps) {\n    var _this = this;\n\n    var _a = this.props,\n        _b = _a.styles,\n        styles = _b === void 0 ? {} : _b,\n        disabled = _a.disabled,\n        allowDisabledFocus = _a.allowDisabledFocus,\n        checked = _a.checked,\n        getSplitButtonClassNames = _a.getSplitButtonClassNames,\n        primaryDisabled = _a.primaryDisabled,\n        menuProps = _a.menuProps,\n        toggle = _a.toggle,\n        role = _a.role,\n        primaryActionButtonProps = _a.primaryActionButtonProps;\n    var keytipProps = this.props.keytipProps;\n    var menuHidden = this.state.menuHidden;\n    var classNames = getSplitButtonClassNames ? getSplitButtonClassNames(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles && getBaseSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);\n    assign(buttonProps, {\n      onClick: undefined,\n      onPointerDown: undefined,\n      onPointerUp: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false\n    });\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    var containerProps = getNativeProps(buttonProps, [], ['disabled']); // Add additional props to apply on primary action button\n\n    if (primaryActionButtonProps) {\n      assign(buttonProps, primaryActionButtonProps);\n    }\n\n    var SplitButton = function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, containerProps, {\n        \"data-ktp-target\": keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined,\n        role: role ? role : 'button',\n        \"aria-disabled\": disabled,\n        \"aria-haspopup\": true,\n        \"aria-expanded\": !menuHidden,\n        \"aria-pressed\": toggle ? !!checked : undefined,\n        \"aria-describedby\": mergeAriaAttributeValues(buttonProps['aria-describedby'], keytipAttributes ? keytipAttributes['aria-describedby'] : undefined),\n        className: classNames && classNames.splitButtonContainer,\n        onKeyDown: _this._onSplitButtonContainerKeyDown,\n        onTouchStart: _this._onTouchStart,\n        ref: _this._splitButtonContainer,\n        \"data-is-focusable\": true,\n        onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : undefined,\n        tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : undefined,\n        \"aria-roledescription\": buttonProps['aria-roledescription'],\n        onFocusCapture: _this._onSplitContainerFocusCapture\n      }), React.createElement(\"span\", {\n        style: {\n          display: 'flex'\n        }\n      }, _this._onRenderContent(tag, buttonProps), _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes), _this._onRenderSplitButtonDivider(classNames)));\n    };\n\n    return keytipProps ? React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return SplitButton(keytipAttributes);\n    }) : SplitButton();\n  };\n\n  BaseButton.prototype._onRenderSplitButtonDivider = function (classNames) {\n    if (classNames && classNames.divider) {\n      var onClick = function (ev) {\n        ev.stopPropagation();\n      };\n\n      return React.createElement(\"span\", {\n        className: classNames.divider,\n        \"aria-hidden\": true,\n        onClick: onClick\n      });\n    }\n\n    return null;\n  };\n\n  BaseButton.prototype._onRenderSplitButtonMenuButton = function (classNames, keytipAttributes) {\n    var _a = this.props,\n        allowDisabledFocus = _a.allowDisabledFocus,\n        checked = _a.checked,\n        disabled = _a.disabled,\n        splitButtonMenuProps = _a.splitButtonMenuProps,\n        splitButtonAriaLabel = _a.splitButtonAriaLabel,\n        primaryDisabled = _a.primaryDisabled;\n    var menuHidden = this.state.menuHidden;\n    var menuIconProps = this.props.menuIconProps;\n\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown'\n      };\n    }\n\n    var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), {\n      styles: classNames,\n      checked: checked,\n      disabled: disabled,\n      allowDisabledFocus: allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: __assign(__assign({}, menuIconProps), {\n        className: this._classNames.menuIcon\n      }),\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': !menuHidden,\n      'data-is-focusable': false\n    }); // Add data-ktp-execute-target to the split button if the keytip is defined\n\n\n    return React.createElement(BaseButton, __assign({}, splitButtonProps, {\n      \"data-ktp-execute-target\": keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes,\n      onMouseDown: this._onMouseDown,\n      tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1\n    }));\n  };\n\n  BaseButton.prototype._onPointerDown = function (ev) {\n    var onPointerDown = this.props.onPointerDown;\n\n    if (onPointerDown) {\n      onPointerDown(ev);\n    }\n\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  BaseButton.prototype._handleTouchAndPointerEvent = function () {\n    var _this = this; // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a new one.\n\n\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n\n      this._lastTouchTimeoutId = undefined;\n    }\n\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined; // Touch and pointer events don't focus the button naturally,\n      // so adding an imperative focus call to guarantee this behavior.\n\n      _this.focus();\n    }, TouchIdleDelay);\n  };\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n\n\n  BaseButton.prototype._isValidMenuOpenKey = function (ev) {\n    if (this.props.menuTriggerKeyCode) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    } // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n\n\n    return false;\n  };\n\n  BaseButton.defaultProps = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false\n  };\n  return BaseButton;\n}(React.Component);\n\nexport { BaseButton };","map":{"version":3,"sources":["components/Button/BaseButton.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  anchorProperties,\n  assign,\n  buttonProperties,\n  createMergedRef,\n  css,\n  getId,\n  getNativeProps,\n  initializeComponentRef,\n  memoizeFunction,\n  mergeAriaAttributeValues,\n  nullRender,\n  portalContainsElement,\n  setFocusVisibility,\n  warnConditionallyRequiredProps,\n  warnDeprecations,\n  Async,\n  EventGroup,\n  FocusRects,\n  KeyCodes,\n} from '../../Utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu } from '../../ContextualMenu';\nimport { getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getSplitButtonClassNames as getBaseSplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport type { IRenderFunction } from '../../Utilities';\nimport type { IContextualMenuProps } from '../../ContextualMenu';\nimport type { IButtonProps, IButton } from './Button.types';\nimport type { IButtonClassNames } from './BaseButton.classNames';\nimport type { ISplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport type { IKeytipProps } from '../../Keytip';\nimport { composeComponentAs } from '../../Utilities';\n\n/**\n * {@docCategory Button}\n */\nexport interface IBaseButtonProps extends IButtonProps {\n  baseClassName?: string;\n  variantClassName?: string;\n}\n\n/**\n * {@docCategory Button}\n */\nexport interface IBaseButtonState {\n  menuHidden: boolean;\n}\n\nconst TouchIdleDelay = 500; /* ms */\nconst COMPONENT_NAME = 'BaseButton';\n\n/**\n * {@docCategory Button}\n */\nexport class BaseButton extends React.Component<IBaseButtonProps, IBaseButtonState> implements IButton {\n  private get _isSplitButton(): boolean {\n    return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n  }\n\n  public static defaultProps: Partial<IBaseButtonProps> = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _buttonElement = React.createRef<HTMLElement>();\n  private _splitButtonContainer = React.createRef<HTMLDivElement>();\n  private _mergedRef = createMergedRef<HTMLElement>();\n  private _labelId: string;\n  private _descriptionId: string;\n  private _ariaDescriptionId: string;\n  private _classNames: IButtonClassNames;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  private _renderedVisibleMenu: boolean = false;\n\n  // These fields will be used to set corresponding props on the menu.\n  private _menuShouldFocusOnContainer: boolean | undefined;\n  private _menuShouldFocusOnMount: boolean | undefined;\n\n  private _getMemoizedMenuButtonKeytipProps = memoizeFunction((keytipProps: IKeytipProps) => {\n    return {\n      ...keytipProps,\n      hasMenu: true,\n    };\n  });\n\n  constructor(props: IBaseButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnConditionallyRequiredProps(COMPONENT_NAME, props, ['menuProps', 'onClick'], 'split', this.props.split!);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked',\n    });\n    this._labelId = getId();\n    this._descriptionId = getId();\n    this._ariaDescriptionId = getId();\n\n    this.state = {\n      menuHidden: true,\n    };\n  }\n\n  public render(): JSX.Element {\n    const {\n      ariaDescription,\n      ariaLabel,\n      ariaHidden,\n      className,\n      disabled,\n      allowDisabledFocus,\n      primaryDisabled,\n      // eslint-disable-next-line deprecation/deprecation\n      secondaryText = this.props.description,\n      href,\n      iconProps,\n      menuIconProps,\n      styles,\n      checked,\n      variantClassName,\n      theme,\n      toggle,\n      getClassNames,\n      role,\n    } = this.props;\n\n    const { menuHidden } = this.state;\n\n    // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled\n    const isPrimaryButtonDisabled = disabled || primaryDisabled;\n\n    this._classNames = getClassNames\n      ? getClassNames(\n          theme!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          checked!,\n          !menuHidden,\n          !!this.props.menuProps,\n          this.props.split,\n          !!allowDisabledFocus,\n        )\n      : getBaseButtonClassNames(\n          theme!,\n          styles!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          !!this.props.menuProps,\n          checked!,\n          !menuHidden,\n          this.props.split,\n        );\n\n    const { _ariaDescriptionId, _labelId, _descriptionId } = this;\n    // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n    const renderAsAnchor: boolean = !isPrimaryButtonDisabled && !!href;\n    const tag = renderAsAnchor ? 'a' : 'button';\n\n    const nativeProps = getNativeProps(\n      // eslint-disable-next-line deprecation/deprecation\n      assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props),\n      renderAsAnchor ? anchorProperties : buttonProperties,\n      [\n        'disabled', // let disabled buttons be focused and styled as disabled.\n      ],\n    );\n\n    // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n    const resolvedAriaLabel = ariaLabel || (nativeProps as any)['aria-label'];\n\n    // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of\n    // aria-describedby. Otherwise default to undefined so property does not appear in output.\n    let ariaDescribedBy = undefined;\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if ((nativeProps as any)['aria-describedby']) {\n      ariaDescribedBy = (nativeProps as any)['aria-describedby'];\n    }\n\n    // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute)\n    // and no ariaLabel is specified, set the labelledby element.\n    // Otherwise, the button is labeled implicitly by the descendent text on the button (if it exists).\n    let ariaLabelledBy = undefined;\n    if ((nativeProps as any)['aria-labelledby']) {\n      ariaLabelledBy = (nativeProps as any)['aria-labelledby'];\n    } else if (ariaDescribedBy && !resolvedAriaLabel) {\n      ariaLabelledBy = this._hasText() ? _labelId : undefined;\n    }\n\n    const dataIsFocusable =\n      (this.props as any)['data-is-focusable'] === false || (disabled && !allowDisabledFocus) || this._isSplitButton\n        ? false\n        : true;\n\n    const isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox';\n    // if isCheckboxTypeRole, always return a checked value.\n    // Otherwise only return checked value if toggle is set to true.\n    // This is because role=\"checkbox\" always needs to have an aria-checked value\n    // but our checked prop only sets aria-pressed if we mark the button as a toggle=\"true\"\n    const checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;\n\n    const buttonProps = assign(nativeProps, {\n      className: this._classNames.root,\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._buttonElement),\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable,\n      // aria-pressed attribute should only be present for toggle buttons\n      // aria-checked attribute should only be present for toggle buttons with checkbox type role\n      [isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed']: checkedOrPressedValue,\n    });\n\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      const { id = `${this._labelId}-menu` } = this.props.menuProps;\n      assign(buttonProps, {\n        'aria-expanded': !menuHidden,\n        'aria-controls': !menuHidden ? id : null,\n        'aria-haspopup': true,\n      });\n    }\n\n    return this._onRenderContent(tag, buttonProps);\n  }\n\n  public componentDidMount() {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the\n    // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,\n    // because React does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      if ('onpointerdown' in this._splitButtonContainer.current) {\n        this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n      }\n      if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {\n        this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);\n      }\n    }\n  }\n\n  public componentDidUpdate(prevProps: IBaseButtonProps, prevState: IBaseButtonState) {\n    // If Button's menu was closed, run onAfterMenuDismiss.\n    if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {\n      this.props.onAfterMenuDismiss();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public focus(): void {\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      setFocusVisibility(true);\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      setFocusVisibility(true);\n      this._buttonElement.current.focus();\n    }\n  }\n\n  public dismissMenu(): void {\n    this._dismissMenu();\n  }\n\n  public openMenu(shouldFocusOnContainer?: boolean, shouldFocusOnMount?: boolean): void {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  }\n\n  private _onRenderContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const props = this.props;\n    const Tag = tag;\n    const {\n      menuIconProps,\n      menuProps,\n      onRenderIcon = this._onRenderIcon,\n      onRenderAriaDescription = this._onRenderAriaDescription,\n      onRenderChildren = this._onRenderChildren,\n      // eslint-disable-next-line deprecation/deprecation\n      onRenderMenu = this._onRenderMenu,\n      onRenderMenuIcon = this._onRenderMenuIcon,\n      disabled,\n    } = props;\n    let { keytipProps } = props;\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const Button = (keytipAttributes?: any): JSX.Element => (\n      <Tag {...buttonProps} {...keytipAttributes}>\n        <span className={this._classNames.flexContainer} data-automationid=\"splitbuttonprimary\">\n          {onRenderIcon(props, this._onRenderIcon)}\n          {this._onRenderTextContents()}\n          {onRenderAriaDescription(props, this._onRenderAriaDescription)}\n          {onRenderChildren(props, this._onRenderChildren)}\n          {!this._isSplitButton &&\n            (menuProps || menuIconProps || this.props.onRenderMenuIcon) &&\n            onRenderMenuIcon(this.props, this._onRenderMenuIcon)}\n          {menuProps &&\n            !menuProps.doNotLayer &&\n            this._shouldRenderMenu() &&\n            onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)}\n        </span>\n      </Tag>\n    );\n\n    const Content = keytipProps ? (\n      // If we're making a split button, we won't put the keytip here\n      <KeytipData\n        keytipProps={!this._isSplitButton ? keytipProps : undefined}\n        ariaDescribedBy={(buttonProps as any)['aria-describedby']}\n        disabled={disabled}\n      >\n        {(keytipAttributes: any): JSX.Element => Button(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      Button()\n    );\n\n    if (menuProps && menuProps.doNotLayer) {\n      return (\n        <>\n          {Content}\n          {this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)}\n        </>\n      );\n    }\n\n    return (\n      <>\n        {Content}\n        <FocusRects />\n      </>\n    );\n  }\n\n  /**\n   * Method to help determine if the menu's component tree should\n   * be rendered. It takes into account whether the menu is expanded,\n   * whether it is a persisted menu and whether it has been shown to the user.\n   */\n  private _shouldRenderMenu() {\n    const { menuHidden } = this.state;\n    // eslint-disable-next-line deprecation/deprecation\n    const { persistMenu, renderPersistedMenuHiddenOnMount } = this.props;\n\n    if (!menuHidden) {\n      // Always should render a menu when it is expanded\n      return true;\n    } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {\n      // _renderedVisibleMenu ensures that the first rendering of\n      // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.\n      return true;\n    }\n\n    return false;\n  }\n\n  private _onRenderIcon = (\n    buttonProps?: IButtonProps,\n    defaultRender?: IRenderFunction<IButtonProps>,\n  ): JSX.Element | null => {\n    const { iconProps } = this.props;\n\n    if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n      const { className, imageProps, ...rest } = iconProps;\n\n      // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon\n      // do not have this prop.\n      if (iconProps.styles) {\n        return <Icon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n      if (iconProps.iconName) {\n        return <FontIcon className={css(this._classNames.icon, className)} {...rest} />;\n      }\n      if (imageProps) {\n        return <ImageIcon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n    }\n    return null;\n  };\n\n  private _onRenderTextContents = (): JSX.Element | (JSX.Element | null)[] => {\n    const {\n      text,\n      children,\n      // eslint-disable-next-line deprecation/deprecation\n      secondaryText = this.props.description,\n      onRenderText = this._onRenderText,\n      onRenderDescription = this._onRenderDescription,\n    } = this.props;\n\n    if (text || typeof children === 'string' || secondaryText) {\n      return (\n        <span className={this._classNames.textContainer}>\n          {onRenderText(this.props, this._onRenderText)}\n          {onRenderDescription(this.props, this._onRenderDescription)}\n        </span>\n      );\n    }\n    return [onRenderText(this.props, this._onRenderText), onRenderDescription(this.props, this._onRenderDescription)];\n  };\n\n  private _onRenderText = (): JSX.Element | null => {\n    let { text } = this.props;\n    const { children } = this.props;\n\n    // For backwards compat, we should continue to take in the text content from children.\n    if (text === undefined && typeof children === 'string') {\n      text = children;\n    }\n\n    if (this._hasText()) {\n      return (\n        <span key={this._labelId} className={this._classNames.label} id={this._labelId}>\n          {text}\n        </span>\n      );\n    }\n\n    return null;\n  };\n\n  private _hasText(): boolean {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText\n    // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.\n    // text to be undefined in order for props.children to be used as a fallback.\n    // Purely a code maintainability/reuse issue, but logged as Issue #4979.\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  }\n\n  private _onRenderChildren = (): JSX.Element | null => {\n    const { children } = this.props;\n\n    // If children is just a string, either it or the text will be rendered via onRenderLabel\n    // If children is another component, it will be rendered after text\n    if (typeof children === 'string') {\n      return null;\n    }\n\n    return children as any;\n  };\n\n  private _onRenderDescription = (props: IButtonProps) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { secondaryText = this.props.description } = props;\n\n    // ms-Button-description is only shown when the button type is compound.\n    // In other cases it will not be displayed.\n    return secondaryText ? (\n      <span key={this._descriptionId} className={this._classNames.description} id={this._descriptionId}>\n        {secondaryText}\n      </span>\n    ) : null;\n  };\n\n  private _onRenderAriaDescription = () => {\n    const { ariaDescription } = this.props;\n\n    // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n    // otherwise it will be assigned to descriptionSpan.\n    return ariaDescription ? (\n      <span className={this._classNames.screenReaderText} id={this._ariaDescriptionId}>\n        {ariaDescription}\n      </span>\n    ) : null;\n  };\n\n  private _onRenderMenuIcon = (props: IButtonProps): JSX.Element | null => {\n    const { menuIconProps } = this.props;\n\n    return <FontIcon iconName=\"ChevronDown\" {...menuIconProps} className={this._classNames.menuIcon} />;\n  };\n\n  private _getMenuProps(menuProps: IContextualMenuProps): IContextualMenuProps {\n    const { persistMenu } = this.props;\n    const { menuHidden } = this.state;\n\n    // the accessible menu label (accessible name) has a relationship to the button.\n    // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n    // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n    if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {\n      menuProps = { ...menuProps, labelElementId: this._labelId };\n    }\n\n    return {\n      id: this._labelId + '-menu',\n      directionalHint: DirectionalHint.bottomLeftEdge,\n      ...menuProps,\n      shouldFocusOnContainer: this._menuShouldFocusOnContainer,\n      shouldFocusOnMount: this._menuShouldFocusOnMount,\n      hidden: persistMenu ? menuHidden : undefined,\n      className: css('ms-BaseButton-menuhost', menuProps.className),\n      target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current,\n      onDismiss: this._onDismissMenu,\n    };\n  }\n\n  private _onRenderMenu = (menuProps: IContextualMenuProps): JSX.Element => {\n    const MenuType = this.props.menuAs ? composeComponentAs(this.props.menuAs, ContextualMenu) : ContextualMenu;\n\n    return <MenuType {...menuProps} />;\n  };\n\n  private _onDismissMenu: IContextualMenuProps['onDismiss'] = ev => {\n    const { menuProps } = this.props;\n\n    if (menuProps && menuProps.onDismiss) {\n      menuProps.onDismiss(ev);\n    }\n    if (!ev || !ev.defaultPrevented) {\n      this._dismissMenu();\n    }\n  };\n\n  private _dismissMenu = (): void => {\n    this._menuShouldFocusOnMount = undefined;\n    this._menuShouldFocusOnContainer = undefined;\n    this.setState({ menuHidden: true });\n  };\n\n  private _openMenu = (shouldFocusOnContainer?: boolean, shouldFocusOnMount: boolean = true): void => {\n    if (this.props.menuProps) {\n      this._menuShouldFocusOnContainer = shouldFocusOnContainer;\n      this._menuShouldFocusOnMount = shouldFocusOnMount;\n      this._renderedVisibleMenu = true;\n      this.setState({ menuHidden: false });\n    }\n  };\n\n  private _onToggleMenu = (shouldFocusOnContainer: boolean): void => {\n    let shouldFocusOnMount = true;\n    if (this.props.menuProps && this.props.menuProps.shouldFocusOnMount === false) {\n      shouldFocusOnMount = false;\n    }\n\n    this.state.menuHidden ? this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : this._dismissMenu();\n  };\n\n  private _onRenderSplitButtonContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const {\n      styles = {},\n      disabled,\n      allowDisabledFocus,\n      checked,\n      getSplitButtonClassNames,\n      primaryDisabled,\n      menuProps,\n      toggle,\n      role,\n      primaryActionButtonProps,\n    } = this.props;\n    let { keytipProps } = this.props;\n    const { menuHidden } = this.state;\n\n    const classNames = getSplitButtonClassNames\n      ? getSplitButtonClassNames(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus)\n      : styles && getBaseSplitButtonClassNames(styles!, !!disabled, !menuHidden, !!checked, !!primaryDisabled);\n\n    assign(buttonProps, {\n      onClick: undefined,\n      onPointerDown: undefined,\n      onPointerUp: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false,\n    });\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const containerProps = getNativeProps<React.HTMLAttributes<HTMLSpanElement>>(buttonProps, [], ['disabled']);\n\n    // Add additional props to apply on primary action button\n    if (primaryActionButtonProps) {\n      assign(buttonProps, primaryActionButtonProps);\n    }\n\n    const SplitButton = (keytipAttributes?: any): JSX.Element => (\n      <div\n        {...containerProps}\n        data-ktp-target={keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined}\n        role={role ? role : 'button'}\n        aria-disabled={disabled}\n        aria-haspopup={true}\n        aria-expanded={!menuHidden}\n        aria-pressed={toggle ? !!checked : undefined} // should only be present for toggle buttons\n        aria-describedby={mergeAriaAttributeValues(\n          buttonProps['aria-describedby'],\n          keytipAttributes ? keytipAttributes['aria-describedby'] : undefined,\n        )}\n        className={classNames && classNames.splitButtonContainer}\n        onKeyDown={this._onSplitButtonContainerKeyDown}\n        onTouchStart={this._onTouchStart}\n        ref={this._splitButtonContainer}\n        data-is-focusable={true}\n        onClick={!disabled && !primaryDisabled ? this._onSplitButtonPrimaryClick : undefined}\n        tabIndex={(!disabled && !primaryDisabled) || allowDisabledFocus ? 0 : undefined}\n        aria-roledescription={buttonProps['aria-roledescription']}\n        onFocusCapture={this._onSplitContainerFocusCapture}\n      >\n        <span style={{ display: 'flex' }}>\n          {this._onRenderContent(tag, buttonProps)}\n          {this._onRenderSplitButtonMenuButton(classNames, keytipAttributes)}\n          {this._onRenderSplitButtonDivider(classNames)}\n        </span>\n      </div>\n    );\n\n    return keytipProps ? (\n      <KeytipData keytipProps={keytipProps} disabled={disabled}>\n        {(keytipAttributes: any): JSX.Element => SplitButton(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      SplitButton()\n    );\n  }\n\n  private _onSplitContainerFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    const container = this._splitButtonContainer.current;\n\n    // If the target is coming from the portal we do not need to set focus on the container.\n    if (!container || (ev.target && portalContainsElement(ev.target, container))) {\n      return;\n    }\n\n    // We should never be able to focus the individual buttons in a split button. Focus\n    // should always remain on the container.\n    container.focus();\n  };\n\n  private _onSplitButtonPrimaryClick = (ev: React.MouseEvent<HTMLDivElement>) => {\n    if (!this.state.menuHidden) {\n      this._dismissMenu();\n    }\n\n    if (!this._processingTouch && this.props.onClick) {\n      this.props.onClick(ev);\n    } else if (this._processingTouch) {\n      this._onMenuClick(ev);\n    }\n  };\n\n  private _onRenderSplitButtonDivider(classNames: ISplitButtonClassNames | undefined): JSX.Element | null {\n    if (classNames && classNames.divider) {\n      const onClick = (ev: React.MouseEvent<HTMLSpanElement, MouseEvent>) => {\n        ev.stopPropagation();\n      };\n      return <span className={classNames.divider} aria-hidden={true} onClick={onClick} />;\n    }\n    return null;\n  }\n\n  private _onRenderSplitButtonMenuButton(\n    classNames: ISplitButtonClassNames | undefined,\n    keytipAttributes: any,\n  ): JSX.Element {\n    const {\n      allowDisabledFocus,\n      checked,\n      disabled,\n      splitButtonMenuProps,\n      splitButtonAriaLabel,\n      primaryDisabled,\n    } = this.props;\n    const { menuHidden } = this.state;\n    let menuIconProps = this.props.menuIconProps;\n\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown',\n      };\n    }\n\n    const splitButtonProps = {\n      ...splitButtonMenuProps,\n      styles: classNames,\n      checked: checked,\n      disabled: disabled,\n      allowDisabledFocus: allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: { ...menuIconProps, className: this._classNames.menuIcon },\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': !menuHidden,\n      'data-is-focusable': false,\n    };\n\n    // Add data-ktp-execute-target to the split button if the keytip is defined\n    return (\n      <BaseButton\n        {...splitButtonProps}\n        data-ktp-execute-target={keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes}\n        onMouseDown={this._onMouseDown}\n        tabIndex={primaryDisabled && !allowDisabledFocus ? 0 : -1}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    // explicity cancelling event so click won't fire after this\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    } else if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuKeyDown(ev);\n      } else if (this.props.onKeyDown !== undefined) {\n        this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onKeyUp = (\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onKeyUp !== undefined) {\n      this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onKeyPress = (\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onKeyPress !== undefined) {\n      this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseUp = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onMouseUp !== undefined) {\n      this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseDown = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onMouseDown !== undefined) {\n      this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onClick = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuClick(ev);\n      } else if (this.props.onClick !== undefined) {\n        this.props.onClick(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onSplitButtonContainerKeyDown = (ev: React.KeyboardEvent<HTMLDivElement>) => {\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n      if (this._buttonElement.current) {\n        this._buttonElement.current.click();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    } else {\n      this._onMenuKeyDown(ev);\n    }\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const isUp = ev.which === KeyCodes.up;\n    // eslint-disable-next-line deprecation/deprecation\n    const isDown = ev.which === KeyCodes.down;\n\n    if (!ev.defaultPrevented && this._isValidMenuOpenKey(ev)) {\n      const { onMenuClick } = this.props;\n      if (onMenuClick) {\n        onMenuClick(ev, this.props);\n      }\n\n      this._onToggleMenu(false);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n      // We manually set the focus visibility to true if opening via Enter or Space to account for the scenario where\n      // a user clicks on the button, closes the menu and then opens it via keyboard. In this scenario our default logic\n      // for setting focus visibility is not triggered since there is no keyboard navigation present beforehand.\n      setFocusVisibility(true, ev.target as Element);\n    }\n\n    if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n      // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items\n      // We need to re-render the menu with shouldFocusOnMount as true.\n\n      if (!this.state.menuHidden && this.props.menuProps) {\n        const currentShouldFocusOnMount =\n          this._menuShouldFocusOnMount !== undefined\n            ? this._menuShouldFocusOnMount\n            : this.props.menuProps.shouldFocusOnMount;\n        if (!currentShouldFocusOnMount) {\n          ev.preventDefault();\n          ev.stopPropagation();\n          this._menuShouldFocusOnMount = true;\n          this.forceUpdate();\n        }\n      }\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (\n      this._isSplitButton &&\n      this._splitButtonContainer.current &&\n      !('onpointerdown' in this._splitButtonContainer.current)\n    ) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown(\n    ev: PointerEvent &\n      React.PointerEvent<HTMLAnchorElement | HTMLButtonElement | HTMLDivElement | BaseButton | HTMLSpanElement>,\n  ) {\n    const { onPointerDown } = this.props;\n    if (onPointerDown) {\n      onPointerDown(ev);\n    }\n\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  }\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a new one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n\n      // Touch and pointer events don't focus the button naturally,\n      // so adding an imperative focus call to guarantee this behavior.\n      this.focus();\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n  private _isValidMenuOpenKey(\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>,\n  ): boolean {\n    if (this.props.menuTriggerKeyCode) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    }\n\n    // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n    return false;\n  }\n\n  private _onMenuClick = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLButtonElement | HTMLAnchorElement | HTMLSpanElement>,\n  ) => {\n    const { onMenuClick, menuProps } = this.props;\n    if (onMenuClick) {\n      onMenuClick(ev, this.props);\n    }\n\n    // focus on the container by default when the menu is opened with a click event\n    // this differentiates from a keyboard interaction triggering the click event\n    const shouldFocusOnContainer =\n      typeof menuProps?.shouldFocusOnContainer === 'boolean'\n        ? menuProps.shouldFocusOnContainer\n        : (ev.nativeEvent as PointerEvent).pointerType === 'mouse';\n\n    if (!ev.defaultPrevented) {\n      this._onToggleMenu(shouldFocusOnContainer);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}