{"ast":null,"code":"/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\nimport { getDocument } from './dom/getDocument';\n/** Tag names to ignore when modalizing */\n\nvar tagsToIgnore = ['TEMPLATE', 'STYLE', 'SCRIPT'];\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\n\nexport function modalize(target) {\n  var targetDocument = getDocument(target);\n\n  if (!targetDocument) {\n    // can't do this in SSR\n    return function () {\n      return undefined;\n    };\n  }\n\n  var affectedNodes = []; // start at target, then recurse and do the same for parent, until we reach <body>\n\n  while (target !== targetDocument.body && target.parentElement) {\n    // grab all siblings of current element\n    for (var _i = 0, _a = target.parentElement.children; _i < _a.length; _i++) {\n      var sibling = _a[_i]; // but ignore elements that are already aria-hidden\n\n      var ariaHidden = sibling.getAttribute('aria-hidden');\n\n      if (sibling !== target && (ariaHidden === null || ariaHidden === void 0 ? void 0 : ariaHidden.toLowerCase()) !== 'true' && tagsToIgnore.indexOf(sibling.tagName) === -1) {\n        affectedNodes.push([sibling, ariaHidden]);\n      }\n    }\n\n    target = target.parentElement;\n  } // take all those elements and set aria-hidden=true on them\n\n\n  affectedNodes.forEach(function (_a) {\n    var node = _a[0];\n    node.setAttribute('aria-hidden', 'true');\n  });\n  return function () {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n/**\n * Undoes the changes that modalize() did.\n */\n\nfunction unmodalize(affectedNodes) {\n  affectedNodes.forEach(function (_a) {\n    var node = _a[0],\n        originalValue = _a[1]; // Restore the original value (false or unset)\n\n    if (originalValue) {\n      node.setAttribute('aria-hidden', originalValue);\n    } else {\n      node.removeAttribute('aria-hidden');\n    }\n  });\n}","map":{"version":3,"sources":["modalize.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAEH,SAAS,WAAT,QAA4B,mBAA5B;AAEA;;AACA,IAAM,YAAY,GAAG,CAAC,UAAD,EAAa,OAAb,EAAsB,QAAtB,CAArB;AAEA;;;AAGG;;AACH,OAAM,SAAU,QAAV,CAAmB,MAAnB,EAAsC;EAC1C,IAAM,cAAc,GAAG,WAAW,CAAC,MAAD,CAAlC;;EACA,IAAI,CAAC,cAAL,EAAqB;IACnB;IACA,OAAO,YAAA;MAAM,OAAA,SAAA;IAAS,CAAtB;EACD;;EAED,IAAI,aAAa,GAAmC,EAApD,CAP0C,CAS1C;;EACA,OAAO,MAAM,KAAK,cAAc,CAAC,IAA1B,IAAkC,MAAM,CAAC,aAAhD,EAA+D;IAC7D;IACA,KAAsB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAC,MAAM,CAAC,aAAP,CAAqB,QAA5C,EAAsB,EAAA,GAAA,EAAA,CAAA,MAAtB,EAAsB,EAAA,EAAtB,EAAmF;MAA9E,IAAM,OAAO,GAAA,EAAA,CAAA,EAAA,CAAb,CAA8E,CACjF;;MACA,IAAM,UAAU,GAAG,OAAO,CAAC,YAAR,CAAqB,aAArB,CAAnB;;MACA,IAAI,OAAO,KAAK,MAAZ,IAAsB,CAAA,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,WAAZ,EAAA,MAA8B,MAApD,IAA8D,YAAY,CAAC,OAAb,CAAqB,OAAO,CAAC,OAA7B,MAA0C,CAAC,CAA7G,EAAgH;QAC9G,aAAa,CAAC,IAAd,CAAmB,CAAC,OAAD,EAAU,UAAV,CAAnB;MACD;IACF;;IAED,MAAM,GAAG,MAAM,CAAC,aAAhB;EACD,CArByC,CAuB1C;;;EACA,aAAa,CAAC,OAAd,CAAsB,UAAC,EAAD,EAAO;QAAL,IAAI,GAAA,EAAA,CAAA,CAAA,C;IAC1B,IAAI,CAAC,YAAL,CAAkB,aAAlB,EAAiC,MAAjC;EACD,CAFD;EAIA,OAAO,YAAA;IACL,UAAU,CAAC,aAAD,CAAV;IACA,aAAa,GAAG,EAAhB,CAFK,CAEe;EACrB,CAHD;AAID;AAED;;AAEG;;AACH,SAAS,UAAT,CAAoB,aAApB,EAAiE;EAC/D,aAAa,CAAC,OAAd,CAAsB,UAAC,EAAD,EAAsB;QAApB,IAAI,GAAA,EAAA,CAAA,CAAA,C;QAAE,aAAa,GAAA,EAAA,CAAA,CAAA,C,CAAC,CAC1C;;IACA,IAAI,aAAJ,EAAmB;MACjB,IAAI,CAAC,YAAL,CAAkB,aAAlB,EAAiC,aAAjC;IACD,CAFD,MAEO;MACL,IAAI,CAAC,eAAL,CAAqB,aAArB;IACD;EACF,CAPD;AAQD","sourcesContent":["/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\n\nimport { getDocument } from './dom/getDocument';\n\n/** Tag names to ignore when modalizing */\nconst tagsToIgnore = ['TEMPLATE', 'STYLE', 'SCRIPT'];\n\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\nexport function modalize(target: HTMLElement): () => void {\n  const targetDocument = getDocument(target);\n  if (!targetDocument) {\n    // can't do this in SSR\n    return () => undefined;\n  }\n\n  let affectedNodes: [HTMLElement, string | null][] = [];\n\n  // start at target, then recurse and do the same for parent, until we reach <body>\n  while (target !== targetDocument.body && target.parentElement) {\n    // grab all siblings of current element\n    for (const sibling of (target.parentElement.children as unknown) as HTMLElement[]) {\n      // but ignore elements that are already aria-hidden\n      const ariaHidden = sibling.getAttribute('aria-hidden');\n      if (sibling !== target && ariaHidden?.toLowerCase() !== 'true' && tagsToIgnore.indexOf(sibling.tagName) === -1) {\n        affectedNodes.push([sibling, ariaHidden]);\n      }\n    }\n\n    target = target.parentElement;\n  }\n\n  // take all those elements and set aria-hidden=true on them\n  affectedNodes.forEach(([node]) => {\n    node.setAttribute('aria-hidden', 'true');\n  });\n\n  return () => {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n\n/**\n * Undoes the changes that modalize() did.\n */\nfunction unmodalize(affectedNodes: [HTMLElement, string | null][]) {\n  affectedNodes.forEach(([node, originalValue]) => {\n    // Restore the original value (false or unset)\n    if (originalValue) {\n      node.setAttribute('aria-hidden', originalValue);\n    } else {\n      node.removeAttribute('aria-hidden');\n    }\n  });\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}