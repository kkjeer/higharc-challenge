{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { concatStyleSets } from '@fluentui/style-utilities';\nimport { Customizations, CustomizerContext } from '@fluentui/utilities';\nimport { createFactory } from './slots';\nimport { assign } from './utilities';\n/**\n * Assembles a higher order component based on the following: styles, theme, view, and state.\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call\n * the view prop.\n *\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n *\n * State component is optional. If state is not provided, created component is essentially a functional\n * stateless component.\n *\n * @param options - component Component options. See IComponentOptions for more detail.\n */\n\nexport function createComponent(view, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.factoryOptions,\n      factoryOptions = _a === void 0 ? {} : _a;\n  var defaultProp = factoryOptions.defaultProp;\n\n  var ResultComponent = function (componentProps) {\n    var settings = _getCustomizations(options.displayName, React.useContext(CustomizerContext), options.fields);\n\n    var stateReducer = options.state;\n\n    if (stateReducer) {\n      // Don't assume state will return all props, so spread useState result over component props.\n      componentProps = __assign(__assign({}, componentProps), stateReducer(componentProps));\n    }\n\n    var theme = componentProps.theme || settings.theme;\n\n    var tokens = _resolveTokens(componentProps, theme, options.tokens, settings.tokens, componentProps.tokens);\n\n    var styles = _resolveStyles(componentProps, theme, tokens, options.styles, settings.styles, componentProps.styles);\n\n    var viewProps = __assign(__assign({}, componentProps), {\n      styles: styles,\n      tokens: tokens,\n      _defaultStyles: styles,\n      theme: theme\n    });\n\n    return view(viewProps);\n  };\n\n  ResultComponent.displayName = options.displayName || view.name; // If a shorthand prop is defined, create a factory for the component.\n  // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\n  //       Need to weigh creating default factories on component creation vs. memoizing them on use in slots.tsx.\n\n  if (defaultProp) {\n    ResultComponent.create = createFactory(ResultComponent, {\n      defaultProp: defaultProp\n    });\n  }\n\n  assign(ResultComponent, options.statics); // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\n\n  return ResultComponent;\n}\n/**\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\n */\n\nfunction _resolveStyles(props, theme, tokens) {\n  var allStyles = [];\n\n  for (var _i = 3; _i < arguments.length; _i++) {\n    allStyles[_i - 3] = arguments[_i];\n  }\n\n  return concatStyleSets.apply(void 0, allStyles.map(function (styles) {\n    return typeof styles === 'function' ? styles(props, theme, tokens) : styles;\n  }));\n}\n/**\n * Resolve all tokens functions with props flatten results along with all tokens objects.\n */\n\n\nfunction _resolveTokens(props, theme) {\n  var allTokens = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    allTokens[_i - 2] = arguments[_i];\n  }\n\n  var tokens = {};\n\n  for (var _a = 0, allTokens_1 = allTokens; _a < allTokens_1.length; _a++) {\n    var currentTokens = allTokens_1[_a];\n\n    if (currentTokens) {\n      // TODO: why is this cast needed? TS seems to think there is a (TToken | Function) union from somewhere.\n      currentTokens = typeof currentTokens === 'function' ? currentTokens(props, theme) : currentTokens;\n\n      if (Array.isArray(currentTokens)) {\n        currentTokens = _resolveTokens.apply(void 0, __spreadArray([props, theme], currentTokens));\n      }\n\n      assign(tokens, currentTokens);\n    }\n  }\n\n  return tokens;\n}\n/**\n * Helper function for calling Customizations.getSettings falling back to default fields.\n *\n * @param displayName Displayable name for component.\n * @param context React context passed to component containing contextual settings.\n * @param fields Optional list of properties to grab from global store and context.\n */\n\n\nfunction _getCustomizations(displayName, context, fields) {\n  // TODO: do we want field props? should fields be part of IComponent and used here?\n  // TODO: should we centrally define DefaultFields? (not exported from styling)\n  // TODO: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\n  var DefaultFields = ['theme', 'styles', 'tokens'];\n  return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\n}","map":{"version":3,"sources":["createComponent.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { concatStyleSets, IStyleSet, ITheme } from '@fluentui/style-utilities';\nimport { Customizations, CustomizerContext, ICustomizerContext } from '@fluentui/utilities';\nimport { createFactory } from './slots';\nimport { assign } from './utilities';\n\nimport {\n  IComponentOptions,\n  ICustomizationProps,\n  IStyleableComponentProps,\n  IStylesFunctionOrObject,\n  IToken,\n  ITokenFunction,\n  IViewComponent,\n} from './IComponent';\nimport { IDefaultSlotProps, ISlotCreator, ValidProps } from './ISlots';\n\n/**\n * Assembles a higher order component based on the following: styles, theme, view, and state.\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call\n * the view prop.\n *\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n *\n * State component is optional. If state is not provided, created component is essentially a functional\n * stateless component.\n *\n * @param options - component Component options. See IComponentOptions for more detail.\n */\nexport function createComponent<\n  TComponentProps extends ValidProps,\n  TTokens,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TViewProps extends TComponentProps = TComponentProps,\n  TStatics = {}\n>(\n  view: IViewComponent<TViewProps>,\n  options: IComponentOptions<TComponentProps, TTokens, TStyleSet, TViewProps, TStatics> = {},\n): React.FunctionComponent<TComponentProps> & TStatics {\n  const { factoryOptions = {} } = options;\n  const { defaultProp } = factoryOptions;\n\n  const ResultComponent: React.FunctionComponent<TComponentProps> = (\n    componentProps: TComponentProps & IStyleableComponentProps<TViewProps, TTokens, TStyleSet>,\n  ) => {\n    const settings: ICustomizationProps<TViewProps, TTokens, TStyleSet> = _getCustomizations(\n      options.displayName,\n      React.useContext(CustomizerContext),\n      options.fields,\n    );\n\n    const stateReducer = options.state;\n\n    if (stateReducer) {\n      // Don't assume state will return all props, so spread useState result over component props.\n      componentProps = {\n        ...componentProps,\n        ...stateReducer(componentProps),\n      };\n    }\n\n    const theme = componentProps.theme || settings.theme;\n\n    const tokens = _resolveTokens(componentProps, theme, options.tokens, settings.tokens, componentProps.tokens);\n    const styles = _resolveStyles(\n      componentProps,\n      theme,\n      tokens,\n      options.styles,\n      settings.styles,\n      componentProps.styles,\n    );\n\n    const viewProps = ({\n      ...componentProps,\n      styles,\n      tokens,\n      _defaultStyles: styles,\n      theme,\n    } as unknown) as TViewProps & IDefaultSlotProps<any>;\n\n    return view(viewProps);\n  };\n\n  ResultComponent.displayName = options.displayName || view.name;\n\n  // If a shorthand prop is defined, create a factory for the component.\n  // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\n  //       Need to weigh creating default factories on component creation vs. memoizing them on use in slots.tsx.\n  if (defaultProp) {\n    (ResultComponent as ISlotCreator<TComponentProps, any>).create = createFactory(ResultComponent, { defaultProp });\n  }\n\n  assign(ResultComponent, options.statics);\n\n  // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\n  return ResultComponent as React.FunctionComponent<TComponentProps> & TStatics;\n}\n\n/**\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\n */\nfunction _resolveStyles<TProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  props: TProps,\n  theme: ITheme,\n  tokens: TTokens,\n  ...allStyles: (IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined)[]\n): ReturnType<typeof concatStyleSets> {\n  return concatStyleSets(\n    ...allStyles.map((styles: IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined) =>\n      typeof styles === 'function' ? styles(props, theme, tokens) : styles,\n    ),\n  );\n}\n\n/**\n * Resolve all tokens functions with props flatten results along with all tokens objects.\n */\nfunction _resolveTokens<TViewProps, TTokens>(\n  props: TViewProps,\n  theme: ITheme,\n  ...allTokens: (IToken<TViewProps, TTokens> | false | null | undefined)[]\n): TTokens {\n  const tokens = {};\n\n  for (let currentTokens of allTokens) {\n    if (currentTokens) {\n      // TODO: why is this cast needed? TS seems to think there is a (TToken | Function) union from somewhere.\n      currentTokens =\n        typeof currentTokens === 'function'\n          ? (currentTokens as ITokenFunction<TViewProps, TTokens>)(props, theme)\n          : currentTokens;\n\n      if (Array.isArray(currentTokens)) {\n        currentTokens = _resolveTokens(props, theme, ...currentTokens);\n      }\n\n      assign(tokens, currentTokens);\n    }\n  }\n\n  return tokens as TTokens;\n}\n\n/**\n * Helper function for calling Customizations.getSettings falling back to default fields.\n *\n * @param displayName Displayable name for component.\n * @param context React context passed to component containing contextual settings.\n * @param fields Optional list of properties to grab from global store and context.\n */\nfunction _getCustomizations<TViewProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  displayName: string | undefined,\n  context: ICustomizerContext,\n  fields?: string[],\n): ICustomizationProps<TViewProps, TTokens, TStyleSet> {\n  // TODO: do we want field props? should fields be part of IComponent and used here?\n  // TODO: should we centrally define DefaultFields? (not exported from styling)\n  // TODO: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\n  const DefaultFields = ['theme', 'styles', 'tokens'];\n  return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}