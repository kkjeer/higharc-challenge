{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { KeyCodes, calculatePrecision, classNamesFunction, precisionRound, getNativeProps, getPropsWithDefaults, divProperties } from '../../Utilities';\nimport { getArrowButtonStyles } from './SpinButton.styles';\nimport { KeyboardSpinDirection } from './SpinButton.types';\nimport { Position } from '../../Positioning';\nimport { useAsync, useControllableValue, useWarnings, useId, usePrevious } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SpinButton';\nvar DEFAULT_PROPS = {\n  disabled: false,\n  label: '',\n  step: 1,\n  labelPosition: Position.start,\n  incrementButtonIcon: {\n    iconName: 'ChevronUpSmall'\n  },\n  decrementButtonIcon: {\n    iconName: 'ChevronDownSmall'\n  }\n};\nvar INITIAL_STEP_DELAY = 400;\nvar STEP_DELAY = 75;\n\nvar useComponentRef = function (props, input, value) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      get value() {\n        return value;\n      },\n\n      focus: function () {\n        if (input.current) {\n          input.current.focus();\n        }\n      }\n    };\n  }, [input, value]);\n};\n\nvar noOp = function () {\n  /**\n   * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n   * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n   * The no-op onChange handler was still needed because React gives console errors if an input\n   * doesn't have onChange.\n   *\n   * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n   * ours or 3rd-party, which simulate entering text in a SpinButton)\n   */\n};\n/** Clamp the value to the provided min and/or max */\n\n\nvar clampValue = function (value, _a) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (typeof max === 'number') {\n    value = Math.min(value, max);\n  }\n\n  if (typeof min === 'number') {\n    value = Math.max(value, min);\n  }\n\n  return value;\n};\n\nexport var SpinButtonBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var disabled = props.disabled,\n      label = props.label,\n      min = props.min,\n      max = props.max,\n      step = props.step,\n      defaultValue = props.defaultValue,\n      valueFromProps = props.value,\n      precisionFromProps = props.precision,\n      labelPosition = props.labelPosition,\n      iconProps = props.iconProps,\n      incrementButtonIcon = props.incrementButtonIcon,\n      incrementButtonAriaLabel = props.incrementButtonAriaLabel,\n      decrementButtonIcon = props.decrementButtonIcon,\n      decrementButtonAriaLabel = props.decrementButtonAriaLabel,\n      ariaLabel = props.ariaLabel,\n      ariaDescribedBy = props.ariaDescribedBy,\n      customUpArrowButtonStyles = props.upArrowButtonStyles,\n      customDownArrowButtonStyles = props.downArrowButtonStyles,\n      theme = props.theme,\n      ariaPositionInSet = props.ariaPositionInSet,\n      ariaSetSize = props.ariaSetSize,\n      ariaValueNow = props.ariaValueNow,\n      ariaValueText = props.ariaValueText,\n      className = props.className,\n      inputProps = props.inputProps,\n      onDecrement = props.onDecrement,\n      onIncrement = props.onIncrement,\n      iconButtonProps = props.iconButtonProps,\n      onValidate = props.onValidate,\n      onChange = props.onChange,\n      styles = props.styles;\n  var input = React.useRef(null);\n  var inputId = useId('input');\n  var labelId = useId('Label');\n\n  var _a = React.useState(false),\n      isFocused = _a[0],\n      setIsFocused = _a[1];\n\n  var _b = React.useState(KeyboardSpinDirection.notSpinning),\n      keyboardSpinDirection = _b[0],\n      setKeyboardSpinDirection = _b[1];\n\n  var async = useAsync();\n  var precision = React.useMemo(function () {\n    return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(calculatePrecision(step), 0);\n  }, [precisionFromProps, step]);\n  /**\n   * Actual current value. If `props.value` is provided (controlled), it will always be used.\n   * If not (uncontrolled), this tracks the current value based on user modifications.\n   * Note that while the user is editing text in the field, this will not be updated until \"commit\"\n   * (blur or press enter).\n   */\n\n  var _c = useControllableValue(valueFromProps, defaultValue !== null && defaultValue !== void 0 ? defaultValue : String(min || 0), onChange),\n      value = _c[0],\n      setValue = _c[1];\n  /**\n   * \"Uncommitted\" internal value while the user is editing text in the field. This lets us wait to\n   * call `onChange` (and possibly update the real value) until the user \"commits\" the value by\n   * pressing enter or blurring the field.\n   */\n\n\n  var _d = React.useState(),\n      intermediateValue = _d[0],\n      setIntermediateValue = _d[1];\n\n  var internalState = React.useRef({\n    stepTimeoutHandle: -1,\n    latestValue: undefined,\n    latestIntermediateValue: undefined\n  }).current; // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n\n  internalState.latestValue = value;\n  internalState.latestIntermediateValue = intermediateValue;\n  var previousValueFromProps = usePrevious(valueFromProps);\n  React.useEffect(function () {\n    // If props.value changes while editing, clear the intermediate value\n    if (valueFromProps !== previousValueFromProps && intermediateValue !== undefined) {\n      setIntermediateValue(undefined);\n    }\n  }, [valueFromProps, previousValueFromProps, intermediateValue]);\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    disabled: disabled,\n    isFocused: isFocused,\n    keyboardSpinDirection: keyboardSpinDirection,\n    labelPosition: labelPosition,\n    className: className\n  });\n  var nativeProps = getNativeProps(props, divProperties, ['onBlur', 'onFocus', 'className', 'onChange']);\n  /** Validate (commit) function called on blur or enter keypress. */\n\n  var validate = React.useCallback(function (ev) {\n    // Only run validation if the value changed\n    var enteredValue = internalState.latestIntermediateValue;\n\n    if (enteredValue !== undefined && enteredValue !== internalState.latestValue) {\n      var newValue = void 0;\n\n      if (onValidate) {\n        newValue = onValidate(enteredValue, ev);\n      } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {\n        // default validation handling\n        newValue = String(clampValue(Number(enteredValue), {\n          min: min,\n          max: max\n        }));\n      }\n\n      if (newValue !== undefined && newValue !== internalState.latestValue) {\n        // Commit the value if it changed\n        setValue(newValue, ev);\n      }\n    } // Done validating, so clear the intermediate typed value (if any)\n\n\n    setIntermediateValue(undefined);\n  }, [internalState, max, min, onValidate, setValue]);\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n\n  var stop = React.useCallback(function () {\n    if (internalState.stepTimeoutHandle >= 0) {\n      async.clearTimeout(internalState.stepTimeoutHandle);\n      internalState.stepTimeoutHandle = -1;\n    }\n\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      internalState.spinningByMouse = false;\n      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);\n    }\n  }, [internalState, keyboardSpinDirection, async]);\n  /**\n   * Update the value with the given stepFunction.\n   * Also starts spinning for mousedown events by scheduling another update with setTimeout.\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n\n  var updateValue = React.useCallback(function (stepFunction, ev) {\n    ev.persist();\n\n    if (internalState.latestIntermediateValue !== undefined) {\n      // Edge case: if intermediateValue is set, this means that the user was editing the input\n      // text and then started spinning (either with mouse or keyboard). We need to validate and\n      // call onChange before starting to spin.\n      if (ev.type === 'keydown') {\n        // For the arrow keys, we have to manually trigger validation.\n        // (For the buttons, validation will happen automatically since the input's onBlur will\n        // be triggered after mousedown on the button completes.)\n        validate(ev);\n      }\n\n      async.requestAnimationFrame(function () {\n        // After handling any value updates, do the spinning update\n        updateValue(stepFunction, ev);\n      });\n      return;\n    } // Call the step function and update the value.\n    // (Note: we access the latest value via internalState (not directly) to ensure we don't use\n    // a stale captured value. This is mainly important for spinning by mouse, where we trigger\n    // additional calls to the original updateValue function via setTimeout. It also lets us\n    // avoid useCallback deps on frequently changing values.)\n\n\n    var newValue = stepFunction(internalState.latestValue || '', ev);\n\n    if (newValue !== undefined && newValue !== internalState.latestValue) {\n      setValue(newValue, ev);\n    } // Schedule the next spin if applicable\n    // (will be canceled if there's a mouseup before the timeout runs)\n\n\n    var wasSpinning = internalState.spinningByMouse;\n    internalState.spinningByMouse = ev.type === 'mousedown';\n\n    if (internalState.spinningByMouse) {\n      internalState.stepTimeoutHandle = async.setTimeout(function () {\n        updateValue(stepFunction, ev);\n      }, wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY);\n    }\n  }, [internalState, async, validate, setValue]);\n  /** Composed increment handler (uses `props.onIncrement` or default) */\n\n  var handleIncrement = React.useCallback(function (newValue) {\n    if (onIncrement) {\n      return onIncrement(newValue);\n    } else {\n      var numericValue = clampValue(Number(newValue) + Number(step), {\n        max: max\n      });\n      numericValue = precisionRound(numericValue, precision);\n      return String(numericValue);\n    }\n  }, [precision, max, onIncrement, step]);\n  /** Composed decrement handler (uses `props.onDecrement` or default) */\n\n  var handleDecrement = React.useCallback(function (newValue) {\n    if (onDecrement) {\n      return onDecrement(newValue);\n    } else {\n      var numericValue = clampValue(Number(newValue) - Number(step), {\n        min: min\n      });\n      numericValue = precisionRound(numericValue, precision);\n      return String(numericValue);\n    }\n  }, [precision, min, onDecrement, step]);\n  /** Handles when the user types in the input */\n\n  var handleInputChange = function (ev) {\n    setIntermediateValue(ev.target.value);\n  };\n  /** Composed focus handler (does internal stuff and calls `props.onFocus`) */\n\n\n  var handleFocus = function (ev) {\n    var _a; // We can't set focus on a non-existing element\n\n\n    if (!input.current) {\n      return;\n    }\n\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      stop();\n    }\n\n    input.current.select();\n    setIsFocused(true);\n    (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n  };\n  /** Composed blur handler (does internal stuff and calls `props.onBlur`) */\n\n\n  var handleBlur = function (ev) {\n    var _a;\n\n    validate(ev);\n    setIsFocused(false);\n    (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n  };\n  /** Update value when arrow keys are pressed, commit on enter, or revert on escape */\n\n\n  var handleKeyDown = function (ev) {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    if (disabled) {\n      stop();\n      return;\n    }\n\n    var spinDirection = KeyboardSpinDirection.notSpinning; // eslint-disable-next-line deprecation/deprecation\n\n    switch (ev.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        updateValue(handleIncrement, ev);\n        break;\n\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        updateValue(handleDecrement, ev);\n        break;\n\n      case KeyCodes.enter:\n        // Commit the edited value\n        validate(ev);\n        break;\n\n      case KeyCodes.escape:\n        // Revert to previous value\n        setIntermediateValue(undefined);\n        break;\n    } // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n\n\n    if (keyboardSpinDirection !== spinDirection) {\n      setKeyboardSpinDirection(spinDirection);\n    }\n  };\n  /** Stop spinning on keyUp if the up or down arrow key fired this event */\n\n\n  var handleKeyUp = React.useCallback(function (ev) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {\n      stop();\n      return;\n    }\n  }, [disabled, stop]);\n  var handleIncrementMouseDown = React.useCallback(function (ev) {\n    updateValue(handleIncrement, ev);\n  }, [handleIncrement, updateValue]);\n  var handleDecrementMouseDown = React.useCallback(function (ev) {\n    updateValue(handleDecrement, ev);\n  }, [handleDecrement, updateValue]);\n  useComponentRef(props, input, value);\n  useDebugWarnings(props);\n  var valueIsNumber = !!value && !isNaN(Number(value)); // Number('') is 0 which may not be desirable\n\n  var labelContent = (iconProps || label) && React.createElement(\"div\", {\n    className: classNames.labelWrapper\n  }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n    className: classNames.icon,\n    \"aria-hidden\": \"true\"\n  })), label && React.createElement(Label, {\n    id: labelId,\n    htmlFor: inputId,\n    className: classNames.label,\n    disabled: disabled\n  }, label));\n  return React.createElement(\"div\", {\n    className: classNames.root,\n    ref: ref\n  }, labelPosition !== Position.bottom && labelContent, React.createElement(\"div\", __assign({}, nativeProps, {\n    className: classNames.spinButtonWrapper,\n    \"aria-label\": ariaLabel && ariaLabel,\n    \"aria-posinset\": ariaPositionInSet,\n    \"aria-setsize\": ariaSetSize,\n    \"data-ktp-target\": true\n  }), React.createElement(\"input\", __assign({\n    // Display intermediateValue while editing the text (before commit)\n    value: intermediateValue !== null && intermediateValue !== void 0 ? intermediateValue : value,\n    id: inputId,\n    onChange: noOp,\n    onInput: handleInputChange,\n    className: classNames.input,\n    type: \"text\",\n    autoComplete: \"off\",\n    role: \"spinbutton\",\n    \"aria-labelledby\": label && labelId,\n    \"aria-valuenow\": ariaValueNow !== null && ariaValueNow !== void 0 ? ariaValueNow : valueIsNumber ? Number(value) : undefined,\n    \"aria-valuetext\": ariaValueText !== null && ariaValueText !== void 0 ? ariaValueText : valueIsNumber ? undefined : value,\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-describedby\": ariaDescribedBy,\n    onBlur: handleBlur,\n    ref: input,\n    onFocus: handleFocus,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    disabled: disabled,\n    \"aria-disabled\": disabled,\n    \"data-lpignore\": true,\n    \"data-ktp-execute-target\": true\n  }, inputProps)), React.createElement(\"span\", {\n    className: classNames.arrowButtonsContainer\n  }, React.createElement(IconButton, __assign({\n    styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n    className: 'ms-UpButton',\n    checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n    disabled: disabled,\n    iconProps: incrementButtonIcon,\n    onMouseDown: handleIncrementMouseDown,\n    onMouseLeave: stop,\n    onMouseUp: stop,\n    tabIndex: -1,\n    ariaLabel: incrementButtonAriaLabel,\n    \"data-is-focusable\": false\n  }, iconButtonProps)), React.createElement(IconButton, __assign({\n    styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n    className: 'ms-DownButton',\n    checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n    disabled: disabled,\n    iconProps: decrementButtonIcon,\n    onMouseDown: handleDecrementMouseDown,\n    onMouseLeave: stop,\n    onMouseUp: stop,\n    tabIndex: -1,\n    ariaLabel: decrementButtonAriaLabel,\n    \"data-is-focusable\": false\n  }, iconButtonProps)))), labelPosition === Position.bottom && labelContent);\n});\nSpinButtonBase.displayName = COMPONENT_NAME;\n\nvar useDebugWarnings = function (props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      mutuallyExclusive: {\n        value: 'defaultValue'\n      }\n    });\n  }\n};","map":{"version":3,"sources":["components/SpinButton/SpinButton.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  KeyCodes,\n  calculatePrecision,\n  classNamesFunction,\n  precisionRound,\n  getNativeProps,\n  getPropsWithDefaults,\n  divProperties,\n} from '../../Utilities';\nimport { getArrowButtonStyles } from './SpinButton.styles';\nimport { KeyboardSpinDirection } from './SpinButton.types';\nimport { Position } from '../../Positioning';\nimport { useAsync, useControllableValue, useWarnings, useId, usePrevious } from '@fluentui/react-hooks';\nimport type { ISpinButtonProps, ISpinButtonStyleProps, ISpinButtonStyles } from './SpinButton.types';\n\ninterface ISpinButtonInternalState {\n  spinningByMouse?: boolean;\n  stepTimeoutHandle: number;\n  /** Allows access to the latest `value` inside reused callbacks (to avoid stale capture issues) */\n  latestValue: string | undefined;\n  /** Allows access to the latest `intermediateValue` inside reused callbacks (to avoid stale capture issues) */\n  latestIntermediateValue: string | undefined;\n}\n\nconst getClassNames = classNamesFunction<ISpinButtonStyleProps, ISpinButtonStyles>();\n\nconst COMPONENT_NAME = 'SpinButton';\nconst DEFAULT_PROPS: Required<\n  Pick<\n    ISpinButtonProps,\n    // These are explicitly specified so that only the things which actually have defaults\n    // get marked as required in ISpinButtonPropsWithDefaults below\n    'disabled' | 'label' | 'step' | 'labelPosition' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n> = {\n  disabled: false,\n  label: '',\n  step: 1,\n  labelPosition: Position.start,\n  incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n  decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n};\ntype ISpinButtonPropsWithDefaults = ISpinButtonProps & typeof DEFAULT_PROPS;\n\nconst INITIAL_STEP_DELAY = 400;\nconst STEP_DELAY = 75;\n\nconst useComponentRef = (\n  props: ISpinButtonProps,\n  input: React.RefObject<HTMLDivElement>,\n  value: string | undefined,\n) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      get value() {\n        return value;\n      },\n      focus() {\n        if (input.current) {\n          input.current.focus();\n        }\n      },\n    }),\n    [input, value],\n  );\n};\n\nconst noOp = (): void => {\n  /**\n   * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n   * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n   * The no-op onChange handler was still needed because React gives console errors if an input\n   * doesn't have onChange.\n   *\n   * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n   * ours or 3rd-party, which simulate entering text in a SpinButton)\n   */\n};\n\n/** Clamp the value to the provided min and/or max */\nconst clampValue = (value: number, { min, max }: { max?: number; min?: number }) => {\n  if (typeof max === 'number') {\n    value = Math.min(value, max);\n  }\n  if (typeof min === 'number') {\n    value = Math.max(value, min);\n  }\n  return value;\n};\n\nexport const SpinButtonBase: React.FunctionComponent<ISpinButtonProps> = React.forwardRef<\n  HTMLDivElement,\n  ISpinButtonProps\n>((propsWithoutDefaults, ref) => {\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults) as ISpinButtonPropsWithDefaults;\n  const {\n    disabled,\n    label,\n    min,\n    max,\n    step,\n    defaultValue,\n    value: valueFromProps,\n    precision: precisionFromProps,\n    labelPosition,\n    iconProps,\n    incrementButtonIcon,\n    incrementButtonAriaLabel,\n    decrementButtonIcon,\n    decrementButtonAriaLabel,\n    ariaLabel,\n    ariaDescribedBy,\n    upArrowButtonStyles: customUpArrowButtonStyles,\n    downArrowButtonStyles: customDownArrowButtonStyles,\n    theme,\n    ariaPositionInSet,\n    ariaSetSize,\n    ariaValueNow,\n    ariaValueText,\n    className,\n    inputProps,\n    onDecrement,\n    onIncrement,\n    iconButtonProps,\n    onValidate,\n    onChange,\n    styles,\n  } = props;\n\n  const input = React.useRef<HTMLInputElement>(null);\n  const inputId = useId('input');\n  const labelId = useId('Label');\n\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [keyboardSpinDirection, setKeyboardSpinDirection] = React.useState(KeyboardSpinDirection.notSpinning);\n  const async = useAsync();\n\n  const precision = React.useMemo(() => {\n    return precisionFromProps ?? Math.max(calculatePrecision(step), 0);\n  }, [precisionFromProps, step]);\n\n  /**\n   * Actual current value. If `props.value` is provided (controlled), it will always be used.\n   * If not (uncontrolled), this tracks the current value based on user modifications.\n   * Note that while the user is editing text in the field, this will not be updated until \"commit\"\n   * (blur or press enter).\n   */\n  const [value, setValue] = useControllableValue(valueFromProps, defaultValue ?? String(min || 0), onChange);\n  /**\n   * \"Uncommitted\" internal value while the user is editing text in the field. This lets us wait to\n   * call `onChange` (and possibly update the real value) until the user \"commits\" the value by\n   * pressing enter or blurring the field.\n   */\n  const [intermediateValue, setIntermediateValue] = React.useState<string>();\n\n  const { current: internalState } = React.useRef<ISpinButtonInternalState>({\n    stepTimeoutHandle: -1,\n    latestValue: undefined,\n    latestIntermediateValue: undefined,\n  });\n  // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n  internalState.latestValue = value;\n  internalState.latestIntermediateValue = intermediateValue;\n\n  const previousValueFromProps = usePrevious(valueFromProps);\n  React.useEffect(() => {\n    // If props.value changes while editing, clear the intermediate value\n    if (valueFromProps !== previousValueFromProps && intermediateValue !== undefined) {\n      setIntermediateValue(undefined);\n    }\n  }, [valueFromProps, previousValueFromProps, intermediateValue]);\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    disabled,\n    isFocused,\n    keyboardSpinDirection,\n    labelPosition,\n    className,\n  });\n\n  const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties, [\n    'onBlur',\n    'onFocus',\n    'className',\n    'onChange',\n  ]);\n\n  /** Validate (commit) function called on blur or enter keypress. */\n  const validate = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLElement>): void => {\n      // Only run validation if the value changed\n      const enteredValue = internalState.latestIntermediateValue;\n      if (enteredValue !== undefined && enteredValue !== internalState.latestValue) {\n        let newValue: string | undefined;\n        if (onValidate) {\n          newValue = onValidate(enteredValue, ev) as string | undefined;\n        } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {\n          // default validation handling\n          newValue = String(clampValue(Number(enteredValue), { min, max }));\n        }\n        if (newValue !== undefined && newValue !== internalState.latestValue) {\n          // Commit the value if it changed\n          setValue(newValue, ev);\n        }\n      }\n\n      // Done validating, so clear the intermediate typed value (if any)\n      setIntermediateValue(undefined);\n    },\n    [internalState, max, min, onValidate, setValue],\n  );\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  const stop = React.useCallback((): void => {\n    if (internalState.stepTimeoutHandle >= 0) {\n      async.clearTimeout(internalState.stepTimeoutHandle);\n      internalState.stepTimeoutHandle = -1;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      internalState.spinningByMouse = false;\n      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);\n    }\n  }, [internalState, keyboardSpinDirection, async]);\n\n  /**\n   * Update the value with the given stepFunction.\n   * Also starts spinning for mousedown events by scheduling another update with setTimeout.\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  const updateValue = React.useCallback(\n    (\n      stepFunction: Required<ISpinButtonProps>['onIncrement'],\n      ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLInputElement>,\n    ): void => {\n      ev.persist();\n\n      if (internalState.latestIntermediateValue !== undefined) {\n        // Edge case: if intermediateValue is set, this means that the user was editing the input\n        // text and then started spinning (either with mouse or keyboard). We need to validate and\n        // call onChange before starting to spin.\n        if (ev.type === 'keydown') {\n          // For the arrow keys, we have to manually trigger validation.\n          // (For the buttons, validation will happen automatically since the input's onBlur will\n          // be triggered after mousedown on the button completes.)\n          validate(ev);\n        }\n        async.requestAnimationFrame(() => {\n          // After handling any value updates, do the spinning update\n          updateValue(stepFunction, ev);\n        });\n        return;\n      }\n\n      // Call the step function and update the value.\n      // (Note: we access the latest value via internalState (not directly) to ensure we don't use\n      // a stale captured value. This is mainly important for spinning by mouse, where we trigger\n      // additional calls to the original updateValue function via setTimeout. It also lets us\n      // avoid useCallback deps on frequently changing values.)\n      const newValue = stepFunction(internalState.latestValue || '', ev) as string | undefined;\n      if (newValue !== undefined && newValue !== internalState.latestValue) {\n        setValue(newValue, ev);\n      }\n\n      // Schedule the next spin if applicable\n      // (will be canceled if there's a mouseup before the timeout runs)\n      const wasSpinning = internalState.spinningByMouse;\n      internalState.spinningByMouse = ev.type === 'mousedown';\n      if (internalState.spinningByMouse) {\n        internalState.stepTimeoutHandle = async.setTimeout(\n          () => {\n            updateValue(stepFunction, ev);\n          },\n          wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY, // the first step is slower\n        );\n      }\n    },\n    [internalState, async, validate, setValue],\n  );\n\n  /** Composed increment handler (uses `props.onIncrement` or default) */\n  const handleIncrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onIncrement) {\n        return onIncrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) + Number(step), { max });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, max, onIncrement, step],\n  );\n\n  /** Composed decrement handler (uses `props.onDecrement` or default) */\n  const handleDecrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onDecrement) {\n        return onDecrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) - Number(step), { min });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, min, onDecrement, step],\n  );\n\n  /** Handles when the user types in the input */\n  const handleInputChange = (ev: React.FormEvent<HTMLInputElement>): void => {\n    setIntermediateValue((ev.target as HTMLInputElement).value);\n  };\n\n  /** Composed focus handler (does internal stuff and calls `props.onFocus`) */\n  const handleFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!input.current) {\n      return;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      stop();\n    }\n    input.current.select();\n    setIsFocused(true);\n    props.onFocus?.(ev);\n  };\n\n  /** Composed blur handler (does internal stuff and calls `props.onBlur`) */\n  const handleBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    validate(ev);\n    setIsFocused(false);\n    props.onBlur?.(ev);\n  };\n\n  /** Update value when arrow keys are pressed, commit on enter, or revert on escape */\n  const handleKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    if (disabled) {\n      stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        updateValue(handleIncrement, ev);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        updateValue(handleDecrement, ev);\n        break;\n      case KeyCodes.enter:\n        // Commit the edited value\n        validate(ev);\n        break;\n      case KeyCodes.escape:\n        // Revert to previous value\n        setIntermediateValue(undefined);\n        break;\n    }\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (keyboardSpinDirection !== spinDirection) {\n      setKeyboardSpinDirection(spinDirection);\n    }\n  };\n\n  /** Stop spinning on keyUp if the up or down arrow key fired this event */\n  const handleKeyUp = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLElement>): void => {\n      // eslint-disable-next-line deprecation/deprecation\n      if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {\n        stop();\n        return;\n      }\n    },\n    [disabled, stop],\n  );\n\n  const handleIncrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleIncrement, ev);\n    },\n    [handleIncrement, updateValue],\n  );\n\n  const handleDecrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleDecrement, ev);\n    },\n    [handleDecrement, updateValue],\n  );\n\n  useComponentRef(props, input, value);\n  useDebugWarnings(props);\n\n  const valueIsNumber = !!value && !isNaN(Number(value)); // Number('') is 0 which may not be desirable\n\n  const labelContent = (iconProps || label) && (\n    <div className={classNames.labelWrapper}>\n      {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n      {label && (\n        <Label id={labelId} htmlFor={inputId} className={classNames.label} disabled={disabled}>\n          {label}\n        </Label>\n      )}\n    </div>\n  );\n\n  return (\n    <div className={classNames.root} ref={ref}>\n      {labelPosition !== Position.bottom && labelContent}\n      <div\n        {...nativeProps}\n        className={classNames.spinButtonWrapper}\n        aria-label={ariaLabel && ariaLabel}\n        aria-posinset={ariaPositionInSet}\n        aria-setsize={ariaSetSize}\n        data-ktp-target={true}\n      >\n        <input\n          // Display intermediateValue while editing the text (before commit)\n          value={intermediateValue ?? value}\n          id={inputId}\n          onChange={noOp}\n          onInput={handleInputChange}\n          className={classNames.input}\n          type=\"text\"\n          autoComplete=\"off\"\n          role=\"spinbutton\"\n          aria-labelledby={label && labelId}\n          // TODO: test what happens while editing\n          aria-valuenow={ariaValueNow ?? (valueIsNumber ? Number(value) : undefined)}\n          aria-valuetext={ariaValueText ?? (valueIsNumber ? undefined : value)}\n          aria-valuemin={min}\n          aria-valuemax={max}\n          aria-describedby={ariaDescribedBy}\n          onBlur={handleBlur}\n          ref={input}\n          onFocus={handleFocus}\n          onKeyDown={handleKeyDown}\n          onKeyUp={handleKeyUp}\n          disabled={disabled}\n          aria-disabled={disabled}\n          data-lpignore\n          data-ktp-execute-target={true}\n          {...inputProps}\n        />\n        <span className={classNames.arrowButtonsContainer}>\n          <IconButton\n            styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n            className={'ms-UpButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n            disabled={disabled}\n            iconProps={incrementButtonIcon}\n            onMouseDown={handleIncrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={incrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n          <IconButton\n            styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n            className={'ms-DownButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n            disabled={disabled}\n            iconProps={decrementButtonIcon}\n            onMouseDown={handleDecrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={decrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n        </span>\n      </div>\n      {labelPosition === Position.bottom && labelContent}\n    </div>\n  );\n});\nSpinButtonBase.displayName = COMPONENT_NAME;\n\nconst useDebugWarnings = (props: ISpinButtonProps) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { value: 'defaultValue' },\n    });\n  }\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}