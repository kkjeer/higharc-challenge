{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SwatchColorPicker';\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      mutuallyExclusive: {\n        focusOnHover: 'onHover',\n        selectedId: 'defaultSelectedId'\n      },\n      deprecations: {\n        isControlled: \"selectedId' or 'defaultSelectedId\",\n        onColorChanged: 'onChange'\n      }\n    });\n  }\n}\n\nexport var SwatchColorPickerBase = React.forwardRef(function (props, ref) {\n  var defaultId = useId('swatchColorPicker');\n  var id = props.id || defaultId;\n  var internalState = useConst({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250\n  });\n\n  var _a = useSetTimeout(),\n      setTimeout = _a.setTimeout,\n      clearTimeout = _a.clearTimeout;\n\n  useDebugWarnings(props);\n  var colorCells = props.colorCells,\n      _b = props.cellShape,\n      cellShape = _b === void 0 ? 'circle' : _b,\n      columnCount = props.columnCount,\n      _c = props.shouldFocusCircularNavigate,\n      shouldFocusCircularNavigate = _c === void 0 ? true : _c,\n      className = props.className,\n      _d = props.disabled,\n      disabled = _d === void 0 ? false : _d,\n      doNotContainWithinFocusZone = props.doNotContainWithinFocusZone,\n      styles = props.styles,\n      _e = props.cellMargin,\n      cellMargin = _e === void 0 ? 10 : _e,\n      defaultSelectedId = props.defaultSelectedId,\n      focusOnHover = props.focusOnHover,\n      mouseLeaveParentSelector = props.mouseLeaveParentSelector,\n      onChange = props.onChange,\n      // eslint-disable-next-line deprecation/deprecation\n  onColorChanged = props.onColorChanged,\n      onCellHovered = props.onCellHovered,\n      onCellFocused = props.onCellFocused,\n      getColorGridCellStyles = props.getColorGridCellStyles,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      cellBorderWidth = props.cellBorderWidth;\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n\n  var itemsWithIndex = React.useMemo(function () {\n    return colorCells.map(function (item, index) {\n      return __assign(__assign({}, item), {\n        index: index\n      });\n    });\n  }, [colorCells]);\n  var mergedOnChange = React.useCallback(function (ev, newSelectedId) {\n    var _a; // Call both new and old change handlers, and add the extra `color` parameter\n\n\n    var newColor = (_a = colorCells.filter(function (c) {\n      return c.id === newSelectedId;\n    })[0]) === null || _a === void 0 ? void 0 : _a.color;\n    onChange === null || onChange === void 0 ? void 0 : onChange(ev, newSelectedId, newColor);\n    onColorChanged === null || onColorChanged === void 0 ? void 0 : onColorChanged(newSelectedId, newColor);\n  }, [onChange, onColorChanged, colorCells]);\n\n  var _f = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange),\n      selectedId = _f[0],\n      setSelectedId = _f[1];\n\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    cellMargin: cellMargin\n  });\n  var gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer\n  };\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n\n  var isSemanticRadio = colorCells.length <= columnCount;\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n\n  var onSwatchColorPickerBlur = React.useCallback(function (event) {\n    if (onCellFocused) {\n      internalState.cellFocused = false;\n      onCellFocused(undefined, undefined, event);\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n\n  var onMouseEnter = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n\n    if (internalState.isNavigationIdle && !disabled) {\n      ev.currentTarget.focus();\n    }\n\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n\n  var onMouseMove = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n\n    var targetElement = ev.currentTarget; // If navigation is idle and the targetElement is the focused element bail out\n\n    if (internalState.isNavigationIdle && !(document && targetElement === document.activeElement)) {\n      targetElement.focus();\n    }\n\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n\n  var onMouseLeave = React.useCallback(function (ev) {\n    var parentSelector = mouseLeaveParentSelector;\n\n    if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n      return;\n    } // Get the elements that math the given selector\n\n\n    var elements = document.querySelectorAll(parentSelector); // iterate over the elements return to make sure it is a parent of the target and focus it\n\n    for (var index = 0; index < elements.length; index += 1) {\n      if (elements[index].contains(ev.currentTarget)) {\n        /**\n         * IE11 focus() method forces parents to scroll to top of element.\n         * Edge and IE expose a setActive() function for focusable divs that\n         * sets the page focus but does not scroll the parent element.\n         */\n        if (elements[index].setActive) {\n          try {\n            elements[index].setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          elements[index].focus();\n        }\n\n        break;\n      }\n    }\n  }, [disabled, focusOnHover, internalState, mouseLeaveParentSelector]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n\n  var onGridCellHovered = React.useCallback(function (item, event) {\n    if (onCellHovered) {\n      item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n    }\n  }, [onCellHovered]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n\n  var onGridCellFocused = React.useCallback(function (item, event) {\n    if (onCellFocused) {\n      if (item) {\n        internalState.cellFocused = true;\n        return onCellFocused(item.id, item.color, event);\n      } else {\n        internalState.cellFocused = false;\n        return onCellFocused(undefined, undefined, event);\n      }\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Handle the click on a cell\n   */\n\n  var onCellClick = React.useCallback(function (item, event) {\n    if (disabled) {\n      return;\n    }\n\n    if (item.id !== selectedId) {\n      if (onCellFocused && internalState.cellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n\n      setSelectedId(item.id, event);\n    }\n  }, [disabled, internalState, onCellFocused, selectedId, setSelectedId]);\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n\n  var setNavigationTimeout = React.useCallback(function () {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n\n    internalState.navigationIdleTimeoutId = setTimeout(function () {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n  /**\n   * Callback used to handle KeyCode events\n   */\n\n  var onKeyDown = React.useCallback(function (ev) {\n    if ( // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.up || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.down || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.left || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.right) {\n      setNavigationTimeout();\n    }\n  }, [setNavigationTimeout]);\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n\n  var renderOption = function (item) {\n    return React.createElement(ColorPickerGridCell, {\n      item: item,\n      idPrefix: id,\n      color: item.color,\n      styles: getColorGridCellStyles,\n      disabled: disabled,\n      onClick: onCellClick,\n      onHover: onGridCellHovered,\n      onFocus: onGridCellFocused,\n      selected: selectedId === item.id,\n      circle: cellShape === 'circle',\n      label: item.label,\n      onMouseEnter: onMouseEnter,\n      onMouseMove: onMouseMove,\n      onMouseLeave: onMouseLeave,\n      onWheel: setNavigationTimeout,\n      onKeyDown: onKeyDown,\n      height: cellHeight,\n      width: cellWidth,\n      borderWidth: cellBorderWidth,\n      isRadio: isSemanticRadio\n    });\n  };\n\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n\n  var onRenderItem = function (item, index) {\n    var _a = props.onRenderColorCell,\n        onRenderColorCell = _a === void 0 ? renderOption : _a;\n    return onRenderColorCell(item, renderOption);\n  };\n\n  return React.createElement(ButtonGrid, __assign({}, props, {\n    ref: ref,\n    id: id,\n    items: itemsWithIndex,\n    columnCount: columnCount,\n    isSemanticRadio: isSemanticRadio,\n    // eslint-disable-next-line react/jsx-no-bind\n    onRenderItem: onRenderItem,\n    shouldFocusCircularNavigate: shouldFocusCircularNavigate,\n    doNotContainWithinFocusZone: doNotContainWithinFocusZone,\n    onBlur: onSwatchColorPickerBlur,\n    theme: props.theme,\n    styles: gridStyles\n  }));\n});\nSwatchColorPickerBase.displayName = COMPONENT_NAME;","map":{"version":3,"sources":["components/SwatchColorPicker/SwatchColorPicker.base.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,kBAAT,EAA6B,QAA7B,QAA6C,iBAA7C;AACA,SAAS,UAAT,QAA2B,uCAA3B;AACA,SAAS,mBAAT,QAAoC,uBAApC;AACA,SAAS,KAAT,EAAgB,QAAhB,EAA0B,aAA1B,EAAyC,oBAAzC,EAA+D,WAA/D,QAAkF,uBAAlF;AAgBA,IAAM,aAAa,GAAG,kBAAkB,EAAxC;AAEA,IAAM,cAAc,GAAG,mBAAvB;;AAEA,SAAS,gBAAT,CAA0B,KAA1B,EAAwD;EACtD,IAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA7B,EAA2C;IACzC;IACA,WAAW,CAAC;MACV,IAAI,EAAE,cADI;MAEV,KAAK,EAAA,KAFK;MAGV,iBAAiB,EAAE;QAAE,YAAY,EAAE,SAAhB;QAA2B,UAAU,EAAE;MAAvC,CAHT;MAIV,YAAY,EAAE;QAAE,YAAY,EAAE,mCAAhB;QAAqD,cAAc,EAAE;MAArE;IAJJ,CAAD,CAAX;EAMD;AACF;;AAED,OAAO,IAAM,qBAAqB,GAAqD,KAAK,CAAC,UAAN,CAGrF,UAAC,KAAD,EAAQ,GAAR,EAAW;EACX,IAAM,SAAS,GAAG,KAAK,CAAC,mBAAD,CAAvB;EACA,IAAM,EAAE,GAAG,KAAK,CAAC,EAAN,IAAY,SAAvB;EAEA,IAAM,aAAa,GAAG,QAAQ,CAAkC;IAC9D,gBAAgB,EAAE,IAD4C;IAE9D,WAAW,EAAE,KAFiD;IAG9D,uBAAuB,EAAE,SAHqC;IAI9D,mBAAmB,EAAE;EAJyC,CAAlC,CAA9B;;EAOM,IAAA,EAAA,GAA+B,aAAa,EAA5C;EAAA,IAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;EAAA,IAAc,YAAY,GAAA,EAAA,CAAA,YAA1B;;EAEN,gBAAgB,CAAC,KAAD,CAAhB;EAGE,IAAA,UAAU,GAqBR,KAAK,CArBG,UAAV;EAAA,IACA,EAAA,GAoBE,KAAK,CApBa,SADpB;EAAA,IACA,SAAS,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,QAAH,GAAW,EADpB;EAAA,IAEA,WAAW,GAmBT,KAAK,CAnBI,WAFX;EAAA,IAGA,EAAA,GAkBE,KAAK,CAlB2B,2BAHlC;EAAA,IAGA,2BAA2B,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAH,GAAO,EAHlC;EAAA,IAIA,SAAS,GAiBP,KAAK,CAjBE,SAJT;EAAA,IAKA,EAAA,GAgBE,KAAK,CAhBS,QALhB;EAAA,IAKA,QAAQ,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EALhB;EAAA,IAMA,2BAA2B,GAezB,KAAK,CAfoB,2BAN3B;EAAA,IAOA,MAAM,GAcJ,KAAK,CAdD,MAPN;EAAA,IAQA,EAAA,GAaE,KAAK,CAbQ,UARf;EAAA,IAQA,UAAU,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EARf;EAAA,IASA,iBAAiB,GAYf,KAAK,CAZU,iBATjB;EAAA,IAUA,YAAY,GAWV,KAAK,CAXK,YAVZ;EAAA,IAWA,wBAAwB,GAUtB,KAAK,CAViB,wBAXxB;EAAA,IAYA,QAAQ,GASN,KAAK,CATC,QAZR;EAAA,IAaA;EACA,cAAc,GAOZ,KAAK,CAPO,cAdd;EAAA,IAeA,aAAa,GAMX,KAAK,CANM,aAfb;EAAA,IAgBA,aAAa,GAKX,KAAK,CALM,aAhBb;EAAA,IAiBA,sBAAsB,GAIpB,KAAK,CAJe,sBAjBtB;EAAA,IAkBA,UAAU,GAGR,KAAK,CAHG,UAlBV;EAAA,IAmBA,SAAS,GAEP,KAAK,CAFE,SAnBT;EAAA,IAoBA,eAAe,GACb,KAAK,CADQ,eApBf;EAuBF;;AAEG;;EACH,IAAM,cAAc,GAAG,KAAK,CAAC,OAAN,CAAc,YAAA;IACnC,OAAO,UAAU,CAAC,GAAX,CAAe,UAAC,IAAD,EAAO,KAAP,EAAY;MAChC,OAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAY,IAAZ,CAAA,EAAgB;QAAE,KAAK,EAAE;MAAT,CAAhB,CAAA;IACD,CAFM,CAAP;EAGD,CAJsB,EAIpB,CAAC,UAAD,CAJoB,CAAvB;EAMA,IAAM,cAAc,GAAG,KAAK,CAAC,WAAN,CACrB,UAAC,EAAD,EAAmC,aAAnC,EAAoE;WAAA,CAClE;;;IACA,IAAM,QAAQ,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,MAAX,CAAkB,UAAA,CAAA,EAAC;MAAI,OAAA,CAAC,CAAC,EAAF,KAAA,aAAA;IAAsB,CAA7C,EAA+C,CAA/C,CAAA,MAAiD,IAAjD,IAAiD,EAAA,KAAA,KAAA,CAAjD,GAAiD,KAAA,CAAjD,GAAiD,EAAA,CAAE,KAApE;IACA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAG,EAAH,EAAO,aAAP,EAAsB,QAAtB,CAAR;IACA,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAA,cAAc,CAAG,aAAH,EAAkB,QAAlB,CAAd;EACD,CANoB,EAOrB,CAAC,QAAD,EAAW,cAAX,EAA2B,UAA3B,CAPqB,CAAvB;;EAUM,IAAA,EAAA,GAA8B,oBAAoB,CAAC,KAAK,CAAC,UAAP,EAAmB,iBAAnB,EAAsC,cAAtC,CAAlD;EAAA,IAAC,UAAU,GAAA,EAAA,CAAA,CAAA,CAAX;EAAA,IAAa,aAAa,GAAA,EAAA,CAAA,CAAA,CAA1B;;EAEN,IAAM,UAAU,GAAG,aAAa,CAAC,MAAD,EAAU;IACxC,KAAK,EAAE,KAAK,CAAC,KAD2B;IAExC,SAAS,EAAA,SAF+B;IAGxC,UAAU,EAAA;EAH8B,CAAV,CAAhC;EAMA,IAAM,UAAU,GAAG;IACjB,IAAI,EAAE,UAAU,CAAC,IADA;IAEjB,SAAS,EAAE,UAAU,CAAC,SAFL;IAGjB,gBAAgB,EAAE,UAAU,CAAC;EAHZ,CAAnB;EAMA;;;;;;AAMG;;EACH,IAAM,eAAe,GAAG,UAAU,CAAC,MAAX,IAAqB,WAA7C;EAEA;;;AAGG;;EACH,IAAM,uBAAuB,GAAG,KAAK,CAAC,WAAN,CAC9B,UAAC,KAAD,EAA4C;IAC1C,IAAI,aAAJ,EAAmB;MACjB,aAAa,CAAC,WAAd,GAA4B,KAA5B;MACA,aAAa,CAAC,SAAD,EAAY,SAAZ,EAAuB,KAAvB,CAAb;IACD;EACF,CAN6B,EAO9B,CAAC,aAAD,EAAgB,aAAhB,CAP8B,CAAhC;EAUA;;AAEG;;EACH,IAAM,YAAY,GAAG,KAAK,CAAC,WAAN,CACnB,UAAC,EAAD,EAAwC;IACtC,IAAI,CAAC,YAAL,EAAmB;MACjB,OAAO,CAAC,aAAa,CAAC,gBAAf,IAAmC,CAAC,CAAC,QAA5C;IACD;;IACD,IAAI,aAAa,CAAC,gBAAd,IAAkC,CAAC,QAAvC,EAAiD;MAC/C,EAAE,CAAC,aAAH,CAAiB,KAAjB;IACD;;IACD,OAAO,IAAP;EACD,CATkB,EAUnB,CAAC,YAAD,EAAe,aAAf,EAA8B,QAA9B,CAVmB,CAArB;EAaA;;AAEG;;EACH,IAAM,WAAW,GAAG,KAAK,CAAC,WAAN,CAClB,UAAC,EAAD,EAAwC;IACtC,IAAI,CAAC,YAAL,EAAmB;MACjB,OAAO,CAAC,aAAa,CAAC,gBAAf,IAAmC,CAAC,CAAC,QAA5C;IACD;;IAED,IAAM,aAAa,GAAG,EAAE,CAAC,aAAzB,CALsC,CAOtC;;IACA,IAAI,aAAa,CAAC,gBAAd,IAAkC,EAAE,QAAQ,IAAI,aAAa,KAAM,QAAQ,CAAC,aAA1C,CAAtC,EAAgH;MAC9G,aAAa,CAAC,KAAd;IACD;;IAED,OAAO,IAAP;EACD,CAdiB,EAelB,CAAC,YAAD,EAAe,aAAf,EAA8B,QAA9B,CAfkB,CAApB;EAkBA;;AAEG;;EACH,IAAM,YAAY,GAAG,KAAK,CAAC,WAAN,CACnB,UAAC,EAAD,EAAwC;IACtC,IAAM,cAAc,GAAG,wBAAvB;;IAEA,IAAI,CAAC,YAAD,IAAiB,CAAC,cAAlB,IAAoC,CAAC,aAAa,CAAC,gBAAnD,IAAuE,QAA3E,EAAqF;MACnF;IACD,CALqC,CAOtC;;;IACA,IAAM,QAAQ,GAAG,QAAQ,CAAC,gBAAT,CAA0B,cAA1B,CAAjB,CARsC,CAUtC;;IACA,KAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,QAAQ,CAAC,MAArC,EAA6C,KAAK,IAAI,CAAtD,EAAyD;MACvD,IAAI,QAAQ,CAAC,KAAD,CAAR,CAAgB,QAAhB,CAAyB,EAAE,CAAC,aAA5B,CAAJ,EAAgD;QAC9C;;;;AAIG;QACH,IAAK,QAAQ,CAAC,KAAD,CAAR,CAAwB,SAA7B,EAAwC;UACtC,IAAI;YACD,QAAQ,CAAC,KAAD,CAAR,CAAwB,SAAxB;UACF,CAFD,CAEE,OAAO,CAAP,EAAU;YACV;UACD;QACF,CAND,MAMO;UACJ,QAAQ,CAAC,KAAD,CAAR,CAAgC,KAAhC;QACF;;QAED;MACD;IACF;EACF,CAhCkB,EAiCnB,CAAC,QAAD,EAAW,YAAX,EAAyB,aAAzB,EAAwC,wBAAxC,CAjCmB,CAArB;EAoCA;;;AAGG;;EACH,IAAM,iBAAiB,GAAG,KAAK,CAAC,WAAN,CACxB,UAAC,IAAD,EAAyB,KAAzB,EAAoE;IAClE,IAAI,aAAJ,EAAmB;MACjB,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,EAAN,EAAU,IAAI,CAAC,KAAf,EAAsB,KAAtB,CAAhB,GAA+C,aAAa,CAAC,SAAD,EAAY,SAAZ,EAAuB,KAAvB,CAAhE;IACD;EACF,CALuB,EAMxB,CAAC,aAAD,CANwB,CAA1B;EASA;;AAEG;;EACH,IAAM,iBAAiB,GAAG,KAAK,CAAC,WAAN,CACxB,UAAC,IAAD,EAAyB,KAAzB,EAAmE;IACjE,IAAI,aAAJ,EAAmB;MACjB,IAAI,IAAJ,EAAU;QACR,aAAa,CAAC,WAAd,GAA4B,IAA5B;QACA,OAAO,aAAa,CAAC,IAAI,CAAC,EAAN,EAAU,IAAI,CAAC,KAAf,EAAsB,KAAtB,CAApB;MACD,CAHD,MAGO;QACL,aAAa,CAAC,WAAd,GAA4B,KAA5B;QACA,OAAO,aAAa,CAAC,SAAD,EAAY,SAAZ,EAAuB,KAAvB,CAApB;MACD;IACF;EACF,CAXuB,EAYxB,CAAC,aAAD,EAAgB,aAAhB,CAZwB,CAA1B;EAeA;;AAEG;;EACH,IAAM,WAAW,GAAG,KAAK,CAAC,WAAN,CAClB,UAAC,IAAD,EAAwB,KAAxB,EAAmE;IACjE,IAAI,QAAJ,EAAc;MACZ;IACD;;IAED,IAAI,IAAI,CAAC,EAAL,KAAY,UAAhB,EAA4B;MAC1B,IAAI,aAAa,IAAI,aAAa,CAAC,WAAnC,EAAgD;QAC9C,aAAa,CAAC,WAAd,GAA4B,KAA5B;QACA,aAAa,CAAC,SAAD,EAAY,SAAZ,EAAuB,KAAvB,CAAb;MACD;;MACD,aAAa,CAAC,IAAI,CAAC,EAAN,EAAU,KAAV,CAAb;IACD;EACF,CAbiB,EAclB,CAAC,QAAD,EAAW,aAAX,EAA0B,aAA1B,EAAyC,UAAzC,EAAqD,aAArD,CAdkB,CAApB;EAiBA;;;AAGG;;EACH,IAAM,oBAAoB,GAAG,KAAK,CAAC,WAAN,CAAkB,YAAA;IAC7C,IAAI,CAAC,aAAa,CAAC,gBAAf,IAAmC,aAAa,CAAC,uBAAd,KAA0C,SAAjF,EAA4F;MAC1F,YAAY,CAAC,aAAa,CAAC,uBAAf,CAAZ;MACA,aAAa,CAAC,uBAAd,GAAwC,SAAxC;IACD,CAHD,MAGO;MACL,aAAa,CAAC,gBAAd,GAAiC,KAAjC;IACD;;IAED,aAAa,CAAC,uBAAd,GAAwC,UAAU,CAAC,YAAA;MACjD,aAAa,CAAC,gBAAd,GAAiC,IAAjC;IACD,CAFiD,EAE/C,aAAa,CAAC,mBAFiC,CAAlD;EAGD,CAX4B,EAW1B,CAAC,YAAD,EAAe,aAAf,EAA8B,UAA9B,CAX0B,CAA7B;EAaA;;AAEG;;EACH,IAAM,SAAS,GAAG,KAAK,CAAC,WAAN,CAChB,UAAC,EAAD,EAA2C;IACzC,KACE;IACA,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,EAAtB,IACA;IACA,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,IAFtB,IAGA;IACA,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,IAJtB,IAKA;IACA,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,KARxB,EASE;MACA,oBAAoB;IACrB;EACF,CAde,EAehB,CAAC,oBAAD,CAfgB,CAAlB;EAkBA;;;;AAIG;;EACH,IAAM,YAAY,GAAG,UAAC,IAAD,EAAsB;IACzC,OACE,KAAA,CAAA,aAAA,CAAC,mBAAD,EAAoB;MAClB,IAAI,EAAE,IADY;MAElB,QAAQ,EAAE,EAFQ;MAGlB,KAAK,EAAE,IAAI,CAAC,KAHM;MAIlB,MAAM,EAAE,sBAJU;MAKlB,QAAQ,EAAE,QALQ;MAMlB,OAAO,EAAE,WANS;MAOlB,OAAO,EAAE,iBAPS;MAQlB,OAAO,EAAE,iBARS;MASlB,QAAQ,EAAE,UAAU,KAAK,IAAI,CAAC,EATZ;MAUlB,MAAM,EAAE,SAAS,KAAK,QAVJ;MAWlB,KAAK,EAAE,IAAI,CAAC,KAXM;MAYlB,YAAY,EAAE,YAZI;MAalB,WAAW,EAAE,WAbK;MAclB,YAAY,EAAE,YAdI;MAelB,OAAO,EAAE,oBAfS;MAgBlB,SAAS,EAAE,SAhBO;MAiBlB,MAAM,EAAE,UAjBU;MAkBlB,KAAK,EAAE,SAlBW;MAmBlB,WAAW,EAAE,eAnBK;MAoBlB,OAAO,EAAE;IApBS,CAApB,CADF;EAwBD,CAzBD;;EA2BA,IAAI,UAAU,CAAC,MAAX,GAAoB,CAApB,IAAyB,WAAW,GAAG,CAA3C,EAA8C;IAC5C,OAAO,IAAP;EACD;;EAED,IAAM,YAAY,GAAG,UAAC,IAAD,EAAwB,KAAxB,EAAqC;IAChD,IAAA,EAAA,GAAqC,KAAK,CAAV,iBAAhC;IAAA,IAAA,iBAAiB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,YAAH,GAAe,EAAhC;IACR,OAAO,iBAAiB,CAAC,IAAD,EAAO,YAAP,CAAxB;EACD,CAHD;;EAIA,OACE,KAAA,CAAA,aAAA,CAAC,UAAD,EAAW,QAAA,CAAA,EAAA,EACH,KADG,EACmC;IAC5C,GAAG,EAAE,GADuC;IAE5C,EAAE,EAAE,EAFwC;IAG5C,KAAK,EAAE,cAHqC;IAI5C,WAAW,EAAE,WAJ+B;IAK5C,eAAe,EAAE,eAL2B;IAM5C;IACA,YAAY,EAAE,YAP8B;IAQ5C,2BAA2B,EAAE,2BARe;IAS5C,2BAA2B,EAAE,2BATe;IAU5C,MAAM,EAAE,uBAVoC;IAW5C,KAAK,EAAE,KAAK,CAAC,KAX+B;IAY5C,MAAM,EAAE;EAZoC,CADnC,CAAX,CADF;AAiBD,CAhUsF,CAAhF;AAkUP,qBAAqB,CAAC,WAAtB,GAAoC,cAApC","sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nimport type {\n  ISwatchColorPickerProps,\n  ISwatchColorPickerStyleProps,\n  ISwatchColorPickerStyles,\n} from './SwatchColorPicker.types';\nimport type { IColorCellProps } from './ColorPickerGridCell.types';\nimport type { IButtonGridProps } from '../../utilities/ButtonGrid/ButtonGrid.types';\n\ninterface ISwatchColorPickerInternalState {\n  isNavigationIdle: boolean;\n  cellFocused: boolean;\n  navigationIdleTimeoutId: number | undefined;\n  navigationIdleDelay: number;\n}\n\nconst getClassNames = classNamesFunction<ISwatchColorPickerStyleProps, ISwatchColorPickerStyles>();\n\nconst COMPONENT_NAME = 'SwatchColorPicker';\n\nfunction useDebugWarnings(props: ISwatchColorPickerProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { focusOnHover: 'onHover', selectedId: 'defaultSelectedId' },\n      deprecations: { isControlled: \"selectedId' or 'defaultSelectedId\", onColorChanged: 'onChange' },\n    });\n  }\n}\n\nexport const SwatchColorPickerBase: React.FunctionComponent<ISwatchColorPickerProps> = React.forwardRef<\n  HTMLElement,\n  ISwatchColorPickerProps\n>((props, ref) => {\n  const defaultId = useId('swatchColorPicker');\n  const id = props.id || defaultId;\n\n  const internalState = useConst<ISwatchColorPickerInternalState>({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250,\n  });\n\n  const { setTimeout, clearTimeout } = useSetTimeout();\n\n  useDebugWarnings(props);\n\n  const {\n    colorCells,\n    cellShape = 'circle',\n    columnCount,\n    shouldFocusCircularNavigate = true,\n    className,\n    disabled = false,\n    doNotContainWithinFocusZone,\n    styles,\n    cellMargin = 10,\n    defaultSelectedId,\n    focusOnHover,\n    mouseLeaveParentSelector,\n    onChange,\n    // eslint-disable-next-line deprecation/deprecation\n    onColorChanged,\n    onCellHovered,\n    onCellFocused,\n    getColorGridCellStyles,\n    cellHeight,\n    cellWidth,\n    cellBorderWidth,\n  } = props;\n\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n  const itemsWithIndex = React.useMemo(() => {\n    return colorCells.map((item, index) => {\n      return { ...item, index: index };\n    });\n  }, [colorCells]);\n\n  const mergedOnChange = React.useCallback(\n    (ev: React.FormEvent<HTMLElement>, newSelectedId: string | undefined) => {\n      // Call both new and old change handlers, and add the extra `color` parameter\n      const newColor = colorCells.filter(c => c.id === newSelectedId)[0]?.color;\n      onChange?.(ev, newSelectedId, newColor);\n      onColorChanged?.(newSelectedId, newColor);\n    },\n    [onChange, onColorChanged, colorCells],\n  );\n\n  const [selectedId, setSelectedId] = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange);\n\n  const classNames = getClassNames(styles!, {\n    theme: props.theme!,\n    className,\n    cellMargin,\n  });\n\n  const gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer,\n  };\n\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n  const isSemanticRadio = colorCells.length <= columnCount;\n\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n  const onSwatchColorPickerBlur = React.useCallback(\n    (event?: React.FocusEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n  const onMouseEnter = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n      if (internalState.isNavigationIdle && !disabled) {\n        ev.currentTarget.focus();\n      }\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseMove = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n\n      const targetElement = ev.currentTarget as HTMLElement;\n\n      // If navigation is idle and the targetElement is the focused element bail out\n      if (internalState.isNavigationIdle && !(document && targetElement === (document.activeElement as HTMLElement))) {\n        targetElement.focus();\n      }\n\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseLeave = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): void => {\n      const parentSelector = mouseLeaveParentSelector;\n\n      if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n        return;\n      }\n\n      // Get the elements that math the given selector\n      const elements = document.querySelectorAll(parentSelector);\n\n      // iterate over the elements return to make sure it is a parent of the target and focus it\n      for (let index = 0; index < elements.length; index += 1) {\n        if (elements[index].contains(ev.currentTarget)) {\n          /**\n           * IE11 focus() method forces parents to scroll to top of element.\n           * Edge and IE expose a setActive() function for focusable divs that\n           * sets the page focus but does not scroll the parent element.\n           */\n          if ((elements[index] as any).setActive) {\n            try {\n              (elements[index] as any).setActive();\n            } catch (e) {\n              /* no-op */\n            }\n          } else {\n            (elements[index] as HTMLElement).focus();\n          }\n\n          break;\n        }\n      }\n    },\n    [disabled, focusOnHover, internalState, mouseLeaveParentSelector],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n  const onGridCellHovered = React.useCallback(\n    (item?: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (onCellHovered) {\n        item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n      }\n    },\n    [onCellHovered],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n  const onGridCellFocused = React.useCallback(\n    (item?: IColorCellProps, event?: React.FormEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        if (item) {\n          internalState.cellFocused = true;\n          return onCellFocused(item.id, item.color, event);\n        } else {\n          internalState.cellFocused = false;\n          return onCellFocused(undefined, undefined, event);\n        }\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Handle the click on a cell\n   */\n  const onCellClick = React.useCallback(\n    (item: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (disabled) {\n        return;\n      }\n\n      if (item.id !== selectedId) {\n        if (onCellFocused && internalState.cellFocused) {\n          internalState.cellFocused = false;\n          onCellFocused(undefined, undefined, event);\n        }\n        setSelectedId(item.id, event);\n      }\n    },\n    [disabled, internalState, onCellFocused, selectedId, setSelectedId],\n  );\n\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n  const setNavigationTimeout = React.useCallback(() => {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n\n    internalState.navigationIdleTimeoutId = setTimeout(() => {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n\n  /**\n   * Callback used to handle KeyCode events\n   */\n  const onKeyDown = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLButtonElement>): void => {\n      if (\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.up ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.down ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.left ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.right\n      ) {\n        setNavigationTimeout();\n      }\n    },\n    [setNavigationTimeout],\n  );\n\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n  const renderOption = (item: IColorCellProps): JSX.Element => {\n    return (\n      <ColorPickerGridCell\n        item={item}\n        idPrefix={id}\n        color={item.color}\n        styles={getColorGridCellStyles}\n        disabled={disabled}\n        onClick={onCellClick}\n        onHover={onGridCellHovered}\n        onFocus={onGridCellFocused}\n        selected={selectedId === item.id}\n        circle={cellShape === 'circle'}\n        label={item.label}\n        onMouseEnter={onMouseEnter}\n        onMouseMove={onMouseMove}\n        onMouseLeave={onMouseLeave}\n        onWheel={setNavigationTimeout}\n        onKeyDown={onKeyDown}\n        height={cellHeight}\n        width={cellWidth}\n        borderWidth={cellBorderWidth}\n        isRadio={isSemanticRadio}\n      />\n    );\n  };\n\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n\n  const onRenderItem = (item: IColorCellProps, index: number): JSX.Element => {\n    const { onRenderColorCell = renderOption } = props;\n    return onRenderColorCell(item, renderOption) as JSX.Element;\n  };\n  return (\n    <ButtonGrid\n      {...((props as unknown) as IButtonGridProps)}\n      ref={ref}\n      id={id}\n      items={itemsWithIndex}\n      columnCount={columnCount}\n      isSemanticRadio={isSemanticRadio}\n      // eslint-disable-next-line react/jsx-no-bind\n      onRenderItem={onRenderItem}\n      shouldFocusCircularNavigate={shouldFocusCircularNavigate}\n      doNotContainWithinFocusZone={doNotContainWithinFocusZone}\n      onBlur={onSwatchColorPickerBlur}\n      theme={props.theme!}\n      styles={gridStyles}\n    />\n  );\n});\n\nSwatchColorPickerBase.displayName = COMPONENT_NAME;\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}