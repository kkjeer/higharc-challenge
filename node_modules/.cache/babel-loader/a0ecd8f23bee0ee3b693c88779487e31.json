{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { useId, useControllableValue, useConst, useSetTimeout } from '@fluentui/react-hooks';\nimport { KeyCodes, css, getRTL, getRTLSafeKeyCode, on, classNamesFunction, getNativeProps, divProperties } from '@fluentui/utilities';\nexport var ONKEYDOWN_TIMEOUT_DURATION = 1000;\nvar getClassNames = classNamesFunction();\n\nvar getSlotStyleFn = function (sty) {\n  return function (value) {\n    var _a;\n\n    return _a = {}, _a[sty] = value + \"%\", _a;\n  };\n};\n\nvar getPercent = function (value, sliderMin, sliderMax) {\n  return sliderMax === sliderMin ? 0 : (value - sliderMin) / (sliderMax - sliderMin) * 100;\n};\n\nvar useComponentRef = function (props, thumb, value, range) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      get value() {\n        return value;\n      },\n\n      get range() {\n        return range;\n      },\n\n      focus: function () {\n        if (thumb.current) {\n          thumb.current.focus();\n        }\n      }\n    };\n  }, [thumb, value, range]);\n};\n\nexport var useSlider = function (props, ref) {\n  var _a = props.step,\n      step = _a === void 0 ? 1 : _a,\n      className = props.className,\n      _b = props.disabled,\n      disabled = _b === void 0 ? false : _b,\n      label = props.label,\n      _c = props.max,\n      max = _c === void 0 ? 10 : _c,\n      _d = props.min,\n      min = _d === void 0 ? 0 : _d,\n      _e = props.showValue,\n      showValue = _e === void 0 ? true : _e,\n      _f = props.buttonProps,\n      buttonProps = _f === void 0 ? {} : _f,\n      _g = props.vertical,\n      vertical = _g === void 0 ? false : _g,\n      snapToStep = props.snapToStep,\n      valueFormat = props.valueFormat,\n      styles = props.styles,\n      theme = props.theme,\n      originFromZero = props.originFromZero,\n      ariaLabelledBy = props[\"aria-labelledby\"],\n      ariaLabel = props[\"aria-label\"],\n      ranged = props.ranged,\n      onChange = props.onChange,\n      onChanged = props.onChanged;\n  var disposables = React.useRef([]);\n\n  var _h = useSetTimeout(),\n      setTimeout = _h.setTimeout,\n      clearTimeout = _h.clearTimeout;\n\n  var sliderLine = React.useRef(null); // Casting here is necessary because useControllableValue expects the event for the change callback\n  // to extend React.SyntheticEvent, when in fact for Slider, the event could be either a React event\n  // or a native browser event depending on the context.\n\n  var _j = useControllableValue(props.value, props.defaultValue, function (ev, v) {\n    return onChange === null || onChange === void 0 ? void 0 : onChange(v, ranged ? [internalState.latestLowerValue, v] : undefined, ev);\n  }),\n      unclampedValue = _j[0],\n      setValue = _j[1];\n\n  var _k = useControllableValue(props.lowerValue, props.defaultLowerValue, function (ev, lv) {\n    return onChange === null || onChange === void 0 ? void 0 : onChange(internalState.latestValue, [lv, internalState.latestValue], ev);\n  }),\n      unclampedLowerValue = _k[0],\n      setLowerValue = _k[1]; // Ensure that value is always a number and is clamped by min/max.\n\n\n  var value = Math.max(min, Math.min(max, unclampedValue || 0));\n  var lowerValue = Math.max(min, Math.min(value, unclampedLowerValue || 0));\n  var internalState = useConst({\n    onKeyDownTimer: -1,\n    isAdjustingLowerValue: false,\n    latestValue: value,\n    latestLowerValue: lowerValue\n  }); // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n\n  internalState.latestValue = value;\n  internalState.latestLowerValue = lowerValue;\n  var id = useId('Slider', props.id || (buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.id));\n  var classNames = getClassNames(styles, {\n    className: className,\n    disabled: disabled,\n    vertical: vertical,\n    showTransitions: !snapToStep && !internalState.isBetweenSteps,\n    showValue: showValue,\n    ranged: ranged,\n    theme: theme\n  });\n  var steps = (max - min) / step;\n\n  var clearOnKeyDownTimer = function () {\n    clearTimeout(internalState.onKeyDownTimer);\n    internalState.onKeyDownTimer = -1;\n  };\n\n  var setOnKeyDownTimer = function (event) {\n    clearOnKeyDownTimer();\n\n    if (onChanged) {\n      internalState.onKeyDownTimer = setTimeout(function () {\n        onChanged(event, internalState.latestValue, ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined);\n      }, ONKEYDOWN_TIMEOUT_DURATION);\n    }\n  };\n\n  var getAriaValueText = function (valueProps) {\n    var ariaValueText = props.ariaValueText;\n\n    if (valueProps !== undefined) {\n      return ariaValueText ? ariaValueText(valueProps) : valueProps.toString();\n    }\n\n    return undefined;\n  };\n  /**\n   * Update `value` or `lowerValue`, including clamping between min/max and rounding to\n   * appropriate precision.\n   * @param newValue - New current value of the slider, possibly rounded to a whole step.\n   * @param newUnroundedValue - Like `newValue` but without the rounding to a step. If this is\n   * provided and not equal to `newValue`, `internalState.isBetweenSteps` will be set, which\n   * may cause thumb movement animations to be disabled.\n   */\n\n\n  var updateValue = function (ev, newValue, newUnroundedValue) {\n    newValue = Math.min(max, Math.max(min, newValue));\n    newUnroundedValue = newUnroundedValue !== undefined ? Math.min(max, Math.max(min, newUnroundedValue)) : undefined;\n    var numDec = 0;\n\n    if (isFinite(step)) {\n      while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {\n        numDec++;\n      }\n    } // Make sure value has correct number of decimal places based on number of decimals in step\n\n\n    var roundedValue = parseFloat(newValue.toFixed(numDec));\n    internalState.isBetweenSteps = newUnroundedValue !== undefined && newUnroundedValue !== roundedValue;\n\n    if (ranged) {\n      // decided which thumb value to change\n      if (internalState.isAdjustingLowerValue && (originFromZero ? roundedValue <= 0 : roundedValue <= internalState.latestValue)) {\n        setLowerValue(roundedValue, ev);\n      } else if (!internalState.isAdjustingLowerValue && (originFromZero ? roundedValue >= 0 : roundedValue >= internalState.latestLowerValue)) {\n        setValue(roundedValue, ev);\n      }\n    } else {\n      setValue(roundedValue, ev);\n    }\n  };\n\n  var onKeyDown = function (event) {\n    var newCurrentValue = internalState.isAdjustingLowerValue ? internalState.latestLowerValue : internalState.latestValue;\n    var diff = 0; // eslint-disable-next-line deprecation/deprecation\n\n    switch (event.which) {\n      case getRTLSafeKeyCode(KeyCodes.left, props.theme):\n      case KeyCodes.down:\n        diff = -step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case getRTLSafeKeyCode(KeyCodes.right, props.theme):\n      case KeyCodes.up:\n        diff = step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case KeyCodes.home:\n        newCurrentValue = min;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case KeyCodes.end:\n        newCurrentValue = max;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      default:\n        return;\n    }\n\n    updateValue(event, newCurrentValue + diff);\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  var getPosition = function (event, verticalProp) {\n    var currentPosition = 0;\n\n    switch (event.type) {\n      case 'mousedown':\n      case 'mousemove':\n        currentPosition = !verticalProp ? event.clientX : event.clientY;\n        break;\n\n      case 'touchstart':\n      case 'touchmove':\n        currentPosition = !verticalProp ? event.touches[0].clientX : event.touches[0].clientY;\n        break;\n    }\n\n    return currentPosition;\n  };\n\n  var calculateCurrentSteps = function (event) {\n    var sliderPositionRect = sliderLine.current.getBoundingClientRect();\n    var sliderLength = !props.vertical ? sliderPositionRect.width : sliderPositionRect.height;\n    var stepLength = sliderLength / steps;\n    var currentSteps;\n    var distance;\n\n    if (!props.vertical) {\n      var left = getPosition(event, props.vertical);\n      distance = getRTL(props.theme) ? sliderPositionRect.right - left : left - sliderPositionRect.left;\n      currentSteps = distance / stepLength;\n    } else {\n      var bottom = getPosition(event, props.vertical);\n      distance = sliderPositionRect.bottom - bottom;\n      currentSteps = distance / stepLength;\n    }\n\n    return currentSteps;\n  };\n\n  var onMouseMoveOrTouchMove = function (event, suppressEventCancelation) {\n    var currentSteps = calculateCurrentSteps(event);\n    var newUnroundedValue = min + step * currentSteps;\n    var newCurrentValue = min + step * Math.round(currentSteps);\n    updateValue(event, newCurrentValue, newUnroundedValue);\n\n    if (!suppressEventCancelation) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  var onMouseDownOrTouchStart = function (event) {\n    if (ranged) {\n      var currentSteps = calculateCurrentSteps(event);\n      var newValue = min + step * currentSteps;\n      internalState.isAdjustingLowerValue = newValue <= internalState.latestLowerValue || newValue - internalState.latestLowerValue <= internalState.latestValue - newValue;\n    }\n\n    if (event.type === 'mousedown') {\n      disposables.current.push(on(window, 'mousemove', onMouseMoveOrTouchMove, true), on(window, 'mouseup', onMouseUpOrTouchEnd, true));\n    } else if (event.type === 'touchstart') {\n      disposables.current.push(on(window, 'touchmove', onMouseMoveOrTouchMove, true), on(window, 'touchend', onMouseUpOrTouchEnd, true));\n    }\n\n    onMouseMoveOrTouchMove(event, true);\n  };\n\n  var onMouseUpOrTouchEnd = function (event) {\n    // Done adjusting, so clear this value\n    internalState.isBetweenSteps = undefined;\n    onChanged === null || onChanged === void 0 ? void 0 : onChanged(event, internalState.latestValue, ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined);\n    disposeListeners();\n  };\n\n  var onThumbFocus = function (event) {\n    internalState.isAdjustingLowerValue = event.target === lowerValueThumbRef.current;\n  };\n\n  var disposeListeners = function () {\n    disposables.current.forEach(function (dispose) {\n      return dispose();\n    });\n    disposables.current = [];\n  };\n\n  var lowerValueThumbRef = React.useRef(null);\n  var thumbRef = React.useRef(null);\n  useComponentRef(props, ranged && !vertical ? lowerValueThumbRef : thumbRef, value, ranged ? [lowerValue, value] : undefined);\n  var getPositionStyles = getSlotStyleFn(vertical ? 'bottom' : getRTL(props.theme) ? 'right' : 'left');\n  var getTrackStyles = getSlotStyleFn(vertical ? 'height' : 'width');\n  var originValue = originFromZero ? 0 : min;\n  var valuePercent = getPercent(value, min, max);\n  var lowerValuePercent = getPercent(lowerValue, min, max);\n  var originPercentOfLine = getPercent(originValue, min, max);\n  var activeSectionWidth = ranged ? valuePercent - lowerValuePercent : Math.abs(originPercentOfLine - valuePercent);\n  var topSectionWidth = Math.min(100 - valuePercent, 100 - originPercentOfLine);\n  var bottomSectionWidth = ranged ? lowerValuePercent : Math.min(valuePercent, originPercentOfLine);\n  var rootProps = {\n    className: classNames.root,\n    ref: ref\n  };\n  var labelProps = {\n    className: classNames.titleLabel,\n    children: label,\n    disabled: disabled,\n    htmlFor: ariaLabel ? undefined : id\n  };\n  var valueLabelProps = showValue ? {\n    className: classNames.valueLabel,\n    children: valueFormat ? valueFormat(value) : value,\n    disabled: disabled,\n    htmlFor: disabled ? id : undefined\n  } : undefined;\n  var lowerValueLabelProps = ranged && showValue ? {\n    className: classNames.valueLabel,\n    children: valueFormat ? valueFormat(lowerValue) : lowerValue,\n    disabled: disabled\n  } : undefined;\n  var zeroTickProps = originFromZero ? {\n    className: classNames.zeroTick,\n    style: getPositionStyles(originPercentOfLine)\n  } : undefined;\n  var trackActiveProps = {\n    className: css(classNames.lineContainer, classNames.activeSection),\n    style: getTrackStyles(activeSectionWidth)\n  };\n  var trackTopInactiveProps = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(topSectionWidth)\n  };\n  var trackBottomInactiveProps = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(bottomSectionWidth)\n  };\n\n  var sliderProps = __assign({\n    'aria-disabled': disabled,\n    role: 'slider',\n    tabIndex: disabled ? undefined : 0\n  }, {\n    'data-is-focusable': !disabled\n  });\n\n  var sliderBoxProps = __assign(__assign(__assign({\n    id: id,\n    className: css(classNames.slideBox, buttonProps.className)\n  }, !disabled && {\n    onMouseDown: onMouseDownOrTouchStart,\n    onTouchStart: onMouseDownOrTouchStart,\n    onKeyDown: onKeyDown\n  }), buttonProps && getNativeProps(buttonProps, divProperties, ['id', 'className'])), !ranged && __assign(__assign({}, sliderProps), {\n    'aria-valuemin': min,\n    'aria-valuemax': max,\n    'aria-valuenow': value,\n    'aria-valuetext': getAriaValueText(value),\n    'aria-label': ariaLabel || label,\n    'aria-labelledby': ariaLabelledBy\n  }));\n\n  var onFocusProp = disabled ? {} : {\n    onFocus: onThumbFocus\n  };\n\n  var thumbProps = __assign({\n    ref: thumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(valuePercent)\n  }, ranged && __assign(__assign(__assign({}, sliderProps), onFocusProp), {\n    id: \"max-\" + id,\n    'aria-valuemin': lowerValue,\n    'aria-valuemax': max,\n    'aria-valuenow': value,\n    'aria-valuetext': getAriaValueText(value),\n    'aria-label': \"max \" + (ariaLabel || label)\n  }));\n\n  var lowerValueThumbProps = ranged ? __assign(__assign(__assign({\n    ref: lowerValueThumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(lowerValuePercent)\n  }, sliderProps), onFocusProp), {\n    id: \"min-\" + id,\n    'aria-valuemin': min,\n    'aria-valuemax': value,\n    'aria-valuenow': lowerValue,\n    'aria-valuetext': getAriaValueText(lowerValue),\n    'aria-label': \"min \" + (ariaLabel || label)\n  }) : undefined;\n  var containerProps = {\n    className: classNames.container\n  };\n  var sliderLineProps = {\n    ref: sliderLine,\n    className: classNames.line\n  };\n  return {\n    root: rootProps,\n    label: labelProps,\n    sliderBox: sliderBoxProps,\n    container: containerProps,\n    valueLabel: valueLabelProps,\n    lowerValueLabel: lowerValueLabelProps,\n    thumb: thumbProps,\n    lowerValueThumb: lowerValueThumbProps,\n    zeroTick: zeroTickProps,\n    activeTrack: trackActiveProps,\n    topInactiveTrack: trackTopInactiveProps,\n    bottomInactiveTrack: trackBottomInactiveProps,\n    sliderLine: sliderLineProps\n  };\n};","map":{"version":3,"sources":["components/Slider/useSlider.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,KAAT,EAAgB,oBAAhB,EAAsC,QAAtC,EAAgD,aAAhD,QAAqE,uBAArE;AACA,SACE,QADF,EAEE,GAFF,EAGE,MAHF,EAIE,iBAJF,EAKE,EALF,EAME,kBANF,EAOE,cAPF,EAQE,aARF,QASO,qBATP;AAaA,OAAO,IAAM,0BAA0B,GAAG,IAAnC;AAiBP,IAAM,aAAa,GAAG,kBAAkB,EAAxC;;AAUA,IAAM,cAAc,GAAG,UAAC,GAAD,EAAyB;EAC9C,OAAO,UAAC,KAAD,EAAc;;;IACnB,OAAA,EAAA,GAAA,EAAA,EACE,EAAA,CAAC,GAAD,CAAA,GAAU,KAAK,GAAA,GADjB,EAEE,EAFF;EAGD,CAJD;AAKD,CAND;;AAQA,IAAM,UAAU,GAAG,UAAC,KAAD,EAAgB,SAAhB,EAAmC,SAAnC,EAAoD;EACrE,OAAO,SAAS,KAAK,SAAd,GAA0B,CAA1B,GAA+B,CAAC,KAAK,GAAG,SAAT,KAAuB,SAAS,GAAG,SAAnC,CAAD,GAAkD,GAAvF;AACD,CAFD;;AAIA,IAAM,eAAe,GAAG,UACtB,KADsB,EAEtB,KAFsB,EAGtB,KAHsB,EAItB,KAJsB,EAIa;EAEnC,KAAK,CAAC,mBAAN,CACE,KAAK,CAAC,YADR,EAEE,YAAA;IAAM,OAAC;MACL,IAAI,KAAJ,GAAS;QACP,OAAO,KAAP;MACD,CAHI;;MAIL,IAAI,KAAJ,GAAS;QACP,OAAO,KAAP;MACD,CANI;;MAOL,KAAK,EAAA,YAAA;QACH,IAAI,KAAK,CAAC,OAAV,EAAmB;UACjB,KAAK,CAAC,OAAN,CAAc,KAAd;QACD;MACF;IAXI,CAAD;EAYJ,CAdJ,EAeE,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,CAfF;AAiBD,CAvBD;;AAyBA,OAAO,IAAM,SAAS,GAAG,UAAC,KAAD,EAAsB,GAAtB,EAAoD;EAEzE,IAAA,EAAA,GAmBE,KAAK,CAnBC,IAAR;EAAA,IAAA,IAAI,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,CAAH,GAAI,EAAR;EAAA,IACA,SAAS,GAkBP,KAAK,CAlBE,SADT;EAAA,IAEA,EAAA,GAiBE,KAAK,CAjBS,QAFhB;EAAA,IAEA,QAAQ,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EAFhB;EAAA,IAGA,KAAK,GAgBH,KAAK,CAhBF,KAHL;EAAA,IAIA,EAAA,GAeE,KAAK,CAfC,GAJR;EAAA,IAIA,GAAG,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAJR;EAAA,IAKA,EAAA,GAcE,KAAK,CAdA,GALP;EAAA,IAKA,GAAG,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,CAAH,GAAI,EALP;EAAA,IAMA,EAAA,GAaE,KAAK,CAbS,SANhB;EAAA,IAMA,SAAS,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAH,GAAO,EANhB;EAAA,IAOA,EAAA,GAYE,KAAK,CAZS,WAPhB;EAAA,IAOA,WAAW,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAPhB;EAAA,IAQA,EAAA,GAWE,KAAK,CAXS,QARhB;EAAA,IAQA,QAAQ,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EARhB;EAAA,IASA,UAAU,GAUR,KAAK,CAVG,UATV;EAAA,IAUA,WAAW,GAST,KAAK,CATI,WAVX;EAAA,IAWA,MAAM,GAQJ,KAAK,CARD,MAXN;EAAA,IAYA,KAAK,GAOH,KAAK,CAPF,KAZL;EAAA,IAaA,cAAc,GAMZ,KAAK,CANO,cAbd;EAAA,IAcmB,cAAc,GAK/B,KAAK,CAL0B,iBAK1B,CAnBP;EAAA,IAec,SAAS,GAIrB,KAAK,CAJgB,YAIhB,CAnBP;EAAA,IAgBA,MAAM,GAGJ,KAAK,CAHD,MAhBN;EAAA,IAiBA,QAAQ,GAEN,KAAK,CAFC,QAjBR;EAAA,IAkBA,SAAS,GACP,KAAK,CADE,SAlBT;EAqBF,IAAM,WAAW,GAAG,KAAK,CAAC,MAAN,CAA6B,EAA7B,CAApB;;EACM,IAAA,EAAA,GAA+B,aAAa,EAA5C;EAAA,IAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;EAAA,IAAc,YAAY,GAAA,EAAA,CAAA,YAA1B;;EACN,IAAM,UAAU,GAAG,KAAK,CAAC,MAAN,CAA6B,IAA7B,CAAnB,CAzB2E,CA2B3E;EACA;EACA;;EACM,IAAA,EAAA,GAA6B,oBAAoB,CAAC,KAAK,CAAC,KAAP,EAAc,KAAK,CAAC,YAApB,EAAkC,UAAC,EAAD,EAAU,CAAV,EAAW;IAClG,OAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAG,CAAH,EAAO,MAAM,GAAG,CAAC,aAAa,CAAC,gBAAf,EAAiC,CAAjC,CAAH,GAA0C,SAAvD,EAAkE,EAAlE,CAAR;EAA6E,CADxB,CAAjD;EAAA,IAAC,cAAc,GAAA,EAAA,CAAA,CAAA,CAAf;EAAA,IAAiB,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAzB;;EAGA,IAAA,EAAA,GAAuC,oBAAoB,CAC/D,KAAK,CAAC,UADyD,EAE/D,KAAK,CAAC,iBAFyD,EAG/D,UAAC,EAAD,EAAU,EAAV,EAAY;IAAK,OAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAG,aAAa,CAAC,WAAjB,EAA8B,CAAC,EAAD,EAAM,aAAa,CAAC,WAApB,CAA9B,EAAR,EAAQ,CAAR;EAA2E,CAH7B,CAA3D;EAAA,IAAC,mBAAmB,GAAA,EAAA,CAAA,CAAA,CAApB;EAAA,IAAsB,aAAa,GAAA,EAAA,CAAA,CAAA,CAAnC,CAjCqE,CAuC3E;;;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,cAAc,IAAI,CAAhC,CAAd,CAAd;EACA,IAAM,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,mBAAmB,IAAI,CAAvC,CAAd,CAAnB;EAEA,IAAM,aAAa,GAAG,QAAQ,CAAuB;IACnD,cAAc,EAAE,CAAC,CADkC;IAEnD,qBAAqB,EAAE,KAF4B;IAGnD,WAAW,EAAE,KAHsC;IAInD,gBAAgB,EAAE;EAJiC,CAAvB,CAA9B,CA3C2E,CAiD3E;EACA;;EACA,aAAa,CAAC,WAAd,GAA4B,KAA5B;EACA,aAAa,CAAC,gBAAd,GAAiC,UAAjC;EAEA,IAAM,EAAE,GAAG,KAAK,CAAC,QAAD,EAAW,KAAK,CAAC,EAAN,KAAY,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,EAAzB,CAAX,CAAhB;EACA,IAAM,UAAU,GAAG,aAAa,CAAC,MAAD,EAAS;IACvC,SAAS,EAAA,SAD8B;IAEvC,QAAQ,EAAA,QAF+B;IAGvC,QAAQ,EAAA,QAH+B;IAIvC,eAAe,EAAE,CAAC,UAAD,IAAe,CAAC,aAAa,CAAC,cAJR;IAKvC,SAAS,EAAA,SAL8B;IAMvC,MAAM,EAAA,MANiC;IAOvC,KAAK,EAAE;EAPgC,CAAT,CAAhC;EAUA,IAAM,KAAK,GAAG,CAAC,GAAG,GAAG,GAAP,IAAc,IAA5B;;EAEA,IAAM,mBAAmB,GAAG,YAAA;IAC1B,YAAY,CAAC,aAAa,CAAC,cAAf,CAAZ;IACA,aAAa,CAAC,cAAd,GAA+B,CAAC,CAAhC;EACD,CAHD;;EAKA,IAAM,iBAAiB,GAAG,UAAC,KAAD,EAA2B;IACnD,mBAAmB;;IACnB,IAAI,SAAJ,EAAe;MACb,aAAa,CAAC,cAAd,GAA+B,UAAU,CAAC,YAAA;QACxC,SAAS,CACP,KADO,EAEP,aAAa,CAAC,WAFP,EAGP,MAAM,GAAG,CAAC,aAAa,CAAC,gBAAf,EAAiC,aAAa,CAAC,WAA/C,CAAH,GAAiE,SAHhE,CAAT;MAKD,CANwC,EAMtC,0BANsC,CAAzC;IAOD;EACF,CAXD;;EAaA,IAAM,gBAAgB,GAAG,UAAC,UAAD,EAA+B;IAC9C,IAAA,aAAa,GAAK,KAAK,CAAV,aAAb;;IACR,IAAI,UAAU,KAAK,SAAnB,EAA8B;MAC5B,OAAO,aAAa,GAAG,aAAa,CAAC,UAAD,CAAhB,GAA+B,UAAU,CAAC,QAAX,EAAnD;IACD;;IACD,OAAO,SAAP;EACD,CAND;EAQA;;;;;;;AAOG;;;EACH,IAAM,WAAW,GAAG,UAAC,EAAD,EAAU,QAAV,EAA4B,iBAA5B,EAAsD;IACxE,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,QAAd,CAAd,CAAX;IACA,iBAAiB,GAAG,iBAAiB,KAAK,SAAtB,GAAkC,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,iBAAd,CAAd,CAAlC,GAAoF,SAAxG;IAEA,IAAI,MAAM,GAAG,CAAb;;IACA,IAAI,QAAQ,CAAC,IAAD,CAAZ,EAAoB;MAClB,OAAO,IAAI,CAAC,KAAL,CAAW,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,MAAb,CAAlB,IAA0C,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,MAAb,CAA1C,KAAmE,IAA1E,EAAgF;QAC9E,MAAM;MACP;IACF,CATuE,CAUxE;;;IACA,IAAM,YAAY,GAAG,UAAU,CAAC,QAAQ,CAAC,OAAT,CAAiB,MAAjB,CAAD,CAA/B;IAEA,aAAa,CAAC,cAAd,GAA+B,iBAAiB,KAAK,SAAtB,IAAmC,iBAAiB,KAAK,YAAxF;;IAEA,IAAI,MAAJ,EAAY;MACV;MACA,IACE,aAAa,CAAC,qBAAd,KACC,cAAc,GAAG,YAAY,IAAI,CAAnB,GAAuB,YAAY,IAAI,aAAa,CAAC,WADpE,CADF,EAGE;QACA,aAAa,CAAC,YAAD,EAAe,EAAf,CAAb;MACD,CALD,MAKO,IACL,CAAC,aAAa,CAAC,qBAAf,KACC,cAAc,GAAG,YAAY,IAAI,CAAnB,GAAuB,YAAY,IAAI,aAAa,CAAC,gBADpE,CADK,EAGL;QACA,QAAQ,CAAC,YAAD,EAAe,EAAf,CAAR;MACD;IACF,CAbD,MAaO;MACL,QAAQ,CAAC,YAAD,EAAe,EAAf,CAAR;IACD;EACF,CA/BD;;EAiCA,IAAM,SAAS,GAAG,UAAC,KAAD,EAA2B;IAC3C,IAAI,eAAe,GAAG,aAAa,CAAC,qBAAd,GAClB,aAAa,CAAC,gBADI,GAElB,aAAa,CAAC,WAFlB;IAGA,IAAI,IAAI,GAAG,CAAX,CAJ2C,CAK3C;;IACA,QAAQ,KAAK,CAAC,KAAd;MACE,KAAK,iBAAiB,CAAC,QAAQ,CAAC,IAAV,EAAgB,KAAK,CAAC,KAAtB,CAAtB;MACA,KAAK,QAAQ,CAAC,IAAd;QACE,IAAI,GAAG,CAAC,IAAR;QACA,mBAAmB;QACnB,iBAAiB,CAAC,KAAD,CAAjB;QACA;;MACF,KAAK,iBAAiB,CAAC,QAAQ,CAAC,KAAV,EAAiB,KAAK,CAAC,KAAvB,CAAtB;MACA,KAAK,QAAQ,CAAC,EAAd;QACE,IAAI,GAAG,IAAP;QACA,mBAAmB;QACnB,iBAAiB,CAAC,KAAD,CAAjB;QACA;;MACF,KAAK,QAAQ,CAAC,IAAd;QACE,eAAe,GAAG,GAAlB;QACA,mBAAmB;QACnB,iBAAiB,CAAC,KAAD,CAAjB;QACA;;MACF,KAAK,QAAQ,CAAC,GAAd;QACE,eAAe,GAAG,GAAlB;QACA,mBAAmB;QACnB,iBAAiB,CAAC,KAAD,CAAjB;QACA;;MACF;QACE;IAxBJ;;IA0BA,WAAW,CAAC,KAAD,EAAQ,eAAe,GAAG,IAA1B,CAAX;IACA,KAAK,CAAC,cAAN;IACA,KAAK,CAAC,eAAN;EACD,CAnCD;;EAqCA,IAAM,WAAW,GAAG,UAAC,KAAD,EAAyB,YAAzB,EAA0D;IAC5E,IAAI,eAAe,GAAG,CAAtB;;IACA,QAAQ,KAAK,CAAC,IAAd;MACE,KAAK,WAAL;MACA,KAAK,WAAL;QACE,eAAe,GAAG,CAAC,YAAD,GAAiB,KAAoB,CAAC,OAAtC,GAAiD,KAAoB,CAAC,OAAxF;QACA;;MACF,KAAK,YAAL;MACA,KAAK,WAAL;QACE,eAAe,GAAG,CAAC,YAAD,GACb,KAAoB,CAAC,OAArB,CAA6B,CAA7B,EAAgC,OADnB,GAEb,KAAoB,CAAC,OAArB,CAA6B,CAA7B,EAAgC,OAFrC;QAGA;IAVJ;;IAYA,OAAO,eAAP;EACD,CAfD;;EAiBA,IAAM,qBAAqB,GAAG,UAAC,KAAD,EAAuB;IACnD,IAAM,kBAAkB,GAAe,UAAU,CAAC,OAAX,CAAoB,qBAApB,EAAvC;IACA,IAAM,YAAY,GAAW,CAAC,KAAK,CAAC,QAAP,GAAkB,kBAAkB,CAAC,KAArC,GAA6C,kBAAkB,CAAC,MAA7F;IACA,IAAM,UAAU,GAAW,YAAY,GAAG,KAA1C;IACA,IAAI,YAAJ;IACA,IAAI,QAAJ;;IACA,IAAI,CAAC,KAAK,CAAC,QAAX,EAAqB;MACnB,IAAM,IAAI,GAAG,WAAW,CAAC,KAAD,EAAQ,KAAK,CAAC,QAAd,CAAxB;MACA,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,KAAP,CAAN,GAAsB,kBAAkB,CAAC,KAAnB,GAA2B,IAAjD,GAAwD,IAAI,GAAG,kBAAkB,CAAC,IAA7F;MACA,YAAY,GAAG,QAAQ,GAAG,UAA1B;IACD,CAJD,MAIO;MACL,IAAM,MAAM,GAAG,WAAW,CAAC,KAAD,EAAQ,KAAK,CAAC,QAAd,CAA1B;MACA,QAAQ,GAAG,kBAAkB,CAAC,MAAnB,GAA4B,MAAvC;MACA,YAAY,GAAG,QAAQ,GAAG,UAA1B;IACD;;IACD,OAAO,YAAP;EACD,CAhBD;;EAkBA,IAAM,sBAAsB,GAAG,UAAC,KAAD,EAAyB,wBAAzB,EAA2D;IACxF,IAAM,YAAY,GAAG,qBAAqB,CAAC,KAAD,CAA1C;IACA,IAAM,iBAAiB,GAAG,GAAG,GAAG,IAAI,GAAG,YAAvC;IACA,IAAM,eAAe,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,YAAX,CAArC;IACA,WAAW,CAAC,KAAD,EAAQ,eAAR,EAAyB,iBAAzB,CAAX;;IACA,IAAI,CAAC,wBAAL,EAA+B;MAC7B,KAAK,CAAC,cAAN;MACA,KAAK,CAAC,eAAN;IACD;EACF,CATD;;EAWA,IAAM,uBAAuB,GAAG,UAAC,KAAD,EAA2C;IACzE,IAAI,MAAJ,EAAY;MACV,IAAM,YAAY,GAAG,qBAAqB,CAAC,KAAD,CAA1C;MACA,IAAM,QAAQ,GAAG,GAAG,GAAG,IAAI,GAAG,YAA9B;MAEA,aAAa,CAAC,qBAAd,GACE,QAAQ,IAAI,aAAa,CAAC,gBAA1B,IACA,QAAQ,GAAG,aAAa,CAAC,gBAAzB,IAA6C,aAAa,CAAC,WAAd,GAA4B,QAF3E;IAGD;;IAED,IAAI,KAAK,CAAC,IAAN,KAAe,WAAnB,EAAgC;MAC9B,WAAW,CAAC,OAAZ,CAAoB,IAApB,CACE,EAAE,CAAC,MAAD,EAAS,WAAT,EAAsB,sBAAtB,EAAqE,IAArE,CADJ,EAEE,EAAE,CAAC,MAAD,EAAS,SAAT,EAAoB,mBAApB,EAAyC,IAAzC,CAFJ;IAID,CALD,MAKO,IAAI,KAAK,CAAC,IAAN,KAAe,YAAnB,EAAiC;MACtC,WAAW,CAAC,OAAZ,CAAoB,IAApB,CACE,EAAE,CAAC,MAAD,EAAS,WAAT,EAAsB,sBAAtB,EAAqE,IAArE,CADJ,EAEE,EAAE,CAAC,MAAD,EAAS,UAAT,EAAqB,mBAArB,EAA0C,IAA1C,CAFJ;IAID;;IACD,sBAAsB,CAAC,KAAD,EAAQ,IAAR,CAAtB;EACD,CAtBD;;EAwBA,IAAM,mBAAmB,GAAG,UAAC,KAAD,EAA+B;IACzD;IACA,aAAa,CAAC,cAAd,GAA+B,SAA/B;IAEA,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAA,SAAS,CACP,KADO,EAEP,aAAa,CAAC,WAFP,EAGP,MAAM,GAAG,CAAC,aAAa,CAAC,gBAAf,EAAiC,aAAa,CAAC,WAA/C,CAAH,GAAiE,SAHhE,CAAT;IAKA,gBAAgB;EACjB,CAVD;;EAYA,IAAM,YAAY,GAAG,UAAC,KAAD,EAAwB;IAC3C,aAAa,CAAC,qBAAd,GAAsC,KAAK,CAAC,MAAN,KAAiB,kBAAkB,CAAC,OAA1E;EACD,CAFD;;EAIA,IAAM,gBAAgB,GAAG,YAAA;IACvB,WAAW,CAAC,OAAZ,CAAoB,OAApB,CAA4B,UAAA,OAAA,EAAO;MAAI,OAAA,OAAA,EAAA;IAAS,CAAhD;IACA,WAAW,CAAC,OAAZ,GAAsB,EAAtB;EACD,CAHD;;EAKA,IAAM,kBAAkB,GAAG,KAAK,CAAC,MAAN,CAA0B,IAA1B,CAA3B;EACA,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAN,CAA0B,IAA1B,CAAjB;EACA,eAAe,CACb,KADa,EAEb,MAAM,IAAI,CAAC,QAAX,GAAsB,kBAAtB,GAA2C,QAF9B,EAGb,KAHa,EAIb,MAAM,GAAG,CAAC,UAAD,EAAa,KAAb,CAAH,GAAyB,SAJlB,CAAf;EAMA,IAAM,iBAAiB,GAAG,cAAc,CAAC,QAAQ,GAAG,QAAH,GAAc,MAAM,CAAC,KAAK,CAAC,KAAP,CAAN,GAAsB,OAAtB,GAAgC,MAAvD,CAAxC;EACA,IAAM,cAAc,GAAG,cAAc,CAAC,QAAQ,GAAG,QAAH,GAAc,OAAvB,CAArC;EACA,IAAM,WAAW,GAAG,cAAc,GAAG,CAAH,GAAO,GAAzC;EACA,IAAM,YAAY,GAAG,UAAU,CAAC,KAAD,EAAQ,GAAR,EAAa,GAAb,CAA/B;EACA,IAAM,iBAAiB,GAAG,UAAU,CAAC,UAAD,EAAa,GAAb,EAAkB,GAAlB,CAApC;EACA,IAAM,mBAAmB,GAAG,UAAU,CAAC,WAAD,EAAc,GAAd,EAAmB,GAAnB,CAAtC;EACA,IAAM,kBAAkB,GAAG,MAAM,GAAG,YAAY,GAAG,iBAAlB,GAAsC,IAAI,CAAC,GAAL,CAAS,mBAAmB,GAAG,YAA/B,CAAvE;EACA,IAAM,eAAe,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,YAAf,EAA6B,MAAM,mBAAnC,CAAxB;EACA,IAAM,kBAAkB,GAAG,MAAM,GAAG,iBAAH,GAAuB,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,mBAAvB,CAAxD;EAEA,IAAM,SAAS,GAA+E;IAC5F,SAAS,EAAE,UAAU,CAAC,IADsE;IAE5F,GAAG,EAAE;EAFuF,CAA9F;EAKA,IAAM,UAAU,GAAgB;IAC9B,SAAS,EAAE,UAAU,CAAC,UADQ;IAE9B,QAAQ,EAAE,KAFoB;IAG9B,QAAQ,EAAA,QAHsB;IAI9B,OAAO,EAAE,SAAS,GAAG,SAAH,GAAe;EAJH,CAAhC;EAOA,IAAM,eAAe,GAA4B,SAAS,GACtD;IACE,SAAS,EAAE,UAAU,CAAC,UADxB;IAEE,QAAQ,EAAE,WAAW,GAAG,WAAW,CAAC,KAAD,CAAd,GAAwB,KAF/C;IAGE,QAAQ,EAAA,QAHV;IAIE,OAAO,EAAE,QAAQ,GAAG,EAAH,GAAQ;EAJ3B,CADsD,GAOtD,SAPJ;EASA,IAAM,oBAAoB,GACxB,MAAM,IAAI,SAAV,GACI;IACE,SAAS,EAAE,UAAU,CAAC,UADxB;IAEE,QAAQ,EAAE,WAAW,GAAG,WAAW,CAAC,UAAD,CAAd,GAA6B,UAFpD;IAGE,QAAQ,EAAA;EAHV,CADJ,GAMI,SAPN;EASA,IAAM,aAAa,GAAkD,cAAc,GAC/E;IACE,SAAS,EAAE,UAAU,CAAC,QADxB;IAEE,KAAK,EAAE,iBAAiB,CAAC,mBAAD;EAF1B,CAD+E,GAK/E,SALJ;EAOA,IAAM,gBAAgB,GAAsC;IAC1D,SAAS,EAAE,GAAG,CAAC,UAAU,CAAC,aAAZ,EAA2B,UAAU,CAAC,aAAtC,CAD4C;IAE1D,KAAK,EAAE,cAAc,CAAC,kBAAD;EAFqC,CAA5D;EAKA,IAAM,qBAAqB,GAAsC;IAC/D,SAAS,EAAE,GAAG,CAAC,UAAU,CAAC,aAAZ,EAA2B,UAAU,CAAC,eAAtC,CADiD;IAE/D,KAAK,EAAE,cAAc,CAAC,eAAD;EAF0C,CAAjE;EAKA,IAAM,wBAAwB,GAAsC;IAClE,SAAS,EAAE,GAAG,CAAC,UAAU,CAAC,aAAZ,EAA2B,UAAU,CAAC,eAAtC,CADoD;IAElE,KAAK,EAAE,cAAc,CAAC,kBAAD;EAF6C,CAApE;;EAKA,IAAM,WAAW,GAAA,QAAA,CAAA;IACf,iBAAiB,QADF;IAEf,IAAI,EAAE,QAFS;IAGf,QAAQ,EAAE,QAAQ,GAAG,SAAH,GAAe;EAHlB,CAAA,EAIX;IAAE,qBAAqB,CAAC;EAAxB,CAJW,CAAjB;;EAOA,IAAM,cAAc,GAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA;IAClB,EAAE,EAAA,EADgB;IAElB,SAAS,EAAE,GAAG,CAAC,UAAU,CAAC,QAAZ,EAAsB,WAAW,CAAC,SAAlC;EAFI,CAAA,EAGd,CAAC,QAAD,IAAa;IACf,WAAW,EAAE,uBADE;IAEf,YAAY,EAAE,uBAFC;IAGf,SAAS,EAAE;EAHI,CAHC,CAAA,EAQd,WAAW,IACb,cAAc,CAAuC,WAAvC,EAAoD,aAApD,EAAmE,CAAC,IAAD,EAAO,WAAP,CAAnE,CATE,CAAA,EAUd,CAAC,MAAD,IAAO,QAAA,CAAA,QAAA,CAAA,EAAA,EACN,WADM,CAAA,EACK;IACd,iBAAiB,GADH;IAEd,iBAAiB,GAFH;IAGd,iBAAiB,KAHH;IAId,kBAAkB,gBAAgB,CAAC,KAAD,CAJpB;IAKd,cAAc,SAAS,IAAI,KALb;IAMd,mBAAmB;EANL,CADL,CAVO,CAApB;;EAqBA,IAAM,WAAW,GAAG,QAAQ,GAAG,EAAH,GAAQ;IAAE,OAAO,EAAE;EAAX,CAApC;;EAEA,IAAM,UAAU,GAAA,QAAA,CAAA;IACd,GAAG,EAAE,QADS;IAEd,SAAS,EAAE,UAAU,CAAC,KAFR;IAGd,KAAK,EAAE,iBAAiB,CAAC,YAAD;EAHV,CAAA,EAIV,MAAM,IAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACL,WADK,CAAA,EAEL,WAFK,CAAA,EAEM;IACd,EAAE,EAAE,SAAO,EADG;IAEd,iBAAiB,UAFH;IAGd,iBAAiB,GAHH;IAId,iBAAiB,KAJH;IAKd,kBAAkB,gBAAgB,CAAC,KAAD,CALpB;IAMd,cAAc,UAAO,SAAS,IAAI,KAApB;EANA,CAFN,CAJI,CAAhB;;EAgBA,IAAM,oBAAoB,GAEV,MAAM,GACnB,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA;IACG,GAAG,EAAE,kBADR;IAEG,SAAS,EAAE,UAAU,CAAC,KAFzB;IAGG,KAAK,EAAE,iBAAiB,CAAC,iBAAD;EAH3B,CAAA,EAIM,WAJN,CAAA,EAKM,WALN,CAAA,EAKiB;IACd,EAAE,EAAE,SAAO,EADG;IAEd,iBAAiB,GAFH;IAGd,iBAAiB,KAHH;IAId,iBAAiB,UAJH;IAKd,kBAAkB,gBAAgB,CAAC,UAAD,CALpB;IAMd,cAAc,UAAO,SAAS,IAAI,KAApB;EANA,CALjB,CADmB,GAclB,SAhBJ;EAkBA,IAAM,cAAc,GAAsC;IACxD,SAAS,EAAE,UAAU,CAAC;EADkC,CAA1D;EAIA,IAAM,eAAe,GAA+E;IAClG,GAAG,EAAE,UAD6F;IAElG,SAAS,EAAE,UAAU,CAAC;EAF4E,CAApG;EAKA,OAAO;IACL,IAAI,EAAE,SADD;IAEL,KAAK,EAAE,UAFF;IAGL,SAAS,EAAE,cAHN;IAIL,SAAS,EAAE,cAJN;IAKL,UAAU,EAAE,eALP;IAML,eAAe,EAAE,oBANZ;IAOL,KAAK,EAAE,UAPF;IAQL,eAAe,EAAE,oBARZ;IASL,QAAQ,EAAE,aATL;IAUL,WAAW,EAAE,gBAVR;IAWL,gBAAgB,EAAE,qBAXb;IAYL,mBAAmB,EAAE,wBAZhB;IAaL,UAAU,EAAE;EAbP,CAAP;AAeD,CApaM","sourcesContent":["import * as React from 'react';\nimport { useId, useControllableValue, useConst, useSetTimeout } from '@fluentui/react-hooks';\nimport {\n  KeyCodes,\n  css,\n  getRTL,\n  getRTLSafeKeyCode,\n  on,\n  classNamesFunction,\n  getNativeProps,\n  divProperties,\n} from '@fluentui/utilities';\nimport type { ISliderProps, ISliderStyleProps, ISliderStyles } from './Slider.types';\nimport type { ILabelProps } from '../Label/index';\n\nexport const ONKEYDOWN_TIMEOUT_DURATION = 1000;\n\ninterface ISliderInternalState {\n  onKeyDownTimer: number;\n  /** For a ranged slider, whether the thumb currently being dragged is the lower value one. */\n  isAdjustingLowerValue: boolean;\n  /** Allows access to the latest `value` inside reused callbacks (to avoid stale capture issues) */\n  latestValue: number;\n  /** Allows access to the latest `lowerValue` inside reused callbacks (to avoid stale capture issues) */\n  latestLowerValue: number;\n  /**\n   * Whether the user is currently dragging the thumb and it's between step intervals.\n   * (If true, and `props.snapToStep` is falsy, transition animations will be disabled.)\n   */\n  isBetweenSteps?: boolean;\n}\n\nconst getClassNames = classNamesFunction<ISliderStyleProps, ISliderStyles>();\n\ntype Dimension = 'height' | 'width';\ntype Position = 'bottom' | 'left' | 'right';\ntype PositionOrDimension = Dimension | Position;\n/** All the possible event types for a change event */\ntype ChangeEvent = Parameters<Required<ISliderProps>['onChange']>[2];\n/** All the possible event types for a change event that's dragging the slider (mouse or touch) */\ntype DragChangeEvent = React.MouseEvent | React.TouchEvent | MouseEvent | TouchEvent;\n\nconst getSlotStyleFn = (sty: PositionOrDimension) => {\n  return (value: number) => {\n    return {\n      [sty]: `${value}%`,\n    };\n  };\n};\n\nconst getPercent = (value: number, sliderMin: number, sliderMax: number) => {\n  return sliderMax === sliderMin ? 0 : ((value - sliderMin) / (sliderMax - sliderMin)) * 100;\n};\n\nconst useComponentRef = (\n  props: ISliderProps,\n  thumb: React.RefObject<HTMLSpanElement>,\n  value: number | undefined,\n  range: [number, number] | undefined,\n) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      get value() {\n        return value;\n      },\n      get range() {\n        return range;\n      },\n      focus() {\n        if (thumb.current) {\n          thumb.current.focus();\n        }\n      },\n    }),\n    [thumb, value, range],\n  );\n};\n\nexport const useSlider = (props: ISliderProps, ref: React.Ref<HTMLDivElement>) => {\n  const {\n    step = 1,\n    className,\n    disabled = false,\n    label,\n    max = 10,\n    min = 0,\n    showValue = true,\n    buttonProps = {},\n    vertical = false,\n    snapToStep,\n    valueFormat,\n    styles,\n    theme,\n    originFromZero,\n    'aria-labelledby': ariaLabelledBy,\n    'aria-label': ariaLabel,\n    ranged,\n    onChange,\n    onChanged,\n  } = props;\n\n  const disposables = React.useRef<(() => void)[]>([]);\n  const { setTimeout, clearTimeout } = useSetTimeout();\n  const sliderLine = React.useRef<HTMLDivElement>(null);\n\n  // Casting here is necessary because useControllableValue expects the event for the change callback\n  // to extend React.SyntheticEvent, when in fact for Slider, the event could be either a React event\n  // or a native browser event depending on the context.\n  const [unclampedValue, setValue] = useControllableValue(props.value, props.defaultValue, (ev: any, v) =>\n    onChange?.(v!, ranged ? [internalState.latestLowerValue, v!] : undefined, ev),\n  ) as [number | undefined, (v: number | undefined, ev: ChangeEvent) => void];\n  const [unclampedLowerValue, setLowerValue] = useControllableValue(\n    props.lowerValue,\n    props.defaultLowerValue,\n    (ev: any, lv) => onChange?.(internalState.latestValue, [lv!, internalState.latestValue], ev),\n  ) as [number | undefined, (v: number | undefined, ev: ChangeEvent) => void];\n\n  // Ensure that value is always a number and is clamped by min/max.\n  const value = Math.max(min, Math.min(max, unclampedValue || 0));\n  const lowerValue = Math.max(min, Math.min(value, unclampedLowerValue || 0));\n\n  const internalState = useConst<ISliderInternalState>({\n    onKeyDownTimer: -1,\n    isAdjustingLowerValue: false,\n    latestValue: value,\n    latestLowerValue: lowerValue,\n  });\n  // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n  internalState.latestValue = value;\n  internalState.latestLowerValue = lowerValue;\n\n  const id = useId('Slider', props.id || buttonProps?.id);\n  const classNames = getClassNames(styles, {\n    className,\n    disabled,\n    vertical,\n    showTransitions: !snapToStep && !internalState.isBetweenSteps,\n    showValue,\n    ranged,\n    theme: theme!,\n  });\n\n  const steps = (max - min) / step;\n\n  const clearOnKeyDownTimer = (): void => {\n    clearTimeout(internalState.onKeyDownTimer);\n    internalState.onKeyDownTimer = -1;\n  };\n\n  const setOnKeyDownTimer = (event: React.KeyboardEvent) => {\n    clearOnKeyDownTimer();\n    if (onChanged) {\n      internalState.onKeyDownTimer = setTimeout(() => {\n        onChanged(\n          event,\n          internalState.latestValue,\n          ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined,\n        );\n      }, ONKEYDOWN_TIMEOUT_DURATION);\n    }\n  };\n\n  const getAriaValueText = (valueProps: number | undefined): string | undefined => {\n    const { ariaValueText } = props;\n    if (valueProps !== undefined) {\n      return ariaValueText ? ariaValueText(valueProps) : valueProps.toString();\n    }\n    return undefined;\n  };\n\n  /**\n   * Update `value` or `lowerValue`, including clamping between min/max and rounding to\n   * appropriate precision.\n   * @param newValue - New current value of the slider, possibly rounded to a whole step.\n   * @param newUnroundedValue - Like `newValue` but without the rounding to a step. If this is\n   * provided and not equal to `newValue`, `internalState.isBetweenSteps` will be set, which\n   * may cause thumb movement animations to be disabled.\n   */\n  const updateValue = (ev: any, newValue: number, newUnroundedValue?: number): void => {\n    newValue = Math.min(max, Math.max(min, newValue));\n    newUnroundedValue = newUnroundedValue !== undefined ? Math.min(max, Math.max(min, newUnroundedValue)) : undefined;\n\n    let numDec = 0;\n    if (isFinite(step)) {\n      while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {\n        numDec++;\n      }\n    }\n    // Make sure value has correct number of decimal places based on number of decimals in step\n    const roundedValue = parseFloat(newValue.toFixed(numDec));\n\n    internalState.isBetweenSteps = newUnroundedValue !== undefined && newUnroundedValue !== roundedValue;\n\n    if (ranged) {\n      // decided which thumb value to change\n      if (\n        internalState.isAdjustingLowerValue &&\n        (originFromZero ? roundedValue <= 0 : roundedValue <= internalState.latestValue)\n      ) {\n        setLowerValue(roundedValue, ev);\n      } else if (\n        !internalState.isAdjustingLowerValue &&\n        (originFromZero ? roundedValue >= 0 : roundedValue >= internalState.latestLowerValue)\n      ) {\n        setValue(roundedValue, ev);\n      }\n    } else {\n      setValue(roundedValue, ev);\n    }\n  };\n\n  const onKeyDown = (event: React.KeyboardEvent): void => {\n    let newCurrentValue = internalState.isAdjustingLowerValue\n      ? internalState.latestLowerValue\n      : internalState.latestValue;\n    let diff = 0;\n    // eslint-disable-next-line deprecation/deprecation\n    switch (event.which) {\n      case getRTLSafeKeyCode(KeyCodes.left, props.theme):\n      case KeyCodes.down:\n        diff = -step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case getRTLSafeKeyCode(KeyCodes.right, props.theme):\n      case KeyCodes.up:\n        diff = step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case KeyCodes.home:\n        newCurrentValue = min;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case KeyCodes.end:\n        newCurrentValue = max;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      default:\n        return;\n    }\n    updateValue(event, newCurrentValue + diff);\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const getPosition = (event: DragChangeEvent, verticalProp: boolean | undefined): number => {\n    let currentPosition = 0;\n    switch (event.type) {\n      case 'mousedown':\n      case 'mousemove':\n        currentPosition = !verticalProp ? (event as MouseEvent).clientX : (event as MouseEvent).clientY;\n        break;\n      case 'touchstart':\n      case 'touchmove':\n        currentPosition = !verticalProp\n          ? (event as TouchEvent).touches[0].clientX\n          : (event as TouchEvent).touches[0].clientY;\n        break;\n    }\n    return currentPosition;\n  };\n\n  const calculateCurrentSteps = (event: DragChangeEvent) => {\n    const sliderPositionRect: ClientRect = sliderLine.current!.getBoundingClientRect();\n    const sliderLength: number = !props.vertical ? sliderPositionRect.width : sliderPositionRect.height;\n    const stepLength: number = sliderLength / steps;\n    let currentSteps: number;\n    let distance: number;\n    if (!props.vertical) {\n      const left = getPosition(event, props.vertical);\n      distance = getRTL(props.theme) ? sliderPositionRect.right - left : left - sliderPositionRect.left;\n      currentSteps = distance / stepLength;\n    } else {\n      const bottom = getPosition(event, props.vertical);\n      distance = sliderPositionRect.bottom - bottom;\n      currentSteps = distance / stepLength;\n    }\n    return currentSteps;\n  };\n\n  const onMouseMoveOrTouchMove = (event: DragChangeEvent, suppressEventCancelation?: boolean): void => {\n    const currentSteps = calculateCurrentSteps(event);\n    const newUnroundedValue = min + step * currentSteps;\n    const newCurrentValue = min + step * Math.round(currentSteps);\n    updateValue(event, newCurrentValue, newUnroundedValue);\n    if (!suppressEventCancelation) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  const onMouseDownOrTouchStart = (event: React.MouseEvent | React.TouchEvent): void => {\n    if (ranged) {\n      const currentSteps = calculateCurrentSteps(event);\n      const newValue = min + step * currentSteps;\n\n      internalState.isAdjustingLowerValue =\n        newValue <= internalState.latestLowerValue ||\n        newValue - internalState.latestLowerValue <= internalState.latestValue - newValue;\n    }\n\n    if (event.type === 'mousedown') {\n      disposables.current.push(\n        on(window, 'mousemove', onMouseMoveOrTouchMove as (ev: Event) => void, true),\n        on(window, 'mouseup', onMouseUpOrTouchEnd, true),\n      );\n    } else if (event.type === 'touchstart') {\n      disposables.current.push(\n        on(window, 'touchmove', onMouseMoveOrTouchMove as (ev: Event) => void, true),\n        on(window, 'touchend', onMouseUpOrTouchEnd, true),\n      );\n    }\n    onMouseMoveOrTouchMove(event, true);\n  };\n\n  const onMouseUpOrTouchEnd = (event: MouseEvent | TouchEvent): void => {\n    // Done adjusting, so clear this value\n    internalState.isBetweenSteps = undefined;\n\n    onChanged?.(\n      event,\n      internalState.latestValue,\n      ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined,\n    );\n    disposeListeners();\n  };\n\n  const onThumbFocus = (event: React.FocusEvent): void => {\n    internalState.isAdjustingLowerValue = event.target === lowerValueThumbRef.current;\n  };\n\n  const disposeListeners = (): void => {\n    disposables.current.forEach(dispose => dispose());\n    disposables.current = [];\n  };\n\n  const lowerValueThumbRef = React.useRef<HTMLElement>(null);\n  const thumbRef = React.useRef<HTMLElement>(null);\n  useComponentRef(\n    props,\n    ranged && !vertical ? lowerValueThumbRef : thumbRef,\n    value,\n    ranged ? [lowerValue, value] : undefined,\n  );\n  const getPositionStyles = getSlotStyleFn(vertical ? 'bottom' : getRTL(props.theme) ? 'right' : 'left');\n  const getTrackStyles = getSlotStyleFn(vertical ? 'height' : 'width');\n  const originValue = originFromZero ? 0 : min;\n  const valuePercent = getPercent(value, min, max);\n  const lowerValuePercent = getPercent(lowerValue, min, max);\n  const originPercentOfLine = getPercent(originValue, min, max);\n  const activeSectionWidth = ranged ? valuePercent - lowerValuePercent : Math.abs(originPercentOfLine - valuePercent);\n  const topSectionWidth = Math.min(100 - valuePercent, 100 - originPercentOfLine);\n  const bottomSectionWidth = ranged ? lowerValuePercent : Math.min(valuePercent, originPercentOfLine);\n\n  const rootProps: React.HTMLAttributes<HTMLDivElement> & React.RefAttributes<HTMLDivElement> = {\n    className: classNames.root,\n    ref: ref,\n  };\n\n  const labelProps: ILabelProps = {\n    className: classNames.titleLabel,\n    children: label,\n    disabled,\n    htmlFor: ariaLabel ? undefined : id,\n  };\n\n  const valueLabelProps: ILabelProps | undefined = showValue\n    ? {\n        className: classNames.valueLabel,\n        children: valueFormat ? valueFormat(value) : value,\n        disabled,\n        htmlFor: disabled ? id : undefined,\n      }\n    : undefined;\n\n  const lowerValueLabelProps: ILabelProps | undefined =\n    ranged && showValue\n      ? {\n          className: classNames.valueLabel,\n          children: valueFormat ? valueFormat(lowerValue) : lowerValue,\n          disabled,\n        }\n      : undefined;\n\n  const zeroTickProps: React.HTMLAttributes<HTMLElement> | undefined = originFromZero\n    ? {\n        className: classNames.zeroTick,\n        style: getPositionStyles(originPercentOfLine),\n      }\n    : undefined;\n\n  const trackActiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.activeSection),\n    style: getTrackStyles(activeSectionWidth),\n  };\n\n  const trackTopInactiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(topSectionWidth),\n  };\n\n  const trackBottomInactiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(bottomSectionWidth),\n  };\n\n  const sliderProps: React.HTMLAttributes<HTMLElement> = {\n    'aria-disabled': disabled,\n    role: 'slider',\n    tabIndex: disabled ? undefined : 0,\n    ...({ 'data-is-focusable': !disabled } as any),\n  };\n\n  const sliderBoxProps: React.HTMLAttributes<HTMLElement> = {\n    id,\n    className: css(classNames.slideBox, buttonProps.className),\n    ...(!disabled && {\n      onMouseDown: onMouseDownOrTouchStart,\n      onTouchStart: onMouseDownOrTouchStart,\n      onKeyDown: onKeyDown,\n    }),\n    ...(buttonProps &&\n      getNativeProps<React.HTMLAttributes<HTMLDivElement>>(buttonProps, divProperties, ['id', 'className'])),\n    ...(!ranged && {\n      ...sliderProps,\n      'aria-valuemin': min,\n      'aria-valuemax': max,\n      'aria-valuenow': value,\n      'aria-valuetext': getAriaValueText(value),\n      'aria-label': ariaLabel || label,\n      'aria-labelledby': ariaLabelledBy,\n    }),\n  };\n\n  const onFocusProp = disabled ? {} : { onFocus: onThumbFocus };\n\n  const thumbProps: React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement> = {\n    ref: thumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(valuePercent),\n    ...(ranged && {\n      ...sliderProps,\n      ...onFocusProp,\n      id: `max-${id}`,\n      'aria-valuemin': lowerValue,\n      'aria-valuemax': max,\n      'aria-valuenow': value,\n      'aria-valuetext': getAriaValueText(value),\n      'aria-label': `max ${ariaLabel || label}`,\n    }),\n  };\n\n  const lowerValueThumbProps:\n    | (React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement>)\n    | undefined = ranged\n    ? {\n        ref: lowerValueThumbRef,\n        className: classNames.thumb,\n        style: getPositionStyles(lowerValuePercent),\n        ...sliderProps,\n        ...onFocusProp,\n        id: `min-${id}`,\n        'aria-valuemin': min,\n        'aria-valuemax': value,\n        'aria-valuenow': lowerValue,\n        'aria-valuetext': getAriaValueText(lowerValue),\n        'aria-label': `min ${ariaLabel || label}`,\n      }\n    : undefined;\n\n  const containerProps: React.HTMLAttributes<HTMLElement> = {\n    className: classNames.container,\n  };\n\n  const sliderLineProps: React.HTMLAttributes<HTMLDivElement> & React.RefAttributes<HTMLDivElement> = {\n    ref: sliderLine,\n    className: classNames.line,\n  };\n\n  return {\n    root: rootProps,\n    label: labelProps,\n    sliderBox: sliderBoxProps,\n    container: containerProps,\n    valueLabel: valueLabelProps,\n    lowerValueLabel: lowerValueLabelProps,\n    thumb: thumbProps,\n    lowerValueThumb: lowerValueThumbProps,\n    zeroTick: zeroTickProps,\n    activeTrack: trackActiveProps,\n    topInactiveTrack: trackTopInactiveProps,\n    bottomInactiveTrack: trackBottomInactiveProps,\n    sliderLine: sliderLineProps,\n  };\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}