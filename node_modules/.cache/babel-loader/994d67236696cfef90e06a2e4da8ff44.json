{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport { initializeComponentRef, Async, divProperties, getNativeProps, getId, assign, hasOverflow, portalContainsElement, classNamesFunction, KeyCodes } from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nvar getClassNames = classNamesFunction();\n\nvar TooltipHostBase =\n/** @class */\nfunction (_super) {\n  __extends(TooltipHostBase, _super); // Constructor\n\n\n  function TooltipHostBase(props) {\n    var _this = _super.call(this, props) || this; // The wrapping div that gets the hover events\n\n\n    _this._tooltipHost = React.createRef();\n    _this._defaultTooltipId = getId('tooltip');\n\n    _this.show = function () {\n      _this._toggleTooltip(true);\n    };\n\n    _this.dismiss = function () {\n      _this._hideTooltip();\n    };\n\n    _this._getTargetElement = function () {\n      if (!_this._tooltipHost.current) {\n        return undefined;\n      }\n\n      var overflowMode = _this.props.overflowMode; // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n      // to the parent element, otherwise it might look off.\n\n      if (overflowMode !== undefined) {\n        switch (overflowMode) {\n          case TooltipOverflowMode.Parent:\n            return _this._tooltipHost.current.parentElement;\n\n          case TooltipOverflowMode.Self:\n            return _this._tooltipHost.current;\n        }\n      }\n\n      return _this._tooltipHost.current;\n    };\n\n    _this._onTooltipFocus = function (ev) {\n      if (_this._ignoreNextFocusEvent) {\n        _this._ignoreNextFocusEvent = false;\n        return;\n      }\n\n      _this._onTooltipMouseEnter(ev);\n    };\n\n    _this._onTooltipBlur = function (ev) {\n      // The focused element gets a blur event when the document loses focus\n      // (e.g. switching tabs in the browser), but we don't want to show the\n      // tooltip again when the document gets focus back. Handle this case by\n      // checking if the blurred element is still the document's activeElement,\n      // and ignoring when it next gets focus back.\n      // See https://github.com/microsoft/fluentui/issues/13541\n      _this._ignoreNextFocusEvent = (document === null || document === void 0 ? void 0 : document.activeElement) === ev.target;\n\n      _this._hideTooltip();\n    }; // Show Tooltip\n\n\n    _this._onTooltipMouseEnter = function (ev) {\n      var _a = _this.props,\n          overflowMode = _a.overflowMode,\n          delay = _a.delay;\n\n      if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== _this) {\n        TooltipHostBase._currentVisibleTooltip.dismiss();\n      }\n\n      TooltipHostBase._currentVisibleTooltip = _this;\n\n      if (overflowMode !== undefined) {\n        var overflowElement = _this._getTargetElement();\n\n        if (overflowElement && !hasOverflow(overflowElement)) {\n          return;\n        }\n      }\n\n      if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {\n        // Do not show tooltip when target is inside a portal relative to TooltipHost.\n        return;\n      }\n\n      _this._clearDismissTimer();\n\n      _this._clearOpenTimer();\n\n      if (delay !== TooltipDelay.zero) {\n        var delayTime = _this._getDelayTime(delay); // non-null assertion because we set it in `defaultProps`\n\n\n        _this._openTimerId = _this._async.setTimeout(function () {\n          _this._toggleTooltip(true);\n        }, delayTime);\n      } else {\n        _this._toggleTooltip(true);\n      }\n    }; // Hide Tooltip\n\n\n    _this._onTooltipMouseLeave = function (ev) {\n      var closeDelay = _this.props.closeDelay;\n\n      _this._clearDismissTimer();\n\n      _this._clearOpenTimer();\n\n      if (closeDelay) {\n        _this._dismissTimerId = _this._async.setTimeout(function () {\n          _this._toggleTooltip(false);\n        }, closeDelay);\n      } else {\n        _this._toggleTooltip(false);\n      }\n\n      if (TooltipHostBase._currentVisibleTooltip === _this) {\n        TooltipHostBase._currentVisibleTooltip = undefined;\n      }\n    };\n\n    _this._onTooltipKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {\n        _this._hideTooltip();\n\n        ev.stopPropagation();\n      }\n    };\n\n    _this._clearDismissTimer = function () {\n      _this._async.clearTimeout(_this._dismissTimerId);\n    };\n\n    _this._clearOpenTimer = function () {\n      _this._async.clearTimeout(_this._openTimerId);\n    }; // Hide Tooltip\n\n\n    _this._hideTooltip = function () {\n      _this._clearOpenTimer();\n\n      _this._clearDismissTimer();\n\n      _this._toggleTooltip(false);\n    };\n\n    _this._toggleTooltip = function (isTooltipVisible) {\n      if (_this.state.isTooltipVisible !== isTooltipVisible) {\n        _this.setState({\n          isTooltipVisible: isTooltipVisible\n        }, function () {\n          return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible);\n        });\n      }\n    };\n\n    _this._getDelayTime = function (delay) {\n      switch (delay) {\n        case TooltipDelay.medium:\n          return 300;\n\n        case TooltipDelay.long:\n          return 500;\n\n        default:\n          return 0;\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      isAriaPlaceholderRendered: false,\n      isTooltipVisible: false\n    };\n    _this._async = new Async(_this);\n    return _this;\n  } // Render\n\n\n  TooltipHostBase.prototype.render = function () {\n    var _a = this.props,\n        calloutProps = _a.calloutProps,\n        children = _a.children,\n        content = _a.content,\n        directionalHint = _a.directionalHint,\n        directionalHintForRTL = _a.directionalHintForRTL,\n        className = _a.hostClassName,\n        id = _a.id,\n        // eslint-disable-next-line deprecation/deprecation\n    _b = _a.setAriaDescribedBy,\n        // eslint-disable-next-line deprecation/deprecation\n    setAriaDescribedBy = _b === void 0 ? true : _b,\n        tooltipProps = _a.tooltipProps,\n        styles = _a.styles,\n        theme = _a.theme;\n    this._classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var isTooltipVisible = this.state.isTooltipVisible;\n    var tooltipId = id || this._defaultTooltipId;\n    var isContentPresent = !!(content || tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent());\n    var showTooltip = isTooltipVisible && isContentPresent;\n    var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;\n    return React.createElement(\"div\", __assign({\n      className: this._classNames.root,\n      ref: this._tooltipHost\n    }, {\n      onFocusCapture: this._onTooltipFocus\n    }, {\n      onBlurCapture: this._onTooltipBlur\n    }, {\n      onMouseEnter: this._onTooltipMouseEnter,\n      onMouseLeave: this._onTooltipMouseLeave,\n      onKeyDown: this._onTooltipKeyDown,\n      role: \"none\",\n      \"aria-describedby\": ariaDescribedBy\n    }), children, showTooltip && React.createElement(Tooltip, __assign({\n      id: tooltipId + \"--tooltip\",\n      content: content,\n      targetElement: this._getTargetElement(),\n      directionalHint: directionalHint,\n      directionalHintForRTL: directionalHintForRTL,\n      calloutProps: assign({}, calloutProps, {\n        onDismiss: this._hideTooltip,\n        onMouseEnter: this._onTooltipMouseEnter,\n        onMouseLeave: this._onTooltipMouseLeave\n      }),\n      onMouseEnter: this._onTooltipMouseEnter,\n      onMouseLeave: this._onTooltipMouseLeave\n    }, getNativeProps(this.props, divProperties, ['id']), tooltipProps)), React.createElement(\"div\", {\n      hidden: true,\n      id: tooltipId,\n      style: hiddenContentStyle\n    }, content));\n  };\n\n  TooltipHostBase.prototype.componentWillUnmount = function () {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  };\n\n  TooltipHostBase.defaultProps = {\n    delay: TooltipDelay.medium\n  };\n  return TooltipHostBase;\n}(React.Component);\n\nexport { TooltipHostBase };","map":{"version":3,"sources":["components/Tooltip/TooltipHost.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport {\n  initializeComponentRef,\n  Async,\n  divProperties,\n  getNativeProps,\n  getId,\n  assign,\n  hasOverflow,\n  portalContainsElement,\n  classNamesFunction,\n  KeyCodes,\n} from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nimport type { ITooltipHostProps, ITooltipHostStyles, ITooltipHostStyleProps, ITooltipHost } from './TooltipHost.types';\n\nexport interface ITooltipHostState {\n  /** @deprecated No longer used internally */\n  isAriaPlaceholderRendered: boolean;\n  isTooltipVisible: boolean;\n}\n\nconst getClassNames = classNamesFunction<ITooltipHostStyleProps, ITooltipHostStyles>();\n\nexport class TooltipHostBase extends React.Component<ITooltipHostProps, ITooltipHostState> implements ITooltipHost {\n  public static defaultProps = {\n    delay: TooltipDelay.medium,\n  };\n\n  private static _currentVisibleTooltip: ITooltipHost | undefined;\n\n  // The wrapping div that gets the hover events\n  private _tooltipHost = React.createRef<HTMLDivElement>();\n\n  private _classNames: { [key in keyof ITooltipHostStyles]: string };\n  private _async: Async;\n  private _dismissTimerId: number;\n  private _openTimerId: number;\n  private _defaultTooltipId = getId('tooltip');\n  private _ignoreNextFocusEvent: boolean;\n\n  // Constructor\n  constructor(props: ITooltipHostProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      isAriaPlaceholderRendered: false, // eslint-disable-line react/no-unused-state\n      isTooltipVisible: false,\n    };\n\n    this._async = new Async(this);\n  }\n\n  // Render\n  public render(): JSX.Element {\n    const {\n      calloutProps,\n      children,\n      content,\n      directionalHint,\n      directionalHintForRTL,\n      hostClassName: className,\n      id,\n      // eslint-disable-next-line deprecation/deprecation\n      setAriaDescribedBy = true,\n      tooltipProps,\n      styles,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    const { isTooltipVisible } = this.state;\n    const tooltipId = id || this._defaultTooltipId;\n    const isContentPresent = !!(\n      content ||\n      (tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent())\n    );\n    const showTooltip = isTooltipVisible && isContentPresent;\n    const ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;\n\n    return (\n      <div\n        className={this._classNames.root}\n        ref={this._tooltipHost}\n        {...{ onFocusCapture: this._onTooltipFocus }}\n        {...{ onBlurCapture: this._onTooltipBlur }}\n        onMouseEnter={this._onTooltipMouseEnter}\n        onMouseLeave={this._onTooltipMouseLeave}\n        onKeyDown={this._onTooltipKeyDown}\n        role=\"none\"\n        // WARNING: aria-describedby on this node provides no value, since it isn't allowed generic elements\n        aria-describedby={ariaDescribedBy}\n      >\n        {children}\n        {showTooltip && (\n          <Tooltip\n            id={`${tooltipId}--tooltip`}\n            content={content}\n            targetElement={this._getTargetElement()}\n            directionalHint={directionalHint}\n            directionalHintForRTL={directionalHintForRTL}\n            calloutProps={assign({}, calloutProps, {\n              onDismiss: this._hideTooltip,\n              onMouseEnter: this._onTooltipMouseEnter,\n              onMouseLeave: this._onTooltipMouseLeave,\n            })}\n            onMouseEnter={this._onTooltipMouseEnter}\n            onMouseLeave={this._onTooltipMouseLeave}\n            {...getNativeProps(this.props, divProperties, ['id'])} // Make sure we use the id above\n            {...tooltipProps}\n          />\n        )}\n        <div hidden={true} id={tooltipId} style={hiddenContentStyle as React.CSSProperties}>\n          {content}\n        </div>\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  }\n\n  public show = (): void => {\n    this._toggleTooltip(true);\n  };\n\n  public dismiss = (): void => {\n    this._hideTooltip();\n  };\n\n  private _getTargetElement = (): HTMLElement | undefined => {\n    if (!this._tooltipHost.current) {\n      return undefined;\n    }\n\n    const { overflowMode } = this.props;\n\n    // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n    // to the parent element, otherwise it might look off.\n    if (overflowMode !== undefined) {\n      switch (overflowMode) {\n        case TooltipOverflowMode.Parent:\n          return this._tooltipHost.current.parentElement!;\n\n        case TooltipOverflowMode.Self:\n          return this._tooltipHost.current;\n      }\n    }\n\n    return this._tooltipHost.current;\n  };\n\n  private _onTooltipFocus = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this._ignoreNextFocusEvent) {\n      this._ignoreNextFocusEvent = false;\n      return;\n    }\n\n    this._onTooltipMouseEnter(ev);\n  };\n\n  private _onTooltipBlur = (ev: React.FocusEvent<HTMLElement>) => {\n    // The focused element gets a blur event when the document loses focus\n    // (e.g. switching tabs in the browser), but we don't want to show the\n    // tooltip again when the document gets focus back. Handle this case by\n    // checking if the blurred element is still the document's activeElement,\n    // and ignoring when it next gets focus back.\n    // See https://github.com/microsoft/fluentui/issues/13541\n    this._ignoreNextFocusEvent = document?.activeElement === ev.target;\n\n    this._hideTooltip();\n  };\n\n  // Show Tooltip\n  private _onTooltipMouseEnter = (ev: any): void => {\n    const { overflowMode, delay } = this.props;\n\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {\n      TooltipHostBase._currentVisibleTooltip.dismiss();\n    }\n    TooltipHostBase._currentVisibleTooltip = this;\n\n    if (overflowMode !== undefined) {\n      const overflowElement = this._getTargetElement();\n      if (overflowElement && !hasOverflow(overflowElement)) {\n        return;\n      }\n    }\n\n    if (ev.target && portalContainsElement(ev.target as HTMLElement, this._getTargetElement())) {\n      // Do not show tooltip when target is inside a portal relative to TooltipHost.\n      return;\n    }\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (delay !== TooltipDelay.zero) {\n      const delayTime = this._getDelayTime(delay!); // non-null assertion because we set it in `defaultProps`\n\n      this._openTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(true);\n      }, delayTime);\n    } else {\n      this._toggleTooltip(true);\n    }\n  };\n\n  // Hide Tooltip\n  private _onTooltipMouseLeave = (ev: any): void => {\n    const { closeDelay } = this.props;\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (closeDelay) {\n      this._dismissTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(false);\n      }, closeDelay);\n    } else {\n      this._toggleTooltip(false);\n    }\n\n    if (TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n  };\n\n  private _onTooltipKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    // eslint-disable-next-line deprecation/deprecation\n    if ((ev.which === KeyCodes.escape || ev.ctrlKey) && this.state.isTooltipVisible) {\n      this._hideTooltip();\n      ev.stopPropagation();\n    }\n  };\n\n  private _clearDismissTimer = (): void => {\n    this._async.clearTimeout(this._dismissTimerId);\n  };\n\n  private _clearOpenTimer = (): void => {\n    this._async.clearTimeout(this._openTimerId);\n  };\n\n  // Hide Tooltip\n  private _hideTooltip = (): void => {\n    this._clearOpenTimer();\n    this._clearDismissTimer();\n    this._toggleTooltip(false);\n  };\n\n  private _toggleTooltip = (isTooltipVisible: boolean): void => {\n    if (this.state.isTooltipVisible !== isTooltipVisible) {\n      this.setState(\n        { isTooltipVisible },\n        () => this.props.onTooltipToggle && this.props.onTooltipToggle(isTooltipVisible),\n      );\n    }\n  };\n\n  private _getDelayTime = (delay: TooltipDelay): number => {\n    switch (delay) {\n      case TooltipDelay.medium:\n        return 300;\n      case TooltipDelay.long:\n        return 500;\n      default:\n        return 0;\n    }\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}