{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, focusAsync, modalize, on } from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nvar COMPONENT_NAME = 'FocusTrapZone';\n\nvar useComponentRef = function (componentRef, previouslyFocusedElement, focus) {\n  React.useImperativeHandle(componentRef, function () {\n    return {\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n\n      focus: focus\n    };\n  }, [previouslyFocusedElement, focus]);\n};\n\nexport var FocusTrapZone = React.forwardRef(function (props, ref) {\n  var root = React.useRef(null);\n  var firstBumper = React.useRef(null);\n  var lastBumper = React.useRef(null);\n  var mergedRootRef = useMergedRefs(root, ref);\n  var id = useId(undefined, props.id);\n  var doc = useDocument();\n  var divProps = getNativeProps(props, divProperties);\n  var internalState = useConst(function () {\n    return {\n      previouslyFocusedElementOutsideTrapZone: undefined,\n      previouslyFocusedElementInTrapZone: undefined,\n      disposeFocusHandler: undefined,\n      disposeClickHandler: undefined,\n      hasFocus: false,\n      unmodalize: undefined\n    };\n  });\n  var ariaLabelledBy = props.ariaLabelledBy,\n      className = props.className,\n      children = props.children,\n      componentRef = props.componentRef,\n      disabled = props.disabled,\n      _a = props.disableFirstFocus,\n      disableFirstFocus = _a === void 0 ? false : _a,\n      _b = props.disabled,\n      currentDisabledValue = _b === void 0 ? false : _b,\n      elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n      _c = props.forceFocusInsideTrap,\n      forceFocusInsideTrap = _c === void 0 ? true : _c,\n      focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement,\n      // eslint-disable-next-line deprecation/deprecation\n  firstFocusableSelector = props.firstFocusableSelector,\n      firstFocusableTarget = props.firstFocusableTarget,\n      ignoreExternalFocusing = props.ignoreExternalFocusing,\n      _d = props.isClickableOutsideFocusTrap,\n      isClickableOutsideFocusTrap = _d === void 0 ? false : _d,\n      onFocus = props.onFocus,\n      onBlur = props.onBlur,\n      onFocusCapture = props.onFocusCapture,\n      onBlurCapture = props.onBlurCapture,\n      enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n\n    },\n    tabIndex: disabled ? -1 : 0,\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true\n  };\n  var focus = React.useCallback(function () {\n    if (focusPreviouslyFocusedInnerElement && internalState.previouslyFocusedElementInTrapZone && elementContains(root.current, internalState.previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusAsync(internalState.previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var firstFocusableChild = null;\n\n    if (root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        firstFocusableChild = firstFocusableTarget(root.current);\n      } else if (focusSelector) {\n        firstFocusableChild = root.current.querySelector('.' + focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!firstFocusableChild) {\n        firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);\n      }\n    }\n\n    if (firstFocusableChild) {\n      focusAsync(firstFocusableChild);\n    }\n  }, [firstFocusableSelector, firstFocusableTarget, focusPreviouslyFocusedInnerElement, internalState]);\n  var onBumperFocus = React.useCallback(function (isFirstBumper) {\n    if (disabled) {\n      return;\n    }\n\n    var currentBumper = isFirstBumper === internalState.hasFocus ? lastBumper.current : firstBumper.current;\n\n    if (root.current) {\n      var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, currentBumper, true, false) : getFirstTabbable(root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n          // This can happen when FTZ contains no tabbable elements.\n          // focus will take care of finding a focusable element in FTZ.\n          focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  }, [disabled, focus, internalState]);\n  var onRootBlurCapture = React.useCallback(function (ev) {\n    onBlurCapture === null || onBlurCapture === void 0 ? void 0 : onBlurCapture(ev);\n    var relatedTarget = ev.relatedTarget;\n\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the root\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = doc.activeElement;\n    }\n\n    if (!elementContains(root.current, relatedTarget)) {\n      internalState.hasFocus = false;\n    }\n  }, [doc, internalState, onBlurCapture]);\n  var onRootFocusCapture = React.useCallback(function (ev) {\n    onFocusCapture === null || onFocusCapture === void 0 ? void 0 : onFocusCapture(ev);\n\n    if (ev.target === firstBumper.current) {\n      onBumperFocus(true);\n    } else if (ev.target === lastBumper.current) {\n      onBumperFocus(false);\n    }\n\n    internalState.hasFocus = true;\n\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = ev.target;\n    }\n  }, [onFocusCapture, internalState, onBumperFocus]);\n  var returnFocusToInitiator = React.useCallback(function () {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function (value) {\n      return id !== value;\n    });\n\n    if (doc) {\n      var activeElement = doc.activeElement;\n\n      if (!ignoreExternalFocusing && internalState.previouslyFocusedElementOutsideTrapZone && typeof internalState.previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(root.current, activeElement) || activeElement === doc.body)) {\n        if (!(internalState.previouslyFocusedElementOutsideTrapZone === firstBumper.current || internalState.previouslyFocusedElementOutsideTrapZone === lastBumper.current)) {\n          focusAsync(internalState.previouslyFocusedElementOutsideTrapZone);\n        }\n      }\n    }\n  }, [doc, id, ignoreExternalFocusing, internalState]);\n  var forceFocusInTrap = React.useCallback(function (ev) {\n    if (disabled) {\n      return;\n    }\n\n    if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n      var focusedElement = ev.target;\n\n      if (!elementContains(root.current, focusedElement)) {\n        focus();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  }, [disabled, id, focus, internalState]);\n  var forceClickInTrap = React.useCallback(function (ev) {\n    if (disabled) {\n      return;\n    }\n\n    if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n      var clickedElement = ev.target;\n\n      if (clickedElement && !elementContains(root.current, clickedElement)) {\n        focus();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  }, [disabled, id, focus, internalState]);\n  var updateEventHandlers = React.useCallback(function () {\n    if (forceFocusInsideTrap && !internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler = on(window, 'focus', forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !internalState.disposeClickHandler) {\n      internalState.disposeClickHandler = on(window, 'click', forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n  }, [forceClickInTrap, forceFocusInTrap, forceFocusInsideTrap, isClickableOutsideFocusTrap, internalState]); // Updates eventHandlers and cleans up focusStack when the component unmounts.\n\n  React.useEffect(function () {\n    var parentRoot = root.current;\n    updateEventHandlers();\n    return function () {\n      // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n      if (!disabled || forceFocusInsideTrap || !elementContains(parentRoot, doc === null || doc === void 0 ? void 0 : doc.activeElement)) {\n        returnFocusToInitiator();\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only run on mount.\n  }, [updateEventHandlers]); // Updates focusStack and the previouslyFocusedElementOutsideTrapZone on prop change.\n\n  React.useEffect(function () {\n    var newForceFocusInsideTrap = forceFocusInsideTrap !== undefined ? forceFocusInsideTrap : true;\n    var newDisabled = disabled !== undefined ? disabled : false; // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n\n    if (!newDisabled || newForceFocusInsideTrap) {\n      if (currentDisabledValue) {\n        return;\n      }\n\n      FocusTrapZone.focusStack.push(id);\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : doc.activeElement;\n\n      if (!disableFirstFocus && !elementContains(root.current, internalState.previouslyFocusedElementOutsideTrapZone)) {\n        focus();\n      }\n\n      if (!internalState.unmodalize && root.current && enableAriaHiddenSiblings) {\n        internalState.unmodalize = modalize(root.current);\n      }\n    } else if (!newForceFocusInsideTrap || newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      returnFocusToInitiator();\n\n      if (internalState.unmodalize) {\n        internalState.unmodalize();\n      }\n    }\n\n    if (elementToFocusOnDismiss && internalState.previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [elementToFocusOnDismiss, forceFocusInsideTrap, disabled]); // Cleanup lifecyle method for internalState.\n\n  useUnmount(function () {\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n\n    if (internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (internalState.unmodalize) {\n      internalState.unmodalize();\n    } // Dispose of element references so the DOM Nodes can be garbage-collected\n\n\n    delete internalState.previouslyFocusedElementInTrapZone;\n    delete internalState.previouslyFocusedElementOutsideTrapZone;\n  });\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focus);\n  return React.createElement(\"div\", __assign({}, divProps, {\n    className: className,\n    ref: mergedRootRef,\n    \"aria-labelledby\": ariaLabelledBy,\n    onFocusCapture: onRootFocusCapture,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onBlurCapture: onRootBlurCapture\n  }), React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: firstBumper\n  })), children, React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: lastBumper\n  })));\n});\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];","map":{"version":3,"sources":["components/FocusTrapZone/FocusTrapZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  focusAsync,\n  modalize,\n  on,\n} from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nimport type { IRefObject } from '../../Utilities';\nimport type { IFocusTrapZoneProps, IFocusTrapZone } from './FocusTrapZone.types';\n\ninterface IFocusTrapZoneInternalState {\n  disposeFocusHandler: (() => void) | undefined;\n  disposeClickHandler: (() => void) | undefined;\n  previouslyFocusedElementOutsideTrapZone: HTMLElement | undefined;\n  previouslyFocusedElementInTrapZone: HTMLElement | undefined;\n  hasFocus: boolean;\n  unmodalize: (() => void) | undefined;\n}\n\nconst COMPONENT_NAME = 'FocusTrapZone';\n\nconst useComponentRef = (\n  componentRef: IRefObject<IFocusTrapZone> | undefined,\n  previouslyFocusedElement: HTMLElement | undefined,\n  focus: () => void,\n) => {\n  React.useImperativeHandle(\n    componentRef,\n    () => ({\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n      focus,\n    }),\n    [previouslyFocusedElement, focus],\n  );\n};\n\nexport const FocusTrapZone: React.FunctionComponent<IFocusTrapZoneProps> & {\n  focusStack: string[];\n} = React.forwardRef<HTMLElement, IFocusTrapZoneProps>((props, ref) => {\n  const root = React.useRef<HTMLDivElement>(null);\n  const firstBumper = React.useRef<HTMLDivElement>(null);\n  const lastBumper = React.useRef<HTMLDivElement>(null);\n  const mergedRootRef = useMergedRefs(root, ref) as React.Ref<HTMLDivElement>;\n  const id = useId(undefined, props.id);\n  const doc = useDocument();\n  const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties);\n\n  const internalState = useConst<IFocusTrapZoneInternalState>(() => ({\n    previouslyFocusedElementOutsideTrapZone: undefined,\n    previouslyFocusedElementInTrapZone: undefined,\n    disposeFocusHandler: undefined,\n    disposeClickHandler: undefined,\n    hasFocus: false,\n    unmodalize: undefined,\n  }));\n\n  const {\n    ariaLabelledBy,\n    className,\n    children,\n    componentRef,\n    disabled,\n    disableFirstFocus = false,\n    disabled: currentDisabledValue = false,\n    elementToFocusOnDismiss,\n    forceFocusInsideTrap = true,\n    focusPreviouslyFocusedInnerElement,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector,\n    firstFocusableTarget,\n    ignoreExternalFocusing,\n    isClickableOutsideFocusTrap = false,\n    onFocus,\n    onBlur,\n    onFocusCapture,\n    onBlurCapture,\n    enableAriaHiddenSiblings,\n  } = props;\n\n  const bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n    },\n    tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true,\n  } as React.HTMLAttributes<HTMLDivElement>;\n\n  const focus = React.useCallback(() => {\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      internalState.previouslyFocusedElementInTrapZone &&\n      elementContains(root.current, internalState.previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusAsync(internalState.previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string'\n        ? firstFocusableSelector\n        : firstFocusableSelector && firstFocusableSelector();\n\n    let firstFocusableChild: HTMLElement | null = null;\n\n    if (root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        firstFocusableChild = firstFocusableTarget(root.current);\n      } else if (focusSelector) {\n        firstFocusableChild = root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!firstFocusableChild) {\n        firstFocusableChild = getNextElement(\n          root.current,\n          root.current.firstChild as HTMLElement,\n          false,\n          false,\n          false,\n          true,\n        );\n      }\n    }\n    if (firstFocusableChild) {\n      focusAsync(firstFocusableChild);\n    }\n  }, [firstFocusableSelector, firstFocusableTarget, focusPreviouslyFocusedInnerElement, internalState]);\n\n  const onBumperFocus = React.useCallback(\n    (isFirstBumper: boolean) => {\n      if (disabled) {\n        return;\n      }\n\n      const currentBumper = (isFirstBumper === internalState.hasFocus\n        ? lastBumper.current\n        : firstBumper.current) as HTMLElement;\n\n      if (root.current) {\n        const nextFocusable =\n          isFirstBumper === internalState.hasFocus\n            ? getLastTabbable(root.current, currentBumper, true, false)\n            : getFirstTabbable(root.current, currentBumper, true, false);\n\n        if (nextFocusable) {\n          if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n            // This can happen when FTZ contains no tabbable elements.\n            // focus will take care of finding a focusable element in FTZ.\n            focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    },\n    [disabled, focus, internalState],\n  );\n\n  const onRootBlurCapture = React.useCallback(\n    (ev: React.FocusEvent<HTMLDivElement>) => {\n      onBlurCapture?.(ev);\n      let relatedTarget = ev.relatedTarget;\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the root\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = doc!.activeElement as Element;\n      }\n      if (!elementContains(root.current, relatedTarget as HTMLElement)) {\n        internalState.hasFocus = false;\n      }\n    },\n    [doc, internalState, onBlurCapture],\n  );\n\n  const onRootFocusCapture = React.useCallback(\n    (ev: React.FocusEvent<HTMLDivElement>) => {\n      onFocusCapture?.(ev);\n\n      if (ev.target === firstBumper.current) {\n        onBumperFocus(true);\n      } else if (ev.target === lastBumper.current) {\n        onBumperFocus(false);\n      }\n\n      internalState.hasFocus = true;\n\n      if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        internalState.previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n      }\n    },\n    [onFocusCapture, internalState, onBumperFocus],\n  );\n\n  const returnFocusToInitiator = React.useCallback((): void => {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter((value: any) => {\n      return id !== value;\n    });\n\n    if (doc) {\n      const activeElement = doc.activeElement as HTMLElement;\n      if (\n        !ignoreExternalFocusing &&\n        internalState.previouslyFocusedElementOutsideTrapZone &&\n        typeof internalState.previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n        (elementContains(root.current, activeElement) || activeElement === doc.body)\n      ) {\n        if (\n          !(\n            internalState.previouslyFocusedElementOutsideTrapZone === firstBumper.current ||\n            internalState.previouslyFocusedElementOutsideTrapZone === lastBumper.current\n          )\n        ) {\n          focusAsync(internalState.previouslyFocusedElementOutsideTrapZone);\n        }\n      }\n    }\n  }, [doc, id, ignoreExternalFocusing, internalState]);\n\n  const forceFocusInTrap = React.useCallback(\n    (ev: FocusEvent): void => {\n      if (disabled) {\n        return;\n      }\n      if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n        const focusedElement = ev.target as HTMLElement;\n        if (!elementContains(root.current, focusedElement)) {\n          focus();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    },\n    [disabled, id, focus, internalState],\n  );\n\n  const forceClickInTrap = React.useCallback(\n    (ev: MouseEvent): void => {\n      if (disabled) {\n        return;\n      }\n      if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n        const clickedElement = ev.target as HTMLElement;\n        if (clickedElement && !elementContains(root.current, clickedElement)) {\n          focus();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    },\n    [disabled, id, focus, internalState],\n  );\n\n  const updateEventHandlers = React.useCallback((): void => {\n    if (forceFocusInsideTrap && !internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler = on(window, 'focus', forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !internalState.disposeClickHandler) {\n      internalState.disposeClickHandler = on(window, 'click', forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n  }, [forceClickInTrap, forceFocusInTrap, forceFocusInsideTrap, isClickableOutsideFocusTrap, internalState]);\n\n  // Updates eventHandlers and cleans up focusStack when the component unmounts.\n  React.useEffect(() => {\n    const parentRoot = root.current;\n    updateEventHandlers();\n    return () => {\n      // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n      if (!disabled || forceFocusInsideTrap || !elementContains(parentRoot, doc?.activeElement as HTMLElement)) {\n        returnFocusToInitiator();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only run on mount.\n  }, [updateEventHandlers]);\n\n  // Updates focusStack and the previouslyFocusedElementOutsideTrapZone on prop change.\n  React.useEffect(() => {\n    const newForceFocusInsideTrap = forceFocusInsideTrap !== undefined ? forceFocusInsideTrap : true;\n    const newDisabled = disabled !== undefined ? disabled : false;\n\n    // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n    if (!newDisabled || newForceFocusInsideTrap) {\n      if (currentDisabledValue) {\n        return;\n      }\n\n      FocusTrapZone.focusStack.push(id);\n\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n        ? elementToFocusOnDismiss\n        : (doc!.activeElement as HTMLElement);\n      if (!disableFirstFocus && !elementContains(root.current, internalState.previouslyFocusedElementOutsideTrapZone)) {\n        focus();\n      }\n      if (!internalState.unmodalize && root.current && enableAriaHiddenSiblings) {\n        internalState.unmodalize = modalize(root.current);\n      }\n    } else if (!newForceFocusInsideTrap || newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      returnFocusToInitiator();\n      if (internalState.unmodalize) {\n        internalState.unmodalize();\n      }\n    }\n\n    if (elementToFocusOnDismiss && internalState.previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [elementToFocusOnDismiss, forceFocusInsideTrap, disabled]);\n\n  // Cleanup lifecyle method for internalState.\n  useUnmount(() => {\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n    if (internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n    if (internalState.unmodalize) {\n      internalState.unmodalize();\n    }\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n    delete internalState.previouslyFocusedElementOutsideTrapZone;\n  });\n\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focus);\n\n  return (\n    <div\n      {...divProps}\n      className={className}\n      ref={mergedRootRef}\n      aria-labelledby={ariaLabelledBy}\n      onFocusCapture={onRootFocusCapture}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      onBlurCapture={onRootBlurCapture}\n    >\n      <div {...bumperProps} ref={firstBumper} />\n      {children}\n      <div {...bumperProps} ref={lastBumper} />\n    </div>\n  );\n}) as any;\n\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}