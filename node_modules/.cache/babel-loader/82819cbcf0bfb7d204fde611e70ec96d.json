{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport { getDateRangeArray, getDayGrid, getBoundedDateRange, isRestrictedDate, DAYS_IN_WEEK, compareDates, DateRangeType } from '@fluentui/date-time-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\nvar getClassNames = classNamesFunction();\n\nfunction useDayRefs() {\n  var daysRef = React.useRef({});\n\n  var getSetRefCallback = function (dayKey) {\n    return function (element) {\n      if (element === null) {\n        delete daysRef.current[dayKey];\n      } else {\n        daysRef.current[dayKey] = element;\n      }\n    };\n  };\n\n  return [daysRef, getSetRefCallback];\n}\n\nfunction useWeeks(props, onSelectDate, getSetRefCallback) {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  var weeks = React.useMemo(function () {\n    var _a;\n\n    var weeksGrid = getDayGrid(props);\n    var firstVisibleDay = weeksGrid[1][0].originalDate;\n    var lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    var markedDays = ((_a = props.getMarkedDays) === null || _a === void 0 ? void 0 : _a.call(props, firstVisibleDay, lastVisibleDay)) || [];\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n\n    var returnValue = [];\n\n    for (var weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      var week = [];\n\n      var _loop_1 = function (dayIndex) {\n        var day = weeksGrid[weekIndex][dayIndex];\n\n        var dayInfo = __assign(__assign({\n          onSelected: function () {\n            return onSelectDate(day.originalDate);\n          },\n          setRef: getSetRefCallback(day.key)\n        }, day), {\n          isMarked: day.isMarked || (markedDays === null || markedDays === void 0 ? void 0 : markedDays.some(function (markedDay) {\n            return compareDates(day.originalDate, markedDay);\n          }))\n        });\n\n        week.push(dayInfo);\n      };\n\n      for (var dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        _loop_1(dayIndex);\n      }\n\n      returnValue.push(week);\n    }\n\n    return returnValue; // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n  return weeks;\n}\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\n\n\nfunction useAnimateBackwards(weeks) {\n  var previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction useWeekCornerStyles(props) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  var getWeekCornerStyles = function (classNames, initialWeeks) {\n    var weekCornersStyled = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n           in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n    // cut off the animation transition weeks\n\n    var weeks = initialWeeks.slice(1, initialWeeks.length - 1); // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n\n    weeks.forEach(function (week, weekIndex) {\n      week.forEach(function (day, dayIndex) {\n        var above = weeks[weekIndex - 1] && weeks[weekIndex - 1][dayIndex] && isInSameHoverRange(weeks[weekIndex - 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex - 1][dayIndex].isSelected, day.isSelected);\n        var below = weeks[weekIndex + 1] && weeks[weekIndex + 1][dayIndex] && isInSameHoverRange(weeks[weekIndex + 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex + 1][dayIndex].isSelected, day.isSelected);\n        var left = weeks[weekIndex][dayIndex - 1] && isInSameHoverRange(weeks[weekIndex][dayIndex - 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex - 1].isSelected, day.isSelected);\n        var right = weeks[weekIndex][dayIndex + 1] && isInSameHoverRange(weeks[weekIndex][dayIndex + 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex + 1].isSelected, day.isSelected);\n        var style = [];\n        style.push(calculateRoundedStyles(classNames, above, below, left, right));\n        style.push(calculateBorderStyles(classNames, above, below, left, right));\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style.join(' ');\n      });\n    });\n    return weekCornersStyled;\n  };\n\n  var calculateRoundedStyles = function (classNames, above, below, left, right) {\n    var style = [];\n    var roundedTopLeft = !above && !left;\n    var roundedTopRight = !above && !right;\n    var roundedBottomLeft = !below && !left;\n    var roundedBottomRight = !below && !right;\n\n    if (roundedTopLeft) {\n      style.push(getRTL() ? classNames.topRightCornerDate : classNames.topLeftCornerDate);\n    }\n\n    if (roundedTopRight) {\n      style.push(getRTL() ? classNames.topLeftCornerDate : classNames.topRightCornerDate);\n    }\n\n    if (roundedBottomLeft) {\n      style.push(getRTL() ? classNames.bottomRightCornerDate : classNames.bottomLeftCornerDate);\n    }\n\n    if (roundedBottomRight) {\n      style.push(getRTL() ? classNames.bottomLeftCornerDate : classNames.bottomRightCornerDate);\n    }\n\n    return style.join(' ');\n  };\n\n  var calculateBorderStyles = function (classNames, above, below, left, right) {\n    var style = [];\n\n    if (!above) {\n      style.push(classNames.datesAbove);\n    }\n\n    if (!below) {\n      style.push(classNames.datesBelow);\n    }\n\n    if (!left) {\n      style.push(getRTL() ? classNames.datesRight : classNames.datesLeft);\n    }\n\n    if (!right) {\n      style.push(getRTL() ? classNames.datesLeft : classNames.datesRight);\n    }\n\n    return style.join(' ');\n  };\n\n  var isInSameHoverRange = function (date1, date2, date1Selected, date2Selected) {\n    var dateRangeType = props.dateRangeType,\n        firstDayOfWeek = props.firstDayOfWeek,\n        workWeekDays = props.workWeekDays; // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n\n    var dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType; // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n\n    var dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    } // otherwise, both must be unselected, so check the dateRange\n\n\n    return dateRange.filter(function (date) {\n      return date.getTime() === date2.getTime();\n    }).length > 0;\n  };\n\n  return [getWeekCornerStyles, calculateRoundedStyles];\n}\n\nexport var CalendarDayGridBase = function (props) {\n  var navigatedDayRef = React.useRef(null);\n  var activeDescendantId = useId();\n\n  var onSelectDate = function (selectedDate) {\n    var _a, _b;\n\n    var firstDayOfWeek = props.firstDayOfWeek,\n        minDate = props.minDate,\n        maxDate = props.maxDate,\n        workWeekDays = props.workWeekDays,\n        daysToSelectInDayView = props.daysToSelectInDayView,\n        restrictedDates = props.restrictedDates;\n    var restrictedDatesOptions = {\n      minDate: minDate,\n      maxDate: maxDate,\n      restrictedDates: restrictedDates\n    };\n    var dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n    dateRange = dateRange.filter(function (d) {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n    (_a = props.onSelectDate) === null || _a === void 0 ? void 0 : _a.call(props, selectedDate, dateRange);\n    (_b = props.onNavigateDate) === null || _b === void 0 ? void 0 : _b.call(props, selectedDate, true);\n  };\n\n  var _a = useDayRefs(),\n      daysRef = _a[0],\n      getSetRefCallback = _a[1];\n\n  var weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  var animateBackwards = useAnimateBackwards(weeks);\n\n  var _b = useWeekCornerStyles(props),\n      getWeekCornerStyles = _b[0],\n      calculateRoundedStyles = _b[1];\n\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function () {\n        var _a, _b;\n\n        (_b = (_a = navigatedDayRef.current) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n      }\n    };\n  }, []);\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n\n  var getDayInfosInRangeOfDay = function (dayToCompare) {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    var dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays); // gets all the dates for the given date range type that are in the same date range as the given day\n\n    var dateRange = getDateRangeArray(dayToCompare.originalDate, dateRangeHoverType, props.firstDayOfWeek, props.workWeekDays, props.daysToSelectInDayView).map(function (date) {\n      return date.getTime();\n    }); // gets all the day refs for the given dates\n\n    var dayInfosInRange = weeks.reduce(function (accumulatedValue, currentWeek) {\n      return accumulatedValue.concat(currentWeek.filter(function (weekDay) {\n        return dateRange.indexOf(weekDay.originalDate.getTime()) !== -1;\n      }));\n    }, []);\n    return dayInfosInRange;\n  };\n\n  var getRefsFromDayInfos = function (dayInfosInRange) {\n    var dayRefs = [];\n    dayRefs = dayInfosInRange.map(function (dayInfo) {\n      return daysRef.current[dayInfo.key];\n    });\n    return dayRefs;\n  };\n\n  var styles = props.styles,\n      theme = props.theme,\n      className = props.className,\n      dateRangeType = props.dateRangeType,\n      showWeekNumbers = props.showWeekNumbers,\n      labelledBy = props.labelledBy,\n      lightenDaysOutsideNavigatedMonth = props.lightenDaysOutsideNavigatedMonth,\n      animationDirection = props.animationDirection;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    dateRangeType: dateRangeType,\n    showWeekNumbers: showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection: animationDirection,\n    animateBackwards: animateBackwards\n  }); // When the month is highlighted get the corner dates so that styles can be added to them\n\n  var weekCorners = getWeekCornerStyles(classNames, weeks);\n  var partialWeekProps = {\n    weeks: weeks,\n    navigatedDayRef: navigatedDayRef,\n    calculateRoundedStyles: calculateRoundedStyles,\n    activeDescendantId: activeDescendantId,\n    classNames: classNames,\n    weekCorners: weekCorners,\n    getDayInfosInRangeOfDay: getDayInfosInRangeOfDay,\n    getRefsFromDayInfos: getRefsFromDayInfos\n  };\n  return React.createElement(FocusZone, {\n    className: classNames.wrapper\n  }, React.createElement(\"table\", {\n    className: classNames.table,\n    \"aria-multiselectable\": \"false\",\n    \"aria-labelledby\": labelledBy,\n    \"aria-activedescendant\": activeDescendantId,\n    role: \"grid\"\n  }, React.createElement(\"tbody\", null, React.createElement(CalendarMonthHeaderRow, __assign({}, props, {\n    classNames: classNames,\n    weeks: weeks\n  })), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[0],\n    weekIndex: -1,\n    rowClassName: classNames.firstTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })), weeks.slice(1, weeks.length - 1).map(function (week, weekIndex) {\n    return React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n      key: weekIndex,\n      week: week,\n      weekIndex: weekIndex,\n      rowClassName: classNames.weekRow\n    }));\n  }), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[weeks.length - 1],\n    weekIndex: -2,\n    rowClassName: classNames.lastTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })))));\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\n\nfunction getDateRangeTypeToUse(dateRangeType, workWeekDays) {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    var sortedWWDays = workWeekDays.slice().sort();\n    var isContiguous = true;\n\n    for (var i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n\n  return dateRangeType;\n}","map":{"version":3,"sources":["components/CalendarDayGrid/CalendarDayGrid.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport {\n  getDateRangeArray,\n  getDayGrid,\n  getBoundedDateRange,\n  isRestrictedDate,\n  DAYS_IN_WEEK,\n  compareDates,\n  DateRangeType,\n  DayOfWeek,\n} from '@fluentui/date-time-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\nimport type { IDay } from '@fluentui/date-time-utilities';\nimport type {\n  ICalendarDayGridProps,\n  ICalendarDayGridStyleProps,\n  ICalendarDayGridStyles,\n} from './CalendarDayGrid.types';\nimport type { IProcessedStyleSet } from '@fluentui/style-utilities';\n\nconst getClassNames = classNamesFunction<ICalendarDayGridStyleProps, ICalendarDayGridStyles>();\n\nexport interface IWeekCorners {\n  [key: string]: string;\n}\n\nexport interface IDayInfo extends IDay {\n  onSelected: () => void;\n  setRef(element: HTMLElement | null): void;\n}\n\nfunction useDayRefs() {\n  const daysRef = React.useRef<Record<string, HTMLElement>>({});\n\n  const getSetRefCallback = (dayKey: string) => (element: HTMLElement | null) => {\n    if (element === null) {\n      delete daysRef.current[dayKey];\n    } else {\n      daysRef.current[dayKey] = element;\n    }\n  };\n\n  return [daysRef, getSetRefCallback] as const;\n}\n\nfunction useWeeks(\n  props: ICalendarDayGridProps,\n  onSelectDate: (date: Date) => void,\n  getSetRefCallback: (dayKey: string) => (element: HTMLElement | null) => void,\n): IDayInfo[][] {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  const weeks = React.useMemo((): IDayInfo[][] => {\n    const weeksGrid = getDayGrid(props);\n\n    const firstVisibleDay = weeksGrid[1][0].originalDate;\n    const lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    const markedDays = props.getMarkedDays?.(firstVisibleDay, lastVisibleDay) || [];\n\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n    const returnValue: IDayInfo[][] = [];\n\n    for (let weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      const week: IDayInfo[] = [];\n      for (let dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        const day = weeksGrid[weekIndex][dayIndex];\n        const dayInfo: IDayInfo = {\n          onSelected: () => onSelectDate(day.originalDate),\n          setRef: getSetRefCallback(day.key),\n          ...day,\n          isMarked: day.isMarked || markedDays?.some(markedDay => compareDates(day.originalDate, markedDay)),\n        };\n\n        week.push(dayInfo);\n      }\n      returnValue.push(week);\n    }\n\n    return returnValue;\n    // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n\n  return weeks;\n}\n\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\nfunction useAnimateBackwards(weeks: IDayInfo[][]): boolean | undefined {\n  const previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction useWeekCornerStyles(props: ICalendarDayGridProps) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  const getWeekCornerStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    initialWeeks: IDayInfo[][],\n  ): IWeekCorners => {\n    const weekCornersStyled: { [key: string]: string } = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n\n      in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n\n    // cut off the animation transition weeks\n    const weeks = initialWeeks.slice(1, initialWeeks.length - 1);\n\n    // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n    weeks.forEach((week: IDayInfo[], weekIndex: number) => {\n      week.forEach((day: IDayInfo, dayIndex: number) => {\n        const above =\n          weeks[weekIndex - 1] &&\n          weeks[weekIndex - 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex - 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex - 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const below =\n          weeks[weekIndex + 1] &&\n          weeks[weekIndex + 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex + 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex + 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const left =\n          weeks[weekIndex][dayIndex - 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex - 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex - 1].isSelected,\n            day.isSelected,\n          );\n        const right =\n          weeks[weekIndex][dayIndex + 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex + 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex + 1].isSelected,\n            day.isSelected,\n          );\n\n        const style = [];\n        style.push(calculateRoundedStyles(classNames, above, below, left, right));\n        style.push(calculateBorderStyles(classNames, above, below, left, right));\n\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style.join(' ');\n      });\n    });\n\n    return weekCornersStyled;\n  };\n\n  const calculateRoundedStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    above: boolean,\n    below: boolean,\n    left: boolean,\n    right: boolean,\n  ): string => {\n    const style = [];\n    const roundedTopLeft = !above && !left;\n    const roundedTopRight = !above && !right;\n    const roundedBottomLeft = !below && !left;\n    const roundedBottomRight = !below && !right;\n\n    if (roundedTopLeft) {\n      style.push(getRTL() ? classNames.topRightCornerDate : classNames.topLeftCornerDate);\n    }\n    if (roundedTopRight) {\n      style.push(getRTL() ? classNames.topLeftCornerDate : classNames.topRightCornerDate);\n    }\n    if (roundedBottomLeft) {\n      style.push(getRTL() ? classNames.bottomRightCornerDate : classNames.bottomLeftCornerDate);\n    }\n    if (roundedBottomRight) {\n      style.push(getRTL() ? classNames.bottomLeftCornerDate : classNames.bottomRightCornerDate);\n    }\n\n    return style.join(' ');\n  };\n\n  const calculateBorderStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    above: boolean,\n    below: boolean,\n    left: boolean,\n    right: boolean,\n  ): string => {\n    const style = [];\n\n    if (!above) {\n      style.push(classNames.datesAbove);\n    }\n    if (!below) {\n      style.push(classNames.datesBelow);\n    }\n    if (!left) {\n      style.push(getRTL() ? classNames.datesRight : classNames.datesLeft);\n    }\n    if (!right) {\n      style.push(getRTL() ? classNames.datesLeft : classNames.datesRight);\n    }\n\n    return style.join(' ');\n  };\n\n  const isInSameHoverRange = (date1: Date, date2: Date, date1Selected: boolean, date2Selected: boolean): boolean => {\n    const { dateRangeType, firstDayOfWeek, workWeekDays } = props;\n\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType;\n\n    // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n    const dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    }\n\n    // otherwise, both must be unselected, so check the dateRange\n    return dateRange.filter((date: Date) => date.getTime() === date2.getTime()).length > 0;\n  };\n\n  return [getWeekCornerStyles, calculateRoundedStyles] as const;\n}\n\nexport const CalendarDayGridBase: React.FunctionComponent<ICalendarDayGridProps> = props => {\n  const navigatedDayRef = React.useRef<HTMLTableCellElement>(null) as React.MutableRefObject<HTMLTableCellElement>;\n\n  const activeDescendantId = useId();\n\n  const onSelectDate = (selectedDate: Date): void => {\n    const { firstDayOfWeek, minDate, maxDate, workWeekDays, daysToSelectInDayView, restrictedDates } = props;\n    const restrictedDatesOptions = { minDate, maxDate, restrictedDates };\n\n    let dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n\n    dateRange = dateRange.filter((d: Date) => {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n\n    props.onSelectDate?.(selectedDate, dateRange);\n    props.onNavigateDate?.(selectedDate, true);\n  };\n\n  const [daysRef, getSetRefCallback] = useDayRefs();\n\n  const weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  const animateBackwards = useAnimateBackwards(weeks);\n  const [getWeekCornerStyles, calculateRoundedStyles] = useWeekCornerStyles(props);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        navigatedDayRef.current?.focus?.();\n      },\n    }),\n    [],\n  );\n\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n  const getDayInfosInRangeOfDay = (dayToCompare: IDayInfo): IDayInfo[] => {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);\n\n    // gets all the dates for the given date range type that are in the same date range as the given day\n    const dateRange = getDateRangeArray(\n      dayToCompare.originalDate,\n      dateRangeHoverType,\n      props.firstDayOfWeek,\n      props.workWeekDays,\n      props.daysToSelectInDayView,\n    ).map((date: Date) => date.getTime());\n\n    // gets all the day refs for the given dates\n    const dayInfosInRange = weeks.reduce((accumulatedValue: IDayInfo[], currentWeek: IDayInfo[]) => {\n      return accumulatedValue.concat(\n        currentWeek.filter((weekDay: IDayInfo) => dateRange.indexOf(weekDay.originalDate.getTime()) !== -1),\n      );\n    }, []);\n\n    return dayInfosInRange;\n  };\n\n  const getRefsFromDayInfos = (dayInfosInRange: IDayInfo[]): (HTMLElement | null)[] => {\n    let dayRefs: (HTMLElement | null)[] = [];\n    dayRefs = dayInfosInRange.map((dayInfo: IDayInfo) => daysRef.current[dayInfo.key]);\n\n    return dayRefs;\n  };\n\n  const {\n    styles,\n    theme,\n    className,\n    dateRangeType,\n    showWeekNumbers,\n    labelledBy,\n    lightenDaysOutsideNavigatedMonth,\n    animationDirection,\n  } = props;\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    className: className,\n    dateRangeType: dateRangeType,\n    showWeekNumbers: showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth:\n      lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection: animationDirection,\n    animateBackwards: animateBackwards,\n  });\n\n  // When the month is highlighted get the corner dates so that styles can be added to them\n  const weekCorners: IWeekCorners = getWeekCornerStyles(classNames, weeks!);\n  const partialWeekProps = {\n    weeks,\n    navigatedDayRef,\n    calculateRoundedStyles,\n    activeDescendantId,\n    classNames,\n    weekCorners,\n    getDayInfosInRangeOfDay,\n    getRefsFromDayInfos,\n  } as const;\n\n  return (\n    <FocusZone className={classNames.wrapper}>\n      <table\n        className={classNames.table}\n        aria-multiselectable=\"false\"\n        aria-labelledby={labelledBy}\n        aria-activedescendant={activeDescendantId}\n        role=\"grid\"\n      >\n        <tbody>\n          <CalendarMonthHeaderRow {...props} classNames={classNames} weeks={weeks} />\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks[0]}\n            weekIndex={-1}\n            rowClassName={classNames.firstTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n          {weeks!.slice(1, weeks!.length - 1).map((week: IDayInfo[], weekIndex: number) => (\n            <CalendarGridRow\n              {...props}\n              {...partialWeekProps}\n              key={weekIndex}\n              week={week}\n              weekIndex={weekIndex}\n              rowClassName={classNames.weekRow}\n            />\n          ))}\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks![weeks!.length - 1]}\n            weekIndex={-2}\n            rowClassName={classNames.lastTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n        </tbody>\n      </table>\n    </FocusZone>\n  );\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\nfunction getDateRangeTypeToUse(dateRangeType: DateRangeType, workWeekDays: DayOfWeek[] | undefined): DateRangeType {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    const sortedWWDays = workWeekDays.slice().sort();\n    let isContiguous = true;\n    for (let i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n\n  return dateRangeType;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}