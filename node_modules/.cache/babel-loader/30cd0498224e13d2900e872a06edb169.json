{"ast":null,"code":"import { __assign, __decorate, __extends, __rest, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { Autofill } from '../../Autofill';\nimport { initializeComponentRef, css, customizable, divProperties, findElementRecursive, findIndex, focusAsync, getId, getNativeProps, isIOS, isMac, KeyCodes, shallowCompare, mergeAriaAttributeValues, warnMutuallyExclusive, Async, EventGroup, getPropsWithDefaults } from '../../Utilities';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames } from './ComboBox.classNames';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../SelectableOption';\nimport { CommandButton, IconButton } from '../../Button';\nimport { useMergedRefs } from '@fluentui/react-hooks';\nimport { getChildren } from '@fluentui/utilities';\nvar SearchDirection;\n\n(function (SearchDirection) {\n  SearchDirection[SearchDirection[\"backward\"] = -1] = \"backward\";\n  SearchDirection[SearchDirection[\"none\"] = 0] = \"none\";\n  SearchDirection[SearchDirection[\"forward\"] = 1] = \"forward\";\n})(SearchDirection || (SearchDirection = {}));\n\nvar HoverStatus;\n\n(function (HoverStatus) {\n  /** Used when the user was hovering and has since moused out of the menu items */\n  HoverStatus[HoverStatus[\"clearAll\"] = -2] = \"clearAll\";\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n\n  HoverStatus[HoverStatus[\"default\"] = -1] = \"default\";\n})(HoverStatus || (HoverStatus = {}));\n\nvar ScrollIdleDelay = 250;\n/* ms */\n\nvar TouchIdleDelay = 500;\n/* ms */\n\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\n\nvar ReadOnlyPendingAutoCompleteTimeout = 1000;\n/* ms */\n\n/**\n * Internal component that is used to wrap all ComboBox options.\n * This is used to customize when we want to re-render components,\n * so we don't re-render every option every time render is executed.\n */\n\nvar ComboBoxOptionWrapper = React.memo(function (_a) {\n  var render = _a.render;\n  return render();\n}, function (_a, _b) {\n  var oldRender = _a.render,\n      oldProps = __rest(_a, [\"render\"]);\n\n  var newRender = _b.render,\n      newProps = __rest(_b, [\"render\"]); // The render function will always be different, so we ignore that prop\n\n\n  return shallowCompare(oldProps, newProps);\n});\nvar COMPONENT_NAME = 'ComboBox';\nvar DEFAULT_PROPS = {\n  options: [],\n  allowFreeform: false,\n  autoComplete: 'on',\n  buttonIconProps: {\n    iconName: 'ChevronDown'\n  }\n};\n\nfunction useOptionsState(_a) {\n  var options = _a.options,\n      defaultSelectedKey = _a.defaultSelectedKey,\n      selectedKey = _a.selectedKey;\n  /** The currently selected indices */\n\n  var _b = React.useState(function () {\n    return getSelectedIndices(options, buildDefaultSelectedKeys(defaultSelectedKey, selectedKey));\n  }),\n      selectedIndices = _b[0],\n      setSelectedIndices = _b[1];\n  /** The options currently available for the callout */\n\n\n  var _c = React.useState(options),\n      currentOptions = _c[0],\n      setCurrentOptions = _c[1];\n  /** This value is used for the autocomplete hint value */\n\n\n  var _d = React.useState(),\n      suggestedDisplayValue = _d[0],\n      setSuggestedDisplayValue = _d[1];\n\n  React.useEffect(function () {\n    if (selectedKey !== undefined) {\n      var selectedKeys = buildSelectedKeys(selectedKey);\n      var indices = getSelectedIndices(options, selectedKeys);\n      setSelectedIndices(indices);\n    }\n\n    setCurrentOptions(options);\n  }, [options, selectedKey]);\n  React.useEffect(function () {\n    if (selectedKey === null) {\n      setSuggestedDisplayValue(undefined);\n    }\n  }, [selectedKey]);\n  return [selectedIndices, setSelectedIndices, currentOptions, setCurrentOptions, suggestedDisplayValue, setSuggestedDisplayValue];\n}\n\nexport var ComboBox = React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var _a = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults),\n      ref = _a.ref,\n      props = __rest(_a, [\"ref\"]);\n\n  var rootRef = React.useRef(null);\n  var mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n  var _b = useOptionsState(props),\n      selectedIndices = _b[0],\n      setSelectedIndices = _b[1],\n      currentOptions = _b[2],\n      setCurrentOptions = _b[3],\n      suggestedDisplayValue = _b[4],\n      setSuggestedDisplayValue = _b[5];\n\n  return React.createElement(ComboBoxInternal, __assign({}, props, {\n    hoisted: {\n      mergedRootRef: mergedRootRef,\n      rootRef: rootRef,\n      selectedIndices: selectedIndices,\n      setSelectedIndices: setSelectedIndices,\n      currentOptions: currentOptions,\n      setCurrentOptions: setCurrentOptions,\n      suggestedDisplayValue: suggestedDisplayValue,\n      setSuggestedDisplayValue: setSuggestedDisplayValue\n    }\n  }));\n});\nComboBox.displayName = COMPONENT_NAME;\n/**\n * Depth-first search to find the first descendant element where the match function returns true.\n * @param element - element to start searching at\n * @param match - the function that determines if the element is a match\n * @returns the matched element or null no match was found\n */\n\nfunction findFirstDescendant(element, match) {\n  var children = getChildren(element); // For loop is used because forEach cannot be stopped.\n\n  for (var index = 0; index < children.length; index++) {\n    var child = children[index];\n\n    if (match(child)) {\n      return child;\n    }\n\n    var candidate = findFirstDescendant(child, match);\n\n    if (candidate) {\n      return candidate;\n    }\n  }\n\n  return null;\n}\n\nvar ComboBoxInternal =\n/** @class */\nfunction (_super) {\n  __extends(ComboBoxInternal, _super);\n\n  function ComboBoxInternal(props) {\n    var _this = _super.call(this, props) || this;\n    /** The input aspect of the combo box */\n\n\n    _this._autofill = React.createRef();\n    /** The wrapping div of the input and button */\n\n    _this._comboBoxWrapper = React.createRef();\n    /** The callout element */\n\n    _this._comboBoxMenu = React.createRef();\n    /** The menu item element that is currently selected */\n\n    _this._selectedElement = React.createRef();\n    /**\n     * {@inheritdoc}\n     */\n\n    _this.focus = function (shouldOpenOnFocus, useFocusAsync) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this._autofill.current) {\n        if (useFocusAsync) {\n          focusAsync(_this._autofill.current);\n        } else {\n          _this._autofill.current.focus();\n        }\n\n        if (shouldOpenOnFocus) {\n          _this.setState({\n            isOpen: true\n          });\n        }\n      } // Programmatically setting focus means that there is nothing else that needs to be done\n      // Focus is now contained\n\n\n      if (!_this._hasFocus()) {\n        _this.setState({\n          focusState: 'focused'\n        });\n      }\n    };\n    /**\n     * Close menu callout if it is open\n     */\n\n\n    _this.dismissMenu = function () {\n      var isOpen = _this.state.isOpen;\n      isOpen && _this.setState({\n        isOpen: false\n      });\n    };\n    /**\n     * componentWillReceiveProps handler for the auto fill component\n     * Checks/updates the input value to set, if needed\n     * @param defaultVisibleValue - the defaultVisibleValue that got passed\n     *  in to the auto fill's componentWillReceiveProps\n     * @returns - the updated value to set, if needed\n     */\n\n\n    _this._onUpdateValueInAutofillWillReceiveProps = function () {\n      var comboBox = _this._autofill.current;\n\n      if (!comboBox) {\n        return null;\n      }\n\n      if (comboBox.value === null || comboBox.value === undefined) {\n        return null;\n      }\n\n      var visibleValue = normalizeToString(_this._currentVisibleValue);\n\n      if (comboBox.value !== visibleValue) {\n        return visibleValue;\n      }\n\n      return comboBox.value;\n    };\n\n    _this._renderComboBoxWrapper = function (multiselectAccessibleText, errorMessageId) {\n      var _a = _this.props,\n          label = _a.label,\n          disabled = _a.disabled,\n          ariaLabel = _a.ariaLabel,\n          _b = _a.ariaDescribedBy,\n          ariaDescribedBy = _b === void 0 ? _this.props['aria-describedby'] : _b,\n          required = _a.required,\n          errorMessage = _a.errorMessage,\n          buttonIconProps = _a.buttonIconProps,\n          _c = _a.isButtonAriaHidden,\n          isButtonAriaHidden = _c === void 0 ? true : _c,\n          title = _a.title,\n          placeholderProp = _a.placeholder,\n          tabIndex = _a.tabIndex,\n          autofill = _a.autofill,\n          iconButtonProps = _a.iconButtonProps,\n          suggestedDisplayValue = _a.hoisted.suggestedDisplayValue;\n      var isOpen = _this.state.isOpen; // If the combo box has focus, is multiselect, and has a display string, then use that placeholder\n      // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n      // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n      // should be removed and the multiselect combo box should behave like a picker.\n\n      var placeholder = _this._hasFocus() && _this.props.multiSelect && multiselectAccessibleText ? multiselectAccessibleText : placeholderProp;\n      var labelledBy = [_this.props['aria-labelledby'], label && _this._id + '-label'].join(' ').trim();\n      return React.createElement(\"div\", {\n        \"data-ktp-target\": true,\n        ref: _this._comboBoxWrapper,\n        id: _this._id + 'wrapper',\n        className: _this._classNames.root,\n        \"aria-owns\": isOpen ? _this._id + '-list' : undefined\n      }, React.createElement(Autofill, __assign({\n        \"data-ktp-execute-target\": true,\n        \"data-is-interactable\": !disabled,\n        componentRef: _this._autofill,\n        id: _this._id + '-input',\n        className: _this._classNames.input,\n        type: \"text\",\n        onFocus: _this._onFocus,\n        onBlur: _this._onBlur,\n        onKeyDown: _this._onInputKeyDown,\n        onKeyUp: _this._onInputKeyUp,\n        onClick: _this._onAutofillClick,\n        onTouchStart: _this._onTouchStart,\n        onInputValueChange: _this._onInputChange,\n        \"aria-expanded\": isOpen,\n        \"aria-autocomplete\": _this._getAriaAutoCompleteValue(),\n        role: \"combobox\",\n        readOnly: disabled,\n        \"aria-labelledby\": labelledBy ? labelledBy : undefined,\n        \"aria-label\": ariaLabel && !label ? ariaLabel : undefined,\n        \"aria-describedby\": errorMessage !== undefined ? mergeAriaAttributeValues(ariaDescribedBy, errorMessageId) : ariaDescribedBy,\n        \"aria-activedescendant\": _this._getAriaActiveDescendantValue(),\n        \"aria-required\": required,\n        \"aria-disabled\": disabled,\n        \"aria-controls\": isOpen ? _this._id + '-list' : undefined,\n        spellCheck: false,\n        defaultVisibleValue: _this._currentVisibleValue,\n        suggestedDisplayValue: suggestedDisplayValue,\n        updateValueInWillReceiveProps: _this._onUpdateValueInAutofillWillReceiveProps,\n        shouldSelectFullInputValueInComponentDidUpdate: _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate,\n        title: title,\n        preventValueSelection: !_this._hasFocus(),\n        placeholder: placeholder,\n        tabIndex: disabled ? -1 : tabIndex\n      }, autofill)), React.createElement(IconButton, __assign({\n        className: 'ms-ComboBox-CaretDown-button',\n        styles: _this._getCaretButtonStyles(),\n        role: \"presentation\",\n        \"aria-hidden\": isButtonAriaHidden,\n        \"data-is-focusable\": false,\n        tabIndex: -1,\n        onClick: _this._onComboBoxClick,\n        onBlur: _this._onBlur,\n        iconProps: buttonIconProps,\n        disabled: disabled,\n        checked: isOpen\n      }, iconButtonProps)));\n    };\n    /**\n     * componentDidUpdate handler for the auto fill component\n     *\n     * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n     * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n     * @returns - should the full value of the input be selected?\n     * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n     */\n\n\n    _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate = function () {\n      return _this._currentVisibleValue === _this.props.hoisted.suggestedDisplayValue;\n    };\n    /**\n     * Get the correct value to pass to the input\n     * to show to the user based off of the current props and state\n     * @returns the value to pass to the input\n     */\n\n\n    _this._getVisibleValue = function () {\n      var _a = _this.props,\n          text = _a.text,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete,\n          _b = _a.hoisted,\n          suggestedDisplayValue = _b.suggestedDisplayValue,\n          selectedIndices = _b.selectedIndices,\n          currentOptions = _b.currentOptions;\n      var _c = _this.state,\n          currentPendingValueValidIndex = _c.currentPendingValueValidIndex,\n          currentPendingValue = _c.currentPendingValue,\n          isOpen = _c.isOpen;\n      var currentPendingIndexValid = indexWithinBounds(currentOptions, currentPendingValueValidIndex); // If the user passed is a value prop, use that\n      // unless we are open and have a valid current pending index\n\n      if (!(isOpen && currentPendingIndexValid) && text && (currentPendingValue === null || currentPendingValue === undefined)) {\n        return text;\n      }\n\n      if (_this.props.multiSelect) {\n        // Multi-select\n        if (_this._hasFocus()) {\n          var index = -1;\n\n          if (autoComplete === 'on' && currentPendingIndexValid) {\n            index = currentPendingValueValidIndex;\n          }\n\n          return _this._getPendingString(currentPendingValue, currentOptions, index);\n        } else {\n          return _this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n        }\n      } else {\n        // Single-select\n        var index = _this._getFirstSelectedIndex();\n\n        if (allowFreeform) {\n          // If we are allowing freeform and autocomplete is also true\n          // and we've got a pending value that matches an option, remember\n          // the matched option's index\n          if (autoComplete === 'on' && currentPendingIndexValid) {\n            index = currentPendingValueValidIndex;\n          } // Since we are allowing freeform, if there is currently a pending value, use that\n          // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n\n\n          return _this._getPendingString(currentPendingValue, currentOptions, index);\n        } else {\n          // If we are not allowing freeform and have a valid index that matches the pending value,\n          // we know we will need some version of the pending value\n          if (currentPendingIndexValid && autoComplete === 'on') {\n            // If autoComplete is on, return the raw pending value, otherwise remember\n            // the matched option's index\n            index = currentPendingValueValidIndex;\n            return normalizeToString(currentPendingValue);\n          } else if (!_this.state.isOpen && currentPendingValue) {\n            return indexWithinBounds(currentOptions, index) ? currentPendingValue : normalizeToString(suggestedDisplayValue);\n          } else {\n            return indexWithinBounds(currentOptions, index) ? getPreviewText(currentOptions[index]) : normalizeToString(suggestedDisplayValue);\n          }\n        }\n      }\n    };\n    /**\n     * Handler for typing changes on the input\n     * @param updatedValue - the newly changed value\n     */\n\n\n    _this._onInputChange = function (updatedValue) {\n      if (_this.props.disabled) {\n        _this._handleInputWhenDisabled(null\n        /* event */\n        );\n\n        return;\n      }\n\n      if (_this.props.onInputValueChange) {\n        _this.props.onInputValueChange(updatedValue);\n      }\n\n      _this.props.allowFreeform ? _this._processInputChangeWithFreeform(updatedValue) : _this._processInputChangeWithoutFreeform(updatedValue);\n    };\n    /**\n     * Focus (and select) the content of the input\n     * and set the focused state\n     */\n\n\n    _this._onFocus = function () {\n      var _a, _b;\n\n      (_b = (_a = _this._autofill.current) === null || _a === void 0 ? void 0 : _a.inputElement) === null || _b === void 0 ? void 0 : _b.select();\n\n      if (!_this._hasFocus()) {\n        _this.setState({\n          focusState: 'focusing'\n        });\n      }\n    };\n    /**\n     * Callback issued when the options should be resolved, if they have been updated or\n     * if they need to be passed in the first time. This only does work if an onResolveOptions\n     * callback was passed in\n     */\n\n\n    _this._onResolveOptions = function () {\n      if (_this.props.onResolveOptions) {\n        // get the options\n        var newOptions_1 = _this.props.onResolveOptions(__spreadArray([], _this.props.hoisted.currentOptions)); // Check to see if the returned value is an array, if it is update the state\n        // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n        // If it is then resolve it asynchronously.\n\n\n        if (Array.isArray(newOptions_1)) {\n          _this.props.hoisted.setCurrentOptions(newOptions_1);\n        } else if (newOptions_1 && newOptions_1.then) {\n          // Ensure that the promise will only use the callback if it was the most recent one\n          // and update the state when the promise returns\n          _this._currentPromise = newOptions_1;\n          newOptions_1.then(function (newOptionsFromPromise) {\n            if (newOptions_1 === _this._currentPromise) {\n              _this.props.hoisted.setCurrentOptions(newOptionsFromPromise);\n            }\n          });\n        }\n      }\n    };\n    /**\n     * OnBlur handler. Set the focused state to false\n     * and submit any pending value\n     */\n    // eslint-disable-next-line deprecation/deprecation\n\n\n    _this._onBlur = function (event) {\n      var _a, _b; // Do nothing if the blur is coming from something\n      // inside the comboBox root or the comboBox menu since\n      // it we are not really blurring from the whole comboBox\n\n\n      var relatedTarget = event.relatedTarget;\n\n      if (event.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = document.activeElement;\n      }\n\n      if (relatedTarget) {\n        var isBlurFromComboBoxTitle = (_a = _this.props.hoisted.rootRef.current) === null || _a === void 0 ? void 0 : _a.contains(relatedTarget);\n        var isBlurFromComboBoxMenu = (_b = _this._comboBoxMenu.current) === null || _b === void 0 ? void 0 : _b.contains(relatedTarget);\n        var isBlurFromComboBoxMenuAncestor = _this._comboBoxMenu.current && findElementRecursive(_this._comboBoxMenu.current, function (element) {\n          return element === relatedTarget;\n        });\n\n        if (isBlurFromComboBoxTitle || isBlurFromComboBoxMenu || isBlurFromComboBoxMenuAncestor) {\n          if (isBlurFromComboBoxMenuAncestor && _this._hasFocus() && (!_this.props.multiSelect || _this.props.allowFreeform)) {\n            _this._submitPendingValue(event);\n          }\n\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n      }\n\n      if (_this._hasFocus()) {\n        _this.setState({\n          focusState: 'none'\n        });\n\n        if (!_this.props.multiSelect || _this.props.allowFreeform) {\n          _this._submitPendingValue(event);\n        }\n      }\n    }; // Render Callout container and pass in list\n\n\n    _this._onRenderContainer = function (props, defaultRender) {\n      var onRenderList = props.onRenderList,\n          calloutProps = props.calloutProps,\n          dropdownWidth = props.dropdownWidth,\n          dropdownMaxWidth = props.dropdownMaxWidth,\n          _a = props.onRenderUpperContent,\n          onRenderUpperContent = _a === void 0 ? _this._onRenderUpperContent : _a,\n          _b = props.onRenderLowerContent,\n          onRenderLowerContent = _b === void 0 ? _this._onRenderLowerContent : _b,\n          useComboBoxAsMenuWidth = props.useComboBoxAsMenuWidth,\n          persistMenu = props.persistMenu,\n          _c = props.shouldRestoreFocus,\n          shouldRestoreFocus = _c === void 0 ? true : _c;\n      var isOpen = _this.state.isOpen;\n      var id = _this._id;\n      var comboBoxMenuWidth = useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? _this._comboBoxWrapper.current.clientWidth + 2 : undefined;\n      return React.createElement(Callout, __assign({\n        isBeakVisible: false,\n        gapSpace: 0,\n        doNotLayer: false,\n        directionalHint: DirectionalHint.bottomLeftEdge,\n        directionalHintFixed: false\n      }, calloutProps, {\n        onLayerMounted: _this._onLayerMounted,\n        className: css(_this._classNames.callout, calloutProps === null || calloutProps === void 0 ? void 0 : calloutProps.className),\n        target: _this._comboBoxWrapper.current,\n        onDismiss: _this._onDismiss,\n        onMouseDown: _this._onCalloutMouseDown,\n        onScroll: _this._onScroll,\n        setInitialFocus: false,\n        calloutWidth: useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? comboBoxMenuWidth && comboBoxMenuWidth : dropdownWidth,\n        calloutMaxWidth: dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth,\n        hidden: persistMenu ? !isOpen : undefined,\n        shouldRestoreFocus: shouldRestoreFocus\n      }), onRenderUpperContent(_this.props, _this._onRenderUpperContent), React.createElement(\"div\", {\n        className: _this._classNames.optionsContainerWrapper,\n        ref: _this._comboBoxMenu\n      }, onRenderList === null || onRenderList === void 0 ? void 0 : onRenderList(__assign(__assign({}, props), {\n        id: id\n      }), _this._onRenderList)), onRenderLowerContent(_this.props, _this._onRenderLowerContent));\n    };\n\n    _this._onLayerMounted = function () {\n      _this._onCalloutLayerMounted(); // need to call this again here to get the correct scroll parent dimensions\n      // when the callout is first opened\n\n\n      _this._async.setTimeout(function () {\n        _this._scrollIntoView();\n      }, 0);\n\n      if (_this.props.calloutProps && _this.props.calloutProps.onLayerMounted) {\n        _this.props.calloutProps.onLayerMounted();\n      }\n    };\n\n    _this._onRenderLabel = function (onRenderLabelProps) {\n      var _a = onRenderLabelProps.props,\n          label = _a.label,\n          disabled = _a.disabled,\n          required = _a.required;\n\n      if (label) {\n        return React.createElement(Label, {\n          id: _this._id + '-label',\n          disabled: disabled,\n          required: required,\n          className: _this._classNames.label\n        }, label, onRenderLabelProps.multiselectAccessibleText && React.createElement(\"span\", {\n          className: _this._classNames.screenReaderText\n        }, onRenderLabelProps.multiselectAccessibleText));\n      }\n\n      return null;\n    }; // Render List of items\n\n\n    _this._onRenderList = function (props) {\n      var _a = props.onRenderItem,\n          onRenderItem = _a === void 0 ? _this._onRenderItem : _a,\n          label = props.label,\n          ariaLabel = props.ariaLabel,\n          multiSelect = props.multiSelect;\n      var queue = {\n        items: []\n      };\n      var renderedList = [];\n\n      var emptyQueue = function () {\n        var newGroup = queue.id ? [React.createElement(\"div\", {\n          role: \"group\",\n          key: queue.id,\n          \"aria-labelledby\": queue.id\n        }, queue.items)] : queue.items;\n        renderedList = __spreadArray(__spreadArray([], renderedList), newGroup); // Flush items and id\n\n        queue = {\n          items: []\n        };\n      };\n\n      var placeRenderedOptionIntoQueue = function (item, index) {\n        /*\n          Case Header\n            empty queue if it's not already empty\n            ensure unique ID for header and set queue ID\n            push header into queue\n          Case Divider\n            push divider into queue if not first item\n            empty queue if not already empty\n          Default\n            push item into queue\n        */\n        switch (item.itemType) {\n          case SelectableOptionMenuItemType.Header:\n            queue.items.length > 0 && emptyQueue();\n            var id_1 = _this._id + item.key;\n            queue.items.push(onRenderItem(__assign(__assign({\n              id: id_1\n            }, item), {\n              index: index\n            }), _this._onRenderItem));\n            queue.id = id_1;\n            break;\n\n          case SelectableOptionMenuItemType.Divider:\n            index > 0 && queue.items.push(onRenderItem(__assign(__assign({}, item), {\n              index: index\n            }), _this._onRenderItem));\n            queue.items.length > 0 && emptyQueue();\n            break;\n\n          default:\n            queue.items.push(onRenderItem(__assign(__assign({}, item), {\n              index: index\n            }), _this._onRenderItem));\n        }\n      }; // Place options into the queue. Queue will be emptied anytime a Header or Divider is encountered\n\n\n      props.options.forEach(function (item, index) {\n        placeRenderedOptionIntoQueue(item, index);\n      }); // Push remaining items into all renderedList\n\n      queue.items.length > 0 && emptyQueue();\n      var id = _this._id;\n      return React.createElement(\"div\", {\n        id: id + '-list',\n        className: _this._classNames.optionsContainer,\n        \"aria-labelledby\": label && id + '-label',\n        \"aria-label\": ariaLabel && !label ? ariaLabel : undefined,\n        \"aria-multiselectable\": multiSelect ? 'true' : undefined,\n        role: \"listbox\"\n      }, renderedList);\n    }; // Render items\n\n\n    _this._onRenderItem = function (item) {\n      switch (item.itemType) {\n        case SelectableOptionMenuItemType.Divider:\n          return _this._renderSeparator(item);\n\n        case SelectableOptionMenuItemType.Header:\n          return _this._renderHeader(item);\n\n        default:\n          return _this._renderOption(item);\n      }\n    }; // Default _onRenderLowerContent function returns nothing\n\n\n    _this._onRenderLowerContent = function () {\n      return null;\n    }; // Default _onRenderUpperContent function returns nothing\n\n\n    _this._onRenderUpperContent = function () {\n      return null;\n    };\n\n    _this._renderOption = function (item) {\n      var _a = _this.props.onRenderOption,\n          onRenderOption = _a === void 0 ? _this._onRenderOptionContent : _a;\n      var id = _this._id;\n\n      var isSelected = _this._isOptionSelected(item.index);\n\n      var isChecked = _this._isOptionChecked(item.index);\n\n      var isIndeterminate = _this._isOptionIndeterminate(item.index);\n\n      var optionStyles = _this._getCurrentOptionStyles(item);\n\n      var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n      var title = item.title;\n\n      var onRenderCheckboxLabel = function () {\n        return onRenderOption(item, _this._onRenderOptionContent);\n      };\n\n      var getOptionComponent = function () {\n        return !_this.props.multiSelect ? React.createElement(CommandButton, {\n          id: id + '-list' + item.index,\n          key: item.key,\n          \"data-index\": item.index,\n          styles: optionStyles,\n          checked: isSelected,\n          className: 'ms-ComboBox-option',\n          onClick: _this._onItemClick(item),\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseEnter: _this._onOptionMouseEnter.bind(_this, item.index),\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseMove: _this._onOptionMouseMove.bind(_this, item.index),\n          onMouseLeave: _this._onOptionMouseLeave,\n          role: \"option\",\n          \"aria-selected\": isSelected ? 'true' : 'false',\n          ariaLabel: item.ariaLabel,\n          disabled: item.disabled,\n          title: title\n        }, React.createElement(\"span\", {\n          className: optionClassNames.optionTextWrapper,\n          ref: isSelected ? _this._selectedElement : undefined\n        }, onRenderOption(item, _this._onRenderOptionContent))) : React.createElement(Checkbox, {\n          id: id + '-list' + item.index,\n          ariaLabel: item.ariaLabel,\n          key: item.key,\n          styles: optionStyles,\n          className: 'ms-ComboBox-option',\n          onChange: _this._onItemClick(item),\n          label: item.text,\n          checked: isChecked,\n          indeterminate: isIndeterminate,\n          title: title,\n          disabled: item.disabled,\n          // eslint-disable-next-line react/jsx-no-bind\n          onRenderLabel: onRenderCheckboxLabel,\n          inputProps: __assign({\n            // aria-selected should only be applied to checked items, not hovered items\n            'aria-selected': isChecked ? 'true' : 'false',\n            role: 'option'\n          }, {\n            'data-index': item.index,\n            'data-is-focusable': true\n          })\n        });\n      };\n\n      return React.createElement(ComboBoxOptionWrapper, {\n        key: item.key,\n        index: item.index,\n        disabled: item.disabled,\n        isSelected: isSelected,\n        isChecked: isChecked,\n        isIndeterminate: isIndeterminate,\n        text: item.text,\n        // eslint-disable-next-line react/jsx-no-bind\n        render: getOptionComponent,\n        data: item.data\n      });\n    };\n    /**\n     * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n     */\n\n\n    _this._onCalloutMouseDown = function (ev) {\n      ev.preventDefault();\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      var _a;\n\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      if ((_a = _this.props.calloutProps) === null || _a === void 0 ? void 0 : _a.onScroll) {\n        _this.props.calloutProps.onScroll();\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, ScrollIdleDelay);\n    };\n\n    _this._onRenderOptionContent = function (item) {\n      var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n      return React.createElement(\"span\", {\n        className: optionClassNames.optionText\n      }, item.text);\n    };\n    /**\n     * Handles dismissing (cancelling) the menu\n     */\n\n\n    _this._onDismiss = function () {\n      var onMenuDismiss = _this.props.onMenuDismiss;\n\n      if (onMenuDismiss) {\n        onMenuDismiss();\n      } // In persistMode we need to simulate callout layer mount\n      // since that only happens once. We do it on dismiss since\n      // it works either way.\n\n\n      if (_this.props.persistMenu) {\n        _this._onCalloutLayerMounted();\n      } // close the menu\n\n\n      _this._setOpenStateAndFocusOnClose(false\n      /* isOpen */\n      , false\n      /* focusInputAfterClose */\n      ); // reset the selected index\n      // to the last value state\n\n\n      _this._resetSelectedIndex();\n    };\n\n    _this._onAfterClearPendingInfo = function () {\n      _this._processingClearPendingInfo = false;\n    };\n    /**\n     * Handle keydown on the input\n     * @param ev - The keyboard event that was fired\n     */\n\n\n    _this._onInputKeyDown = function (ev) {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete,\n          currentOptions = _a.hoisted.currentOptions;\n      var _b = _this.state,\n          isOpen = _b.isOpen,\n          currentPendingValueValidIndexOnHover = _b.currentPendingValueValidIndexOnHover; // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _onInputKeyUp for reasoning.\n\n      _this._lastKeyDownWasAltOrMeta = isAltOrMeta(ev);\n\n      if (disabled) {\n        _this._handleInputWhenDisabled(ev);\n\n        return;\n      }\n\n      var index = _this._getPendingSelectedIndex(false\n      /* includeCurrentPendingValue */\n      ); // eslint-disable-next-line deprecation/deprecation\n\n\n      switch (ev.which) {\n        case KeyCodes.enter:\n          if (_this._autofill.current && _this._autofill.current.inputElement) {\n            _this._autofill.current.inputElement.select();\n          }\n\n          _this._submitPendingValue(ev);\n\n          if (_this.props.multiSelect && isOpen) {\n            _this.setState({\n              currentPendingValueValidIndex: index\n            });\n          } else {\n            // On enter submit the pending value\n            if (isOpen || (!allowFreeform || _this.state.currentPendingValue === undefined || _this.state.currentPendingValue === null || _this.state.currentPendingValue.length <= 0) && _this.state.currentPendingValueValidIndex < 0) {\n              // if we are open or\n              // if we are not allowing freeform or\n              // our we have no pending value\n              // and no valid pending index\n              // flip the open state\n              _this.setState({\n                isOpen: !isOpen\n              });\n            }\n          }\n\n          break;\n\n        case KeyCodes.tab:\n          // On enter submit the pending value\n          if (!_this.props.multiSelect) {\n            _this._submitPendingValue(ev);\n          } // If we are not allowing freeform\n          // or the combo box is open, flip the open state\n\n\n          if (isOpen) {\n            _this._setOpenStateAndFocusOnClose(!isOpen, false\n            /* focusInputAfterClose */\n            );\n          } // Allow TAB to propagate\n\n\n          return;\n\n        case KeyCodes.escape:\n          // reset the selected index\n          _this._resetSelectedIndex(); // Close the menu if opened\n\n\n          if (isOpen) {\n            _this.setState({\n              isOpen: false\n            });\n          } else {\n            return;\n          }\n\n          break;\n\n        case KeyCodes.up:\n          // if we are in clearAll state (e.g. the user as hovering\n          // and has since mousedOut of the menu items),\n          // go to the last index\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            index = _this.props.hoisted.currentOptions.length;\n          }\n\n          if (ev.altKey || ev.metaKey) {\n            // Close the menu if it is open and break so\n            // that the event get stopPropagation and prevent default.\n            // Otherwise, we need to let the event continue to propagate\n            if (isOpen) {\n              _this._setOpenStateAndFocusOnClose(!isOpen, true\n              /* focusInputAfterClose */\n              );\n\n              break;\n            }\n\n            return;\n          } // do not scroll page\n\n\n          ev.preventDefault(); // Go to the previous option\n\n          _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n\n          break;\n\n        case KeyCodes.down:\n          // Expand the combo box on ALT + DownArrow\n          if (ev.altKey || ev.metaKey) {\n            _this._setOpenStateAndFocusOnClose(true\n            /* isOpen */\n            , true\n            /* focusInputAfterClose */\n            );\n          } else {\n            // if we are in clearAll state (e.g. the user as hovering\n            // and has since mousedOut of the menu items),\n            // go to the first index\n            if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n              index = -1;\n            } // do not scroll page\n\n\n            ev.preventDefault(); // Got to the next option\n\n            _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n          }\n\n          break;\n\n        case KeyCodes.home:\n        case KeyCodes.end:\n          if (allowFreeform) {\n            return;\n          } // Set the initial values to respond to HOME\n          // which goes to the first selectable option\n\n\n          index = -1;\n          var directionToSearch = SearchDirection.forward; // If end, update the values to respond to END\n          // which goes to the last selectable option\n          // eslint-disable-next-line deprecation/deprecation\n\n          if (ev.which === KeyCodes.end) {\n            index = currentOptions.length;\n            directionToSearch = SearchDirection.backward;\n          }\n\n          _this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n\n          break;\n\n        /* eslint-disable no-fallthrough */\n\n        case KeyCodes.space:\n          // event handled in _onComboBoxKeyUp\n          if (!allowFreeform && autoComplete === 'off') {\n            break;\n          }\n\n        default:\n          /* eslint-enable no-fallthrough */\n          // are we processing a function key? if so bail out\n          // eslint-disable-next-line deprecation/deprecation\n          if (ev.which >= 112\n          /* F1 */\n          && ev.which <= 123\n          /* F12 */\n          ) {\n            return;\n          } // If we get here and we got either and ALT key\n          // or meta key, let the event propagate\n          // eslint-disable-next-line deprecation/deprecation\n\n\n          if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta'\n          /* && isOpen */\n          ) {\n            return;\n          } // If we are not allowing freeform and\n          // allowing autoComplete, handle the input here\n          // since we have marked the input as readonly\n\n\n          if (!allowFreeform && autoComplete === 'on') {\n            _this._onInputChange(ev.key);\n\n            break;\n          } // allow the key to propagate by default\n\n\n          return;\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n    /**\n     * Handle keyup on the input\n     * @param ev - the keyboard event that was fired\n     */\n\n\n    _this._onInputKeyUp = function (ev) {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete;\n      var isOpen = _this.state.isOpen; // We close the menu on key up only if ALL of the following are true:\n      // - Most recent key down was alt or meta (command)\n      // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n      //   expand/collapse the menu)\n      // - We're not on a Mac (or iOS)\n      // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n      // closing any open context menus. There is not a similar behavior on Macs.\n\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && isAltOrMeta(ev);\n      _this._lastKeyDownWasAltOrMeta = false;\n      var shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n\n      if (disabled) {\n        _this._handleInputWhenDisabled(ev);\n\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      switch (ev.which) {\n        case KeyCodes.space:\n          // If we are not allowing freeform and are not autoComplete\n          // make space expand/collapse the combo box\n          // and allow the event to propagate\n          if (!allowFreeform && autoComplete === 'off') {\n            _this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n          }\n\n          return;\n\n        default:\n          if (shouldHandleKey && isOpen) {\n            _this._setOpenStateAndFocusOnClose(!isOpen, true\n            /* focusInputAfterClose */\n            );\n          } else {\n            if (_this.state.focusState === 'focusing' && _this.props.openOnKeyboardFocus) {\n              _this.setState({\n                isOpen: true\n              });\n            }\n\n            if (_this.state.focusState !== 'focused') {\n              _this.setState({\n                focusState: 'focused'\n              });\n            }\n          }\n\n          return;\n      }\n    };\n\n    _this._onOptionMouseLeave = function () {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      } // Ignore the event in persistMenu mode if the callout has\n      // closed. This is to avoid clearing the visuals on item click.\n\n\n      if (_this.props.persistMenu && !_this.state.isOpen) {\n        return;\n      }\n\n      _this.setState({\n        currentPendingValueValidIndexOnHover: HoverStatus.clearAll\n      });\n    };\n    /**\n     * Click handler for the button of the combo box and the input when not allowing freeform.\n     * This toggles the expand/collapse state of the combo box (if enabled).\n     */\n\n\n    _this._onComboBoxClick = function () {\n      var disabled = _this.props.disabled;\n      var isOpen = _this.state.isOpen;\n\n      if (!disabled) {\n        _this._setOpenStateAndFocusOnClose(!isOpen, false\n        /* focusInputAfterClose */\n        );\n\n        _this.setState({\n          focusState: 'focused'\n        });\n      }\n    };\n    /**\n     * Click handler for the autofill.\n     */\n\n\n    _this._onAutofillClick = function () {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform;\n\n      if (allowFreeform && !disabled) {\n        _this.focus(_this.state.isOpen || _this._processingTouch);\n      } else {\n        _this._onComboBoxClick();\n      }\n    };\n\n    _this._onTouchStart = function () {\n      if (_this._comboBoxWrapper.current && !('onpointerdown' in _this._comboBoxWrapper)) {\n        _this._handleTouchAndPointerEvent();\n      }\n    };\n\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._handleTouchAndPointerEvent();\n\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      defaultSelectedKey: 'selectedKey',\n      text: 'defaultSelectedKey',\n      selectedKey: 'value',\n      dropdownWidth: 'useComboBoxAsMenuWidth',\n      ariaLabel: 'label'\n    });\n    _this._id = props.id || getId('ComboBox');\n    _this._isScrollIdle = true;\n    _this._processingTouch = false;\n    _this._gotMouseMove = false;\n    _this._processingClearPendingInfo = false;\n    _this.state = {\n      isOpen: false,\n      focusState: 'none',\n      currentPendingValueValidIndex: -1,\n      currentPendingValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    };\n    return _this;\n  }\n\n  Object.defineProperty(ComboBoxInternal.prototype, \"selectedOptions\", {\n    /**\n     * All selected options\n     */\n    get: function () {\n      var _a = this.props.hoisted,\n          currentOptions = _a.currentOptions,\n          selectedIndices = _a.selectedIndices;\n      return getAllSelectedOptions(currentOptions, selectedIndices);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ComboBoxInternal.prototype.componentDidMount = function () {\n    if (this._comboBoxWrapper.current && !this.props.disabled) {\n      // hook up resolving the options if needed on focus\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n        // does not support Pointer events yet.\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n      }\n    }\n  };\n\n  ComboBoxInternal.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _this = this;\n\n    var _a = this.props,\n        allowFreeform = _a.allowFreeform,\n        text = _a.text,\n        onMenuOpen = _a.onMenuOpen,\n        onMenuDismissed = _a.onMenuDismissed,\n        selectedIndices = _a.hoisted.selectedIndices;\n    var _b = this.state,\n        isOpen = _b.isOpen,\n        currentPendingValueValidIndex = _b.currentPendingValueValidIndex; // If we are newly open or are open and the pending valid index changed,\n    // make sure the currently selected/pending option is scrolled into view\n\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n      // Need this timeout so that the selectedElement ref is correctly updated\n      this._async.setTimeout(function () {\n        return _this._scrollIntoView();\n      }, 0);\n    } // if an action is taken that put focus in the ComboBox\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\n    // but we are not the activeElement set focus on the input\n\n\n    if (this._hasFocus() && (isOpen || prevState.isOpen && !isOpen && this._focusInputAfterClose && this._autofill.current && document.activeElement !== this._autofill.current.inputElement)) {\n      this.focus(undefined\n      /*shouldOpenOnFocus*/\n      , true\n      /*useFocusAsync*/\n      );\n    } // If we should focusAfterClose AND\n    //   just opened/closed the menu OR\n    //   are focused AND\n    //     updated the selectedIndex with the menu closed OR\n    //     are not allowing freeform OR\n    //     the value changed\n    // we need to set selection\n\n\n    if (this._focusInputAfterClose && (prevState.isOpen && !isOpen || this._hasFocus() && (!isOpen && !this.props.multiSelect && prevProps.hoisted.selectedIndices && selectedIndices && prevProps.hoisted.selectedIndices[0] !== selectedIndices[0] || !allowFreeform || text !== prevProps.text))) {\n      this._onFocus();\n    }\n\n    this._notifyPendingValueChanged(prevState);\n\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\n      onMenuOpen();\n    }\n\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\n      onMenuDismissed();\n    }\n  };\n\n  ComboBoxInternal.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  }; // Primary Render\n\n\n  ComboBoxInternal.prototype.render = function () {\n    var id = this._id;\n    var errorMessageId = id + '-error';\n    var _a = this.props,\n        className = _a.className,\n        disabled = _a.disabled,\n        required = _a.required,\n        errorMessage = _a.errorMessage,\n        _b = _a.onRenderContainer,\n        onRenderContainer = _b === void 0 ? this._onRenderContainer : _b,\n        _c = _a.onRenderLabel,\n        onRenderLabel = _c === void 0 ? this._onRenderLabel : _c,\n        _d = _a.onRenderList,\n        onRenderList = _d === void 0 ? this._onRenderList : _d,\n        _e = _a.onRenderItem,\n        onRenderItem = _e === void 0 ? this._onRenderItem : _e,\n        _f = _a.onRenderOption,\n        onRenderOption = _f === void 0 ? this._onRenderOptionContent : _f,\n        allowFreeform = _a.allowFreeform,\n        customStyles = _a.styles,\n        theme = _a.theme,\n        persistMenu = _a.persistMenu,\n        multiSelect = _a.multiSelect,\n        _g = _a.hoisted,\n        suggestedDisplayValue = _g.suggestedDisplayValue,\n        selectedIndices = _g.selectedIndices,\n        currentOptions = _g.currentOptions;\n    var isOpen = this.state.isOpen;\n    this._currentVisibleValue = this._getVisibleValue(); // Single select is already accessible since the whole text is selected\n    // when focus enters the input. Since multiselect appears to clear the input\n    // it needs special accessible text\n\n    var multiselectAccessibleText = multiSelect ? this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue) : undefined;\n    var divProps = getNativeProps(this.props, divProperties, ['onChange', 'value', 'aria-describedby', 'aria-labelledby']);\n    var hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n    this._classNames = this.props.getClassNames ? this.props.getClassNames(theme, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage, className) : getClassNames(getStyles(theme, customStyles), className, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage);\n\n    var comboBoxWrapper = this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId);\n\n    return React.createElement(\"div\", __assign({}, divProps, {\n      ref: this.props.hoisted.mergedRootRef,\n      className: this._classNames.container\n    }), onRenderLabel({\n      props: this.props,\n      multiselectAccessibleText: multiselectAccessibleText\n    }, this._onRenderLabel), comboBoxWrapper, (persistMenu || isOpen) && onRenderContainer(__assign(__assign({}, this.props), {\n      onRenderList: onRenderList,\n      onRenderItem: onRenderItem,\n      onRenderOption: onRenderOption,\n      options: currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }),\n      onDismiss: this._onDismiss\n    }), this._onRenderContainer), hasErrorMessage && React.createElement(\"div\", {\n      role: \"alert\",\n      id: errorMessageId,\n      className: this._classNames.errorMessage\n    }, errorMessage));\n  };\n\n  ComboBoxInternal.prototype._getPendingString = function (currentPendingValue, currentOptions, index) {\n    return currentPendingValue !== null && currentPendingValue !== undefined ? currentPendingValue : indexWithinBounds(currentOptions, index) ? getPreviewText(currentOptions[index]) : '';\n  };\n  /**\n   * Returns a string that concatenates all of the selected values\n   * for multiselect combo box.\n   */\n\n\n  ComboBoxInternal.prototype._getMultiselectDisplayString = function (selectedIndices, currentOptions, suggestedDisplayValue) {\n    var displayValues = [];\n\n    for (var idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n      var index = selectedIndices[idx];\n\n      if (currentOptions[index].itemType !== SelectableOptionMenuItemType.SelectAll) {\n        displayValues.push(indexWithinBounds(currentOptions, index) ? currentOptions[index].text : normalizeToString(suggestedDisplayValue));\n      }\n    }\n\n    var _a = this.props.multiSelectDelimiter,\n        multiSelectDelimiter = _a === void 0 ? ', ' : _a;\n    return displayValues.join(multiSelectDelimiter);\n  };\n  /**\n   * Process the new input's new value when the combo box allows freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n\n\n  ComboBoxInternal.prototype._processInputChangeWithFreeform = function (updatedValue) {\n    var currentOptions = this.props.hoisted.currentOptions;\n    var newCurrentPendingValueValidIndex = -1; // if the new value is empty, see if we have an exact match and then set the pending info\n\n    if (updatedValue === '') {\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return isNormalOption(option) && getPreviewText(option) === updatedValue;\n      }); // if we found a match remember the index\n\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n\n      return;\n    } // Remember the original value and then make the value lowercase for comparison\n\n\n    var originalUpdatedValue = updatedValue;\n    updatedValue = updatedValue.toLocaleLowerCase();\n    var newSuggestedDisplayValue = ''; // If autoComplete is on, attempt to find a match from the available options\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return isNormalOption(option) && getPreviewText(option).toLocaleLowerCase().indexOf(updatedValue) === 0;\n      });\n\n      if (items.length > 0) {\n        // use ariaLabel as the value when the option is set\n        var text = getPreviewText(items[0]); // If the user typed out the complete option text, we don't need any suggested display text anymore\n\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : ''; // remember the index of the match we found\n\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } else {\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return isNormalOption(option) && getPreviewText(option).toLocaleLowerCase() === updatedValue;\n      }); // if we found a match remember the index\n\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } // Set the updated state\n\n\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n  };\n  /**\n   * Process the new input's new value when the combo box does not allow freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n\n\n  ComboBoxInternal.prototype._processInputChangeWithoutFreeform = function (updatedValue) {\n    var _this = this;\n\n    var currentOptions = this.props.hoisted.currentOptions;\n    var _a = this.state,\n        currentPendingValue = _a.currentPendingValue,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex;\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on while allow freeform is off,\n      // we will remember the key press and build up a string to attempt to match\n      // as long as characters are typed within a the timeout span of each other,\n      // otherwise we will clear the string and start building a new one on the next keypress.\n      // Also, only do this processing if we have a non-empty value\n      if (updatedValue !== '') {\n        // If we have a pending autocomplete clearing task,\n        // we know that the user is typing with key press happening\n        // within the timeout of each other so remove the clearing task\n        // and continue building the pending value with the updated value\n        if (this._autoCompleteTimeout) {\n          this._async.clearTimeout(this._autoCompleteTimeout);\n\n          this._autoCompleteTimeout = undefined;\n          updatedValue = normalizeToString(currentPendingValue) + updatedValue;\n        }\n\n        var originalUpdatedValue = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase(); // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n\n        var items = currentOptions.map(function (item, i) {\n          return __assign(__assign({}, item), {\n            index: i\n          });\n        }).filter(function (option) {\n          return isNormalOption(option) && option.text.toLocaleLowerCase().indexOf(updatedValue) === 0;\n        }); // If we found a match, update the state\n\n        if (items.length > 0) {\n          this._setPendingInfo(originalUpdatedValue, items[0].index, getPreviewText(items[0]));\n        } // Schedule a timeout to clear the pending value after the timeout span\n\n\n        this._autoCompleteTimeout = this._async.setTimeout(function () {\n          _this._autoCompleteTimeout = undefined;\n        }, ReadOnlyPendingAutoCompleteTimeout);\n        return;\n      }\n    } // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n    // use that; otherwise use the selectedIndex\n\n\n    var index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex(); // Since we are not allowing freeform, we need to\n    // set both the pending and suggested values/index\n    // to allow us to select all content in the input to\n    // give the illusion that we are readonly (e.g. freeform off)\n\n    this._setPendingInfoFromIndex(index);\n  };\n\n  ComboBoxInternal.prototype._getFirstSelectedIndex = function () {\n    var selectedIndices = this.props.hoisted.selectedIndices;\n    return (selectedIndices === null || selectedIndices === void 0 ? void 0 : selectedIndices.length) ? selectedIndices[0] : -1;\n  };\n  /**\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\n   * @param index - the index to get the next selectable index from\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n   */\n\n\n  ComboBoxInternal.prototype._getNextSelectableIndex = function (index, searchDirection) {\n    var currentOptions = this.props.hoisted.currentOptions;\n    var newIndex = index + searchDirection;\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n\n    if (!indexWithinBounds(currentOptions, newIndex)) {\n      return -1;\n    }\n\n    var option = currentOptions[newIndex];\n\n    if (!isSelectableOption(option) || option.hidden === true) {\n      // Should we continue looking for an index to select?\n      if (searchDirection !== SearchDirection.none && (newIndex > 0 && searchDirection < SearchDirection.none || newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none)) {\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n      } else {\n        // If we cannot perform a useful search just return the index we were given\n        return index;\n      }\n    } // We have the next valid selectable index, return it\n\n\n    return newIndex;\n  };\n  /**\n   * Set the selected index. Note, this is\n   * the \"real\" selected index, not the pending selected index\n   * @param index - the index to set (or the index to set from if a search direction is provided)\n   * @param searchDirection - the direction to search along the options from the given index\n   */\n\n\n  ComboBoxInternal.prototype._setSelectedIndex = function (index, submitPendingValueEvent, searchDirection) {\n    if (searchDirection === void 0) {\n      searchDirection = SearchDirection.none;\n    }\n\n    var _a = this.props,\n        onChange = _a.onChange,\n        onPendingValueChanged = _a.onPendingValueChanged,\n        _b = _a.hoisted,\n        initialIndices = _b.selectedIndices,\n        currentOptions = _b.currentOptions; // Clone currentOptions and selectedIndices so we don't mutate state\n\n    var selectedIndices = initialIndices ? initialIndices.slice() : [];\n    var changedOptions = currentOptions.slice(); // Find the next selectable index, if searchDirection is none\n    // we will get our starting index back\n\n    index = this._getNextSelectableIndex(index, searchDirection);\n\n    if (!indexWithinBounds(currentOptions, index)) {\n      return;\n    } // Are we at a new index? If so, update the state, otherwise\n    // there is nothing to do\n\n\n    if (this.props.multiSelect || selectedIndices.length < 1 || selectedIndices.length === 1 && selectedIndices[0] !== index) {\n      var option = __assign({}, currentOptions[index]); // if option doesn't existing, or option is disabled, we noop\n\n\n      if (!option || option.disabled) {\n        return;\n      }\n\n      if (this.props.multiSelect) {\n        // Setting the initial state of option.selected in Multi-select combo box by checking the\n        // selectedIndices array and overriding the undefined issue\n        option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0; // handle changing all options if SelectAll is changed\n\n        if (option.itemType === SelectableOptionMenuItemType.SelectAll) {\n          selectedIndices = []; // if select all is set to checked, push all selectable option indices\n\n          if (option.selected) {\n            currentOptions.forEach(function (currentOption, i) {\n              if (!currentOption.disabled && isSelectableOption(currentOption)) {\n                selectedIndices.push(i);\n                changedOptions[i] = __assign(__assign({}, currentOption), {\n                  selected: true\n                });\n              }\n            });\n          } // otherwise un-check all options\n          else {\n            changedOptions = currentOptions.map(function (currentOption) {\n              return __assign(__assign({}, currentOption), {\n                selected: false\n              });\n            });\n          }\n        } // otherwise update the individual option\n        else {\n          if (option.selected && selectedIndices.indexOf(index) < 0) {\n            selectedIndices.push(index);\n          } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\n            selectedIndices = selectedIndices.filter(function (value) {\n              return value !== index;\n            });\n          }\n\n          changedOptions[index] = option; // If SelectAll exists and another option was toggled, update the SelectAll option's state\n\n          var selectAllOption = changedOptions.filter(function (o) {\n            return o.itemType === SelectableOptionMenuItemType.SelectAll;\n          })[0];\n\n          if (selectAllOption) {\n            var selectAllState = this._isSelectAllChecked(selectedIndices);\n\n            var selectAllIndex_1 = changedOptions.indexOf(selectAllOption);\n\n            if (selectAllState) {\n              selectedIndices.push(selectAllIndex_1);\n              changedOptions[selectAllIndex_1] = __assign(__assign({}, selectAllOption), {\n                selected: true\n              });\n            } else {\n              selectedIndices = selectedIndices.filter(function (value) {\n                return value !== selectAllIndex_1;\n              });\n              changedOptions[selectAllIndex_1] = __assign(__assign({}, selectAllOption), {\n                selected: false\n              });\n            }\n          }\n        }\n      } else {\n        selectedIndices[0] = index;\n      }\n\n      submitPendingValueEvent.persist(); // Only setState if combo box is uncontrolled.\n\n      if (this.props.selectedKey || this.props.selectedKey === null) {\n        // If combo box value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n      } else {\n        this.props.hoisted.setSelectedIndices(selectedIndices);\n        this.props.hoisted.setCurrentOptions(changedOptions); // If ComboBox value is changed, revert preview first\n\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n      } // Call onChange after state is updated\n\n\n      if (onChange) {\n        onChange(submitPendingValueEvent, option, index, getPreviewText(option));\n      }\n    }\n\n    if (this.props.multiSelect && this.state.isOpen) {\n      return;\n    } // clear all of the pending info\n\n\n    this._clearPendingInfo();\n  };\n  /**\n   * Submit a pending value if there is one\n   */\n\n\n  ComboBoxInternal.prototype._submitPendingValue = function (submitPendingValueEvent) {\n    var _a;\n\n    var _b = this.props,\n        onChange = _b.onChange,\n        allowFreeform = _b.allowFreeform,\n        autoComplete = _b.autoComplete,\n        multiSelect = _b.multiSelect,\n        hoisted = _b.hoisted;\n    var currentOptions = hoisted.currentOptions;\n    var _c = this.state,\n        currentPendingValue = _c.currentPendingValue,\n        currentPendingValueValidIndex = _c.currentPendingValueValidIndex,\n        currentPendingValueValidIndexOnHover = _c.currentPendingValueValidIndexOnHover;\n    var selectedIndices = this.props.hoisted.selectedIndices; // Do not submit any pending value if we\n    // have already initiated clearing the pending info\n\n    if (this._processingClearPendingInfo) {\n      return;\n    } // If we allow freeform we need to handle that\n\n\n    if (allowFreeform) {\n      // if currentPendingValue is null or undefined the user did not submit anything\n      // (not even empty because we would have stored that as the pending value)\n      if (currentPendingValue === null || currentPendingValue === undefined) {\n        // if a user did not type anything they may just hovered over an item\n        if (currentPendingValueValidIndexOnHover >= 0) {\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n\n          this._clearPendingInfo();\n        }\n\n        return;\n      } // Check to see if the user typed an exact match\n\n\n      if (indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n        var pendingOptionText = getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();\n        var autofill = this._autofill.current; // By exact match, that means: our pending value is the same as the pending option text OR\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\n        // where the total length is equal to pending option length OR\n        // the live value in the underlying input matches the pending option; update the state\n\n        if (currentPendingValue.toLocaleLowerCase() === pendingOptionText || autoComplete && pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 && (autofill === null || autofill === void 0 ? void 0 : autofill.isValueSelected) && currentPendingValue.length + (autofill.selectionEnd - autofill.selectionStart) === pendingOptionText.length || ((_a = autofill === null || autofill === void 0 ? void 0 : autofill.inputElement) === null || _a === void 0 ? void 0 : _a.value.toLocaleLowerCase()) === pendingOptionText) {\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n\n          if (multiSelect && this.state.isOpen) {\n            return;\n          }\n\n          this._clearPendingInfo();\n\n          return;\n        }\n      }\n\n      if (onChange) {\n        if (onChange) {\n          // trigger onChange to clear value\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n        }\n      } else {\n        // If we are not controlled, create a new selected option\n        var newOption = {\n          key: currentPendingValue || getId(),\n          text: normalizeToString(currentPendingValue)\n        }; // If it's multiselect, set selected state to true\n\n        if (multiSelect) {\n          newOption.selected = true;\n        }\n\n        var newOptions = currentOptions.concat([newOption]);\n\n        if (selectedIndices) {\n          if (!multiSelect) {\n            selectedIndices = [];\n          }\n\n          selectedIndices.push(newOptions.length - 1);\n        }\n\n        hoisted.setCurrentOptions(newOptions);\n        hoisted.setSelectedIndices(selectedIndices);\n      }\n    } else if (currentPendingValueValidIndex >= 0) {\n      // Since we are not allowing freeform, we must have a matching\n      // to be able to update state\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\n      // If all else failed and we were hovering over an item, select it\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n    } // Finally, clear the pending info\n\n\n    this._clearPendingInfo();\n  };\n\n  ComboBoxInternal.prototype._onCalloutLayerMounted = function () {\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\n    // of the component. Any functionality required for callout \"on mount\" can\n    // go here so that we can also call it again during callout dismissal to reset\n    // object state.\n    this._gotMouseMove = false;\n  }; // Render separator\n\n\n  ComboBoxInternal.prototype._renderSeparator = function (item) {\n    var index = item.index,\n        key = item.key;\n\n    if (index && index > 0) {\n      return React.createElement(\"div\", {\n        role: \"separator\",\n        key: key,\n        className: this._classNames.divider\n      });\n    }\n\n    return null;\n  };\n\n  ComboBoxInternal.prototype._renderHeader = function (item) {\n    var _a = this.props.onRenderOption,\n        onRenderOption = _a === void 0 ? this._onRenderOptionContent : _a;\n    return React.createElement(\"div\", {\n      id: item.id,\n      key: item.key,\n      className: this._classNames.header\n    }, onRenderOption(item, this._onRenderOptionContent));\n  };\n  /**\n   * If we are coming from a mouseOut:\n   * there is no visible selected option.\n   *\n   * Else if We are hovering over an item:\n   * that gets the selected look.\n   *\n   * Else:\n   * Use the current valid pending index if it exists OR\n   * we do not have a valid index and we currently have a pending input value,\n   * otherwise use the selected index\n   * */\n\n\n  ComboBoxInternal.prototype._isOptionHighlighted = function (index) {\n    var currentPendingValueValidIndexOnHover = this.state.currentPendingValueValidIndexOnHover; // If the hover state is set to clearAll, don't show a selected index.\n    // Note, this happens when the user moused out of the menu items\n\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n      return false;\n    }\n\n    return currentPendingValueValidIndexOnHover >= 0 ? currentPendingValueValidIndexOnHover === index : this._isOptionSelected(index);\n  };\n\n  ComboBoxInternal.prototype._isOptionSelected = function (index) {\n    return this._getPendingSelectedIndex(true\n    /* includePendingValue */\n    ) === index;\n  };\n\n  ComboBoxInternal.prototype._isOptionChecked = function (index) {\n    if (this.props.multiSelect && index !== undefined && this.props.hoisted.selectedIndices) {\n      var idxOfSelectedIndex = -1;\n      idxOfSelectedIndex = this.props.hoisted.selectedIndices.indexOf(index);\n      return idxOfSelectedIndex >= 0;\n    }\n\n    return false;\n  };\n\n  ComboBoxInternal.prototype._isOptionIndeterminate = function (index) {\n    var _a = this.props,\n        multiSelect = _a.multiSelect,\n        hoisted = _a.hoisted;\n\n    if (multiSelect && index !== undefined && hoisted.selectedIndices && hoisted.currentOptions) {\n      var option = hoisted.currentOptions[index];\n\n      if (option && option.itemType === SelectableOptionMenuItemType.SelectAll) {\n        return hoisted.selectedIndices.length > 0 && !this._isSelectAllChecked();\n      }\n    }\n\n    return false;\n  };\n\n  ComboBoxInternal.prototype._isSelectAllChecked = function (testIndices) {\n    var _a = this.props,\n        multiSelect = _a.multiSelect,\n        hoisted = _a.hoisted;\n    var selectAllOption = hoisted.currentOptions.find(function (option) {\n      return option.itemType === SelectableOptionMenuItemType.SelectAll;\n    });\n    var selectedIndices = testIndices || hoisted.selectedIndices;\n\n    if (!multiSelect || !selectedIndices || !selectAllOption) {\n      return false;\n    } // start by not including the select all option itself\n\n\n    var selectAllIndex = hoisted.currentOptions.indexOf(selectAllOption);\n    var compareSelectedIndices = selectedIndices.filter(function (value) {\n      return value !== selectAllIndex;\n    }); // get array of selectable options, excluding disabled options, headers, and dividers\n\n    var selectableOptions = hoisted.currentOptions.filter(function (option) {\n      return !option.disabled && option.itemType !== SelectableOptionMenuItemType.SelectAll && isSelectableOption(option);\n    });\n    return compareSelectedIndices.length === selectableOptions.length;\n  };\n  /**\n   * Gets the pending selected index taking into account valueValidIndex and selectedIndex\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n   * finding the index\n   */\n\n\n  ComboBoxInternal.prototype._getPendingSelectedIndex = function (includeCurrentPendingValue) {\n    var _a = this.state,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex,\n        currentPendingValue = _a.currentPendingValue;\n    return currentPendingValueValidIndex >= 0 || includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined ? currentPendingValueValidIndex : this.props.multiSelect ? 0 : this._getFirstSelectedIndex();\n  };\n  /**\n   * Scroll the selected element into view\n   */\n\n\n  ComboBoxInternal.prototype._scrollIntoView = function () {\n    var _a = this.props,\n        onScrollToItem = _a.onScrollToItem,\n        scrollSelectedToTop = _a.scrollSelectedToTop;\n\n    var currentPendingSelectedIndex = this._getPendingSelectedIndex(true);\n\n    if (onScrollToItem) {\n      // Use the custom scroll handler\n      onScrollToItem(currentPendingSelectedIndex >= 0 ? currentPendingSelectedIndex : this._getFirstSelectedIndex());\n      return;\n    }\n\n    var scrollToElement = this._selectedElement.current; // in multi-select there are multiple selected elements, so we use the pending select index\n    // to locate the option to scroll to.\n\n    if (this.props.multiSelect && this._comboBoxMenu.current) {\n      scrollToElement = findFirstDescendant(this._comboBoxMenu.current, function (element) {\n        var _a;\n\n        return ((_a = element.dataset) === null || _a === void 0 ? void 0 : _a.index) === currentPendingSelectedIndex.toString();\n      });\n    }\n\n    if (scrollToElement && scrollToElement.offsetParent) {\n      var alignToTop = true; // We are using refs, scroll the ref into view\n\n      if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n        var scrollableParent = this._comboBoxMenu.current.offsetParent;\n        var selectedElement = scrollToElement.offsetParent;\n        var _b = selectedElement,\n            offsetHeight = _b.offsetHeight,\n            offsetTop = _b.offsetTop;\n        var _c = scrollableParent,\n            parentOffsetHeight = _c.offsetHeight,\n            scrollTop = _c.scrollTop;\n        var isAbove = offsetTop < scrollTop;\n        var isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;\n\n        if (isAbove || scrollSelectedToTop) {\n          alignToTop = false;\n          scrollableParent.scrollTo(0, offsetTop);\n        } else if (isBelow) {\n          scrollableParent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);\n        }\n      } // if _comboboxMenu doesn't exist, fall back to scrollIntoView\n      else {\n        scrollToElement.offsetParent.scrollIntoView(alignToTop);\n      }\n    }\n  };\n  /**\n   * Click handler for the menu items\n   * to select the item and also close the menu\n   * @param index - the index of the item that was clicked\n   */\n\n\n  ComboBoxInternal.prototype._onItemClick = function (item) {\n    var _this = this;\n\n    var onItemClick = this.props.onItemClick;\n    var index = item.index;\n    return function (ev) {\n      // only close the callout when it's in single-select mode\n      if (!_this.props.multiSelect) {\n        // ensure that focus returns to the input, not the button\n        _this._autofill.current && _this._autofill.current.focus();\n\n        _this.setState({\n          isOpen: false\n        });\n      } // Continue processing the click only after\n      // performing menu close / control focus(inner working)\n\n\n      onItemClick && onItemClick(ev, item, index);\n\n      _this._setSelectedIndex(index, ev);\n    };\n  };\n  /**\n   * Reset the selected index by clearing the\n   * input (of any pending text), clearing the pending state,\n   * and setting the suggested display value to the last\n   * selected state text\n   */\n\n\n  ComboBoxInternal.prototype._resetSelectedIndex = function () {\n    var currentOptions = this.props.hoisted.currentOptions;\n\n    this._clearPendingInfo();\n\n    var selectedIndex = this._getFirstSelectedIndex();\n\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n      this.props.hoisted.setSuggestedDisplayValue(currentOptions[selectedIndex].text);\n    } else if (this.props.text) {\n      // If we had a value initially, restore it\n      this.props.hoisted.setSuggestedDisplayValue(this.props.text);\n    }\n  };\n  /**\n   * Clears the pending info state\n   */\n\n\n  ComboBoxInternal.prototype._clearPendingInfo = function () {\n    this._processingClearPendingInfo = true;\n    this.props.hoisted.setSuggestedDisplayValue(undefined);\n    this.setState({\n      currentPendingValue: undefined,\n      currentPendingValueValidIndex: -1,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    }, this._onAfterClearPendingInfo);\n  };\n  /**\n   * Set the pending info\n   * @param currentPendingValue - new pending value to set\n   * @param currentPendingValueValidIndex - new pending value index to set\n   * @param suggestedDisplayValue - new suggest display value to set\n   */\n\n\n  ComboBoxInternal.prototype._setPendingInfo = function (currentPendingValue, currentPendingValueValidIndex, suggestedDisplayValue) {\n    if (currentPendingValueValidIndex === void 0) {\n      currentPendingValueValidIndex = -1;\n    }\n\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    this.props.hoisted.setSuggestedDisplayValue(suggestedDisplayValue);\n    this.setState({\n      currentPendingValue: normalizeToString(currentPendingValue),\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    });\n  };\n  /**\n   * Set the pending info from the given index\n   * @param index - the index to set the pending info from\n   */\n\n\n  ComboBoxInternal.prototype._setPendingInfoFromIndex = function (index) {\n    var currentOptions = this.props.hoisted.currentOptions;\n\n    if (index >= 0 && index < currentOptions.length) {\n      var option = currentOptions[index];\n\n      this._setPendingInfo(getPreviewText(option), index, getPreviewText(option));\n    } else {\n      this._clearPendingInfo();\n    }\n  };\n  /**\n   * Sets the pending info for the combo box\n   * @param index - the index to search from\n   * @param searchDirection - the direction to search\n   */\n\n\n  ComboBoxInternal.prototype._setPendingInfoFromIndexAndDirection = function (index, searchDirection) {\n    var currentOptions = this.props.hoisted.currentOptions; // update index to allow content to wrap\n\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n      index = -1;\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\n      index = currentOptions.length;\n    } // get the next \"valid\" index\n\n\n    var indexUpdate = this._getNextSelectableIndex(index, searchDirection); // if the two indices are equal we didn't move and\n    // we should attempt to get  get the first/last \"valid\" index to use\n    // (Note, this takes care of the potential cases where the first/last\n    // item is not focusable), otherwise use the updated index\n\n\n    if (index === indexUpdate) {\n      if (searchDirection === SearchDirection.forward) {\n        index = this._getNextSelectableIndex(-1, searchDirection);\n      } else if (searchDirection === SearchDirection.backward) {\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n      }\n    } else {\n      index = indexUpdate;\n    }\n\n    if (indexWithinBounds(currentOptions, index)) {\n      this._setPendingInfoFromIndex(index);\n    }\n  };\n\n  ComboBoxInternal.prototype._notifyPendingValueChanged = function (prevState) {\n    var onPendingValueChanged = this.props.onPendingValueChanged;\n\n    if (!onPendingValueChanged) {\n      return;\n    }\n\n    var currentOptions = this.props.hoisted.currentOptions;\n    var _a = this.state,\n        currentPendingValue = _a.currentPendingValue,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex,\n        currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover;\n    var newPendingIndex = undefined;\n    var newPendingValue = prevState.currentPendingValue;\n\n    if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover && indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {\n      // Set new pending index if hover index was changed\n      newPendingIndex = currentPendingValueValidIndexOnHover;\n    } else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex && indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n      // Set new pending index if currentPendingValueValidIndex was changed\n      newPendingIndex = currentPendingValueValidIndex;\n    } else if (currentPendingValue !== prevState.currentPendingValue) {\n      // Set pendingValue in the case it was changed and no index was changed\n      newPendingValue = currentPendingValue;\n    } // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n\n\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n      onPendingValueChanged(newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n    }\n  };\n  /**\n   * Sets the isOpen state and updates focusInputAfterClose\n   */\n\n\n  ComboBoxInternal.prototype._setOpenStateAndFocusOnClose = function (isOpen, focusInputAfterClose) {\n    this._focusInputAfterClose = focusInputAfterClose;\n    this.setState({\n      isOpen: isOpen\n    });\n  };\n\n  ComboBoxInternal.prototype._onOptionMouseEnter = function (index) {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index\n    });\n  };\n\n  ComboBoxInternal.prototype._onOptionMouseMove = function (index) {\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index\n    });\n  };\n\n  ComboBoxInternal.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handle dismissing the menu and eating the required key event when disabled\n   * @param ev - the keyboard event that was fired\n   */\n\n\n  ComboBoxInternal.prototype._handleInputWhenDisabled = function (ev) {\n    // If we are disabled, close the menu (if needed)\n    // and eat all keystrokes other than TAB or ESC\n    if (this.props.disabled) {\n      if (this.state.isOpen) {\n        this.setState({\n          isOpen: false\n        });\n      } // When disabled stop propagation and prevent default\n      // of the event unless we have a tab, escape, or function key\n\n\n      if (ev !== null && // eslint-disable-next-line deprecation/deprecation\n      ev.which !== KeyCodes.tab && // eslint-disable-next-line deprecation/deprecation\n      ev.which !== KeyCodes.escape && ( // eslint-disable-next-line deprecation/deprecation\n      ev.which < 112\n      /* F1 */\n      || ev.which > 123)\n      /* F12 */\n      ) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    }\n  };\n\n  ComboBoxInternal.prototype._handleTouchAndPointerEvent = function () {\n    var _this = this; // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n\n\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n\n      this._lastTouchTimeoutId = undefined;\n    }\n\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  };\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n\n\n  ComboBoxInternal.prototype._getCaretButtonStyles = function () {\n    var customCaretDownButtonStyles = this.props.caretDownButtonStyles;\n    return getCaretDownButtonStyles(this.props.theme, customCaretDownButtonStyles);\n  };\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n\n\n  ComboBoxInternal.prototype._getCurrentOptionStyles = function (item) {\n    var customStylesForAllOptions = this.props.comboBoxOptionStyles;\n    var customStylesForCurrentOption = item.styles;\n    return getOptionStyles(this.props.theme, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item), item.hidden, this._isOptionHighlighted(item.index));\n  };\n  /**\n   * Get the aria-activedescendant value for the combo box.\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n   * null otherwise\n   */\n\n\n  ComboBoxInternal.prototype._getAriaActiveDescendantValue = function () {\n    var selectedIndices = this.props.hoisted.selectedIndices;\n    var _a = this.state,\n        isOpen = _a.isOpen,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex;\n    var descendantText = isOpen && (selectedIndices === null || selectedIndices === void 0 ? void 0 : selectedIndices.length) ? this._id + '-list' + selectedIndices[0] : undefined;\n\n    if (isOpen && this._hasFocus() && currentPendingValueValidIndex !== -1) {\n      descendantText = this._id + '-list' + currentPendingValueValidIndex;\n    }\n\n    return descendantText;\n  };\n  /**\n   * Get the aria autocomplete value for the combo box\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n   * and can dynamically populate input, and 'list' if auto-complete is not enabled as selection is the only option.\n   * Ideally, this should be 'none' if auto-complete is not enabled, but there is a known bug in Edge\n   * where the callout may appear over the combo box if this attribute is set to 'none'\n   */\n\n\n  ComboBoxInternal.prototype._getAriaAutoCompleteValue = function () {\n    var autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n    return autoComplete ? this.props.allowFreeform ? 'inline' : 'both' : 'list';\n  };\n\n  ComboBoxInternal.prototype._isPendingOption = function (item) {\n    return item && item.index === this.state.currentPendingValueValidIndex;\n  };\n  /**\n   * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n   */\n\n\n  ComboBoxInternal.prototype._hasFocus = function () {\n    return this.state.focusState !== 'none';\n  };\n\n  ComboBoxInternal = __decorate([customizable('ComboBox', ['theme', 'styles'], true)], ComboBoxInternal);\n  return ComboBoxInternal;\n}(React.Component);\n/**\n * Get the indices of the options that are marked as selected\n * @param options - the combo box options\n * @param selectedKeys - the known selected keys to find\n * @returns - an array of the indices of the selected options, empty array if nothing is selected\n */\n\n\nfunction getSelectedIndices(options, selectedKeys) {\n  if (!options || !selectedKeys) {\n    return [];\n  }\n\n  var selectedIndices = {};\n  options.forEach(function (option, index) {\n    if (option.selected) {\n      selectedIndices[index] = true;\n    }\n  });\n\n  var _loop_1 = function (selectedKey) {\n    var index = findIndex(options, function (option) {\n      return option.key === selectedKey;\n    });\n\n    if (index > -1) {\n      selectedIndices[index] = true;\n    }\n  };\n\n  for (var _i = 0, selectedKeys_1 = selectedKeys; _i < selectedKeys_1.length; _i++) {\n    var selectedKey = selectedKeys_1[_i];\n\n    _loop_1(selectedKey);\n  }\n\n  return Object.keys(selectedIndices).map(Number).sort();\n}\n/**\n * Given default selected key(s) and selected key(s), return the selected keys(s).\n * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n *\n * @returns No matter what specific types the input parameters are, always return an array of\n *  either strings or numbers instead of primitive type.  This normalization makes caller's logic easier.\n */\n\n\nfunction buildDefaultSelectedKeys(defaultSelectedKey, selectedKey) {\n  var selectedKeys = buildSelectedKeys(defaultSelectedKey);\n\n  if (selectedKeys.length) {\n    return selectedKeys;\n  }\n\n  return buildSelectedKeys(selectedKey);\n}\n\nfunction buildSelectedKeys(selectedKey) {\n  if (selectedKey === undefined) {\n    return [];\n  } // need to cast here so typescript does not complain\n\n\n  return selectedKey instanceof Array ? selectedKey : [selectedKey];\n}\n\nfunction normalizeToString(value) {\n  return value || '';\n}\n/**\n * Is the index within the bounds of the array?\n * @param options - options to check if the index is valid for\n * @param index - the index to check\n * @returns - true if the index is valid for the given options, false otherwise\n */\n\n\nfunction indexWithinBounds(options, index) {\n  return !!options && index >= 0 && index < options.length;\n}\n/** Whether this is a normal option, not a header or divider or select all. */\n\n\nfunction isNormalOption(option) {\n  return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider && option.itemType !== SelectableOptionMenuItemType.SelectAll;\n}\n/** Whether this is a selectable option, not a header or divider. */\n\n\nfunction isSelectableOption(option) {\n  return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider;\n}\n/**\n * For scenarios where the option's `text` prop contains embedded styles, we use the option's\n * `ariaLabel` value as the text in the input and for autocomplete matching. We know to use this\n * when the `useAriaLabelAsText` prop is set to true.\n */\n\n\nfunction getPreviewText(item) {\n  return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n}\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\n\n\nfunction isAltOrMeta(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}","map":{"version":3,"sources":["components/ComboBox/ComboBox.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Autofill } from '../../Autofill';\nimport {\n  initializeComponentRef,\n  css,\n  customizable,\n  divProperties,\n  findElementRecursive,\n  findIndex,\n  focusAsync,\n  getId,\n  getNativeProps,\n  isIOS,\n  isMac,\n  KeyCodes,\n  shallowCompare,\n  mergeAriaAttributeValues,\n  warnMutuallyExclusive,\n  Async,\n  EventGroup,\n  getPropsWithDefaults,\n} from '../../Utilities';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames } from './ComboBox.classNames';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../SelectableOption';\nimport { BaseButton, Button, CommandButton, IconButton } from '../../Button';\nimport { useMergedRefs } from '@fluentui/react-hooks';\nimport type { IAutofill } from '../../Autofill';\nimport type { IRenderFunction } from '../../Utilities';\nimport type { IComboBoxClassNames } from './ComboBox.classNames';\nimport type {\n  IComboBoxOption,\n  IComboBoxOptionStyles,\n  IComboBoxProps,\n  IOnRenderComboBoxLabelProps,\n  IComboBox,\n} from './ComboBox.types';\nimport type { IButtonStyles } from '../../Button';\nimport type { ICalloutProps } from '../../Callout';\nimport { getChildren } from '@fluentui/utilities';\n\nexport interface IComboBoxState {\n  /** The open state */\n  isOpen?: boolean;\n\n  /** The focused state of the combo box */\n  focusState?: 'none' | 'focused' | 'focusing';\n\n  /**\n   * When taking input, this will store the index that the options input matches\n   * (-1 if no input or match)\n   */\n  currentPendingValueValidIndex: number;\n\n  /**\n   * Stores the hovered over value in the dropdown\n   * (used for styling the options without updating the input)\n   */\n  currentPendingValueValidIndexOnHover: number;\n\n  /** When taking input, this will store the actual text that is being entered */\n  currentPendingValue?: string;\n}\n\nenum SearchDirection {\n  backward = -1,\n  none = 0,\n  forward = 1,\n}\n\nenum HoverStatus {\n  /** Used when the user was hovering and has since moused out of the menu items */\n  clearAll = -2,\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n  default = -1,\n}\n\nconst ScrollIdleDelay = 250; /* ms */\nconst TouchIdleDelay = 500; /* ms */\n\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\nconst ReadOnlyPendingAutoCompleteTimeout = 1000; /* ms */\n\ninterface IComboBoxOptionWrapperProps extends IComboBoxOption {\n  /** True if the option is currently selected */\n  isSelected: boolean;\n\n  /** True if the option is currently checked (multi-select) */\n  isChecked: boolean;\n\n  /** True if the option is currently indeterminate (multi-select select all option) */\n  isIndeterminate: boolean;\n\n  /**\n   * A function that returns the children of the OptionWrapper. We pass this in as a function to ensure that\n   * children methods don't get called unnecessarily if the component doesn't need to be updated. This leads\n   * to a significant performance increase in ComboBoxes with many options and/or complex onRenderOption functions\n   */\n  render: () => JSX.Element;\n}\n\n/**\n * Internal component that is used to wrap all ComboBox options.\n * This is used to customize when we want to re-render components,\n * so we don't re-render every option every time render is executed.\n */\nconst ComboBoxOptionWrapper = React.memo(\n  ({ render }: IComboBoxOptionWrapperProps) => render(),\n  (\n    { render: oldRender, ...oldProps }: IComboBoxOptionWrapperProps,\n    { render: newRender, ...newProps }: IComboBoxOptionWrapperProps,\n  ) =>\n    // The render function will always be different, so we ignore that prop\n    shallowCompare(oldProps, newProps),\n);\n\nconst COMPONENT_NAME = 'ComboBox';\nconst DEFAULT_PROPS: Partial<IComboBoxProps> = {\n  options: [],\n  allowFreeform: false,\n  autoComplete: 'on',\n  buttonIconProps: { iconName: 'ChevronDown' },\n};\n\nfunction useOptionsState({ options, defaultSelectedKey, selectedKey }: IComboBoxProps) {\n  /** The currently selected indices */\n  const [selectedIndices, setSelectedIndices] = React.useState<number[]>(() =>\n    getSelectedIndices(options, buildDefaultSelectedKeys(defaultSelectedKey, selectedKey)),\n  );\n  /** The options currently available for the callout */\n  const [currentOptions, setCurrentOptions] = React.useState<IComboBoxOption[]>(options);\n  /** This value is used for the autocomplete hint value */\n  const [suggestedDisplayValue, setSuggestedDisplayValue] = React.useState<string>();\n\n  React.useEffect(() => {\n    if (selectedKey !== undefined) {\n      const selectedKeys: string[] | number[] = buildSelectedKeys(selectedKey);\n      const indices: number[] = getSelectedIndices(options, selectedKeys);\n\n      setSelectedIndices(indices);\n    }\n    setCurrentOptions(options);\n  }, [options, selectedKey]);\n\n  React.useEffect(() => {\n    if (selectedKey === null) {\n      setSuggestedDisplayValue(undefined);\n    }\n  }, [selectedKey]);\n\n  return [\n    selectedIndices,\n    setSelectedIndices,\n    currentOptions,\n    setCurrentOptions,\n    suggestedDisplayValue,\n    setSuggestedDisplayValue,\n  ] as const;\n}\n\nexport const ComboBox: React.FunctionComponent<IComboBoxProps> = React.forwardRef<HTMLDivElement, IComboBoxProps>(\n  (propsWithoutDefaults: IComboBoxProps, forwardedRef: React.Ref<HTMLDivElement>) => {\n    const { ref, ...props } = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const rootRef = React.useRef<HTMLDivElement>(null);\n\n    const mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n    const [\n      selectedIndices,\n      setSelectedIndices,\n      currentOptions,\n      setCurrentOptions,\n      suggestedDisplayValue,\n      setSuggestedDisplayValue,\n    ] = useOptionsState(props);\n\n    return (\n      <ComboBoxInternal\n        {...props}\n        hoisted={{\n          mergedRootRef,\n          rootRef,\n          selectedIndices,\n          setSelectedIndices,\n          currentOptions,\n          setCurrentOptions,\n          suggestedDisplayValue,\n          setSuggestedDisplayValue,\n        }}\n      />\n    );\n  },\n);\nComboBox.displayName = COMPONENT_NAME;\n\ninterface IComboBoxInternalProps extends Omit<IComboBoxProps, 'ref'> {\n  hoisted: {\n    mergedRootRef: React.Ref<HTMLDivElement>;\n    rootRef: React.RefObject<HTMLDivElement>;\n    selectedIndices: number[];\n    currentOptions: IComboBoxOption[];\n    suggestedDisplayValue?: string;\n    setSelectedIndices: React.Dispatch<React.SetStateAction<number[]>>;\n    setCurrentOptions: React.Dispatch<React.SetStateAction<IComboBoxOption[]>>;\n    setSuggestedDisplayValue: React.Dispatch<React.SetStateAction<string | undefined>>;\n  };\n}\n\n/**\n * Depth-first search to find the first descendant element where the match function returns true.\n * @param element - element to start searching at\n * @param match - the function that determines if the element is a match\n * @returns the matched element or null no match was found\n */\nfunction findFirstDescendant(element: HTMLElement, match: (element: HTMLElement) => boolean): HTMLElement | null {\n  const children = getChildren(element);\n\n  // For loop is used because forEach cannot be stopped.\n  for (let index = 0; index < children.length; index++) {\n    const child = children[index];\n    if (match(child)) {\n      return child;\n    }\n    const candidate = findFirstDescendant(child, match);\n    if (candidate) {\n      return candidate;\n    }\n  }\n  return null;\n}\n\n@customizable('ComboBox', ['theme', 'styles'], true)\nclass ComboBoxInternal extends React.Component<IComboBoxInternalProps, IComboBoxState> implements IComboBox {\n  /** The input aspect of the combo box */\n  private _autofill = React.createRef<IAutofill>();\n\n  /** The wrapping div of the input and button */\n  private _comboBoxWrapper = React.createRef<HTMLDivElement>();\n\n  /** The callout element */\n  private _comboBoxMenu = React.createRef<HTMLDivElement>();\n\n  /** The menu item element that is currently selected */\n  private _selectedElement = React.createRef<HTMLSpanElement>();\n\n  /** The base id for the ComboBox */\n  private _id: string;\n\n  /**\n   * After a character is inserted when autocomplete is true and allowFreeform is false,\n   * remember the task that will clear the pending string of characters.\n   */\n  private _autoCompleteTimeout: number | undefined;\n\n  /** Promise used when resolving the comboBox options */\n  private _currentPromise: PromiseLike<IComboBoxOption[]>;\n\n  /** The current visible value sent to the auto fill on render */\n  private _currentVisibleValue: string | undefined;\n  private _classNames: IComboBoxClassNames;\n  private _isScrollIdle: boolean;\n  private _hasPendingValue: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n\n  /**\n   * Determines if we should be setting focus back to the input when the menu closes.\n   * The general rule of thumb is if the menu was launched via the keyboard focus should go back\n   * to the input, if it was dropped via the mouse focus should not be forced back to the input.\n   */\n  private _focusInputAfterClose: boolean;\n\n  /** Flag for when we get the first mouseMove */\n  private _gotMouseMove: boolean;\n\n  private _processingClearPendingInfo: boolean;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IComboBoxInternalProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      defaultSelectedKey: 'selectedKey',\n      text: 'defaultSelectedKey',\n      selectedKey: 'value',\n      dropdownWidth: 'useComboBoxAsMenuWidth',\n      ariaLabel: 'label',\n    });\n\n    this._id = props.id || getId('ComboBox');\n\n    this._isScrollIdle = true;\n    this._processingTouch = false;\n    this._gotMouseMove = false;\n    this._processingClearPendingInfo = false;\n\n    this.state = {\n      isOpen: false,\n      focusState: 'none',\n      currentPendingValueValidIndex: -1,\n      currentPendingValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    };\n  }\n\n  /**\n   * All selected options\n   */\n  public get selectedOptions(): IComboBoxOption[] {\n    const { currentOptions, selectedIndices } = this.props.hoisted;\n\n    return getAllSelectedOptions(currentOptions, selectedIndices!);\n  }\n\n  public componentDidMount(): void {\n    if (this._comboBoxWrapper.current && !this.props.disabled) {\n      // hook up resolving the options if needed on focus\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n        // does not support Pointer events yet.\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n      }\n    }\n  }\n\n  public componentDidUpdate(prevProps: IComboBoxInternalProps, prevState: IComboBoxState) {\n    const {\n      allowFreeform,\n      text,\n      onMenuOpen,\n      onMenuDismissed,\n      hoisted: { selectedIndices },\n    } = this.props;\n    const { isOpen, currentPendingValueValidIndex } = this.state;\n\n    // If we are newly open or are open and the pending valid index changed,\n    // make sure the currently selected/pending option is scrolled into view\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n      // Need this timeout so that the selectedElement ref is correctly updated\n      this._async.setTimeout(() => this._scrollIntoView(), 0);\n    }\n\n    // if an action is taken that put focus in the ComboBox\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\n    // but we are not the activeElement set focus on the input\n    if (\n      this._hasFocus() &&\n      (isOpen ||\n        (prevState.isOpen &&\n          !isOpen &&\n          this._focusInputAfterClose &&\n          this._autofill.current &&\n          document.activeElement !== this._autofill.current.inputElement))\n    ) {\n      this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);\n    }\n\n    // If we should focusAfterClose AND\n    //   just opened/closed the menu OR\n    //   are focused AND\n    //     updated the selectedIndex with the menu closed OR\n    //     are not allowing freeform OR\n    //     the value changed\n    // we need to set selection\n    if (\n      this._focusInputAfterClose &&\n      ((prevState.isOpen && !isOpen) ||\n        (this._hasFocus() &&\n          ((!isOpen &&\n            !this.props.multiSelect &&\n            prevProps.hoisted.selectedIndices &&\n            selectedIndices &&\n            prevProps.hoisted.selectedIndices[0] !== selectedIndices[0]) ||\n            !allowFreeform ||\n            text !== prevProps.text)))\n    ) {\n      this._onFocus();\n    }\n\n    this._notifyPendingValueChanged(prevState);\n\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\n      onMenuOpen();\n    }\n\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\n      onMenuDismissed();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  // Primary Render\n  public render(): JSX.Element {\n    const id = this._id;\n    const errorMessageId = id + '-error';\n    const {\n      className,\n      disabled,\n      required,\n      errorMessage,\n      onRenderContainer = this._onRenderContainer,\n      onRenderLabel = this._onRenderLabel,\n      onRenderList = this._onRenderList,\n      onRenderItem = this._onRenderItem,\n      onRenderOption = this._onRenderOptionContent,\n      allowFreeform,\n      styles: customStyles,\n      theme,\n      persistMenu,\n      multiSelect,\n      hoisted: { suggestedDisplayValue, selectedIndices, currentOptions },\n    } = this.props;\n    const { isOpen } = this.state;\n    this._currentVisibleValue = this._getVisibleValue();\n\n    // Single select is already accessible since the whole text is selected\n    // when focus enters the input. Since multiselect appears to clear the input\n    // it needs special accessible text\n    const multiselectAccessibleText = multiSelect\n      ? this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue)\n      : undefined;\n\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onChange',\n      'value',\n      'aria-describedby',\n      'aria-labelledby',\n    ]);\n\n    const hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n\n    this._classNames = this.props.getClassNames\n      ? this.props.getClassNames(\n          theme!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n          className,\n        )\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          className!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n        );\n\n    const comboBoxWrapper = this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId);\n\n    return (\n      <div {...divProps} ref={this.props.hoisted.mergedRootRef} className={this._classNames.container}>\n        {onRenderLabel({ props: this.props, multiselectAccessibleText }, this._onRenderLabel)}\n        {comboBoxWrapper}\n        {(persistMenu || isOpen) &&\n          onRenderContainer(\n            {\n              ...this.props,\n              onRenderList,\n              onRenderItem,\n              onRenderOption,\n              options: currentOptions.map((item, index) => ({ ...item, index: index })),\n              onDismiss: this._onDismiss,\n            },\n            this._onRenderContainer,\n          )}\n        {hasErrorMessage && (\n          <div role=\"alert\" id={errorMessageId} className={this._classNames.errorMessage}>\n            {errorMessage}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public focus = (shouldOpenOnFocus?: boolean, useFocusAsync?: boolean): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (this._autofill.current) {\n      if (useFocusAsync) {\n        focusAsync(this._autofill.current);\n      } else {\n        this._autofill.current.focus();\n      }\n\n      if (shouldOpenOnFocus) {\n        this.setState({\n          isOpen: true,\n        });\n      }\n    }\n\n    // Programmatically setting focus means that there is nothing else that needs to be done\n    // Focus is now contained\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Close menu callout if it is open\n   */\n  public dismissMenu = (): void => {\n    const { isOpen } = this.state;\n    isOpen && this.setState({ isOpen: false });\n  };\n\n  /**\n   * componentWillReceiveProps handler for the auto fill component\n   * Checks/updates the input value to set, if needed\n   * @param defaultVisibleValue - the defaultVisibleValue that got passed\n   *  in to the auto fill's componentWillReceiveProps\n   * @returns - the updated value to set, if needed\n   */\n  private _onUpdateValueInAutofillWillReceiveProps = (): string | null => {\n    const comboBox = this._autofill.current;\n\n    if (!comboBox) {\n      return null;\n    }\n\n    if (comboBox.value === null || comboBox.value === undefined) {\n      return null;\n    }\n\n    const visibleValue = normalizeToString(this._currentVisibleValue);\n    if (comboBox.value !== visibleValue) {\n      return visibleValue;\n    }\n\n    return comboBox.value;\n  };\n\n  private _renderComboBoxWrapper = (\n    multiselectAccessibleText: string | undefined,\n    errorMessageId: string,\n  ): JSX.Element => {\n    const {\n      label,\n      disabled,\n      ariaLabel,\n      ariaDescribedBy = this.props['aria-describedby'],\n      required,\n      errorMessage,\n      buttonIconProps,\n      isButtonAriaHidden = true,\n      title,\n      placeholder: placeholderProp,\n      tabIndex,\n      autofill,\n      iconButtonProps,\n      hoisted: { suggestedDisplayValue },\n    } = this.props;\n\n    const { isOpen } = this.state;\n\n    // If the combo box has focus, is multiselect, and has a display string, then use that placeholder\n    // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n    // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n    // should be removed and the multiselect combo box should behave like a picker.\n    const placeholder =\n      this._hasFocus() && this.props.multiSelect && multiselectAccessibleText\n        ? multiselectAccessibleText\n        : placeholderProp;\n\n    const labelledBy = [this.props['aria-labelledby'], label && this._id + '-label'].join(' ').trim();\n\n    return (\n      <div\n        data-ktp-target={true}\n        ref={this._comboBoxWrapper}\n        id={this._id + 'wrapper'}\n        className={this._classNames.root}\n        aria-owns={isOpen ? this._id + '-list' : undefined}\n      >\n        <Autofill\n          data-ktp-execute-target={true}\n          data-is-interactable={!disabled}\n          componentRef={this._autofill}\n          id={this._id + '-input'}\n          className={this._classNames.input}\n          type=\"text\"\n          onFocus={this._onFocus}\n          onBlur={this._onBlur}\n          onKeyDown={this._onInputKeyDown}\n          onKeyUp={this._onInputKeyUp}\n          onClick={this._onAutofillClick}\n          onTouchStart={this._onTouchStart}\n          onInputValueChange={this._onInputChange}\n          aria-expanded={isOpen}\n          aria-autocomplete={this._getAriaAutoCompleteValue()}\n          role=\"combobox\"\n          readOnly={disabled}\n          aria-labelledby={labelledBy ? labelledBy : undefined}\n          aria-label={ariaLabel && !label ? ariaLabel : undefined}\n          aria-describedby={\n            errorMessage !== undefined ? mergeAriaAttributeValues(ariaDescribedBy, errorMessageId) : ariaDescribedBy\n          }\n          aria-activedescendant={this._getAriaActiveDescendantValue()}\n          aria-required={required}\n          aria-disabled={disabled}\n          aria-controls={isOpen ? this._id + '-list' : undefined}\n          spellCheck={false}\n          defaultVisibleValue={this._currentVisibleValue}\n          suggestedDisplayValue={suggestedDisplayValue}\n          updateValueInWillReceiveProps={this._onUpdateValueInAutofillWillReceiveProps}\n          shouldSelectFullInputValueInComponentDidUpdate={\n            this._onShouldSelectFullInputValueInAutofillComponentDidUpdate\n          }\n          title={title}\n          preventValueSelection={!this._hasFocus()}\n          placeholder={placeholder}\n          tabIndex={disabled ? -1 : tabIndex}\n          {...autofill}\n        />\n        <IconButton\n          className={'ms-ComboBox-CaretDown-button'}\n          styles={this._getCaretButtonStyles()}\n          role=\"presentation\"\n          aria-hidden={isButtonAriaHidden}\n          data-is-focusable={false}\n          tabIndex={-1}\n          onClick={this._onComboBoxClick}\n          onBlur={this._onBlur}\n          iconProps={buttonIconProps}\n          disabled={disabled}\n          checked={isOpen}\n          {...iconButtonProps}\n        />\n      </div>\n    );\n  };\n\n  /**\n   * componentDidUpdate handler for the auto fill component\n   *\n   * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n   * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n   * @returns - should the full value of the input be selected?\n   * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n   */\n  private _onShouldSelectFullInputValueInAutofillComponentDidUpdate = (): boolean => {\n    return this._currentVisibleValue === this.props.hoisted.suggestedDisplayValue;\n  };\n\n  /**\n   * Get the correct value to pass to the input\n   * to show to the user based off of the current props and state\n   * @returns the value to pass to the input\n   */\n  private _getVisibleValue = (): string | undefined => {\n    const {\n      text,\n      allowFreeform,\n      autoComplete,\n      hoisted: { suggestedDisplayValue, selectedIndices, currentOptions },\n    } = this.props;\n    const { currentPendingValueValidIndex, currentPendingValue, isOpen } = this.state;\n\n    const currentPendingIndexValid = indexWithinBounds(currentOptions, currentPendingValueValidIndex);\n\n    // If the user passed is a value prop, use that\n    // unless we are open and have a valid current pending index\n    if (\n      !(isOpen && currentPendingIndexValid) &&\n      text &&\n      (currentPendingValue === null || currentPendingValue === undefined)\n    ) {\n      return text;\n    }\n\n    if (this.props.multiSelect) {\n      // Multi-select\n      if (this._hasFocus()) {\n        let index = -1;\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        return this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n      }\n    } else {\n      // Single-select\n      let index: number = this._getFirstSelectedIndex();\n      if (allowFreeform) {\n        // If we are allowing freeform and autocomplete is also true\n        // and we've got a pending value that matches an option, remember\n        // the matched option's index\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n\n        // Since we are allowing freeform, if there is currently a pending value, use that\n        // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        // If we are not allowing freeform and have a valid index that matches the pending value,\n        // we know we will need some version of the pending value\n        if (currentPendingIndexValid && autoComplete === 'on') {\n          // If autoComplete is on, return the raw pending value, otherwise remember\n          // the matched option's index\n          index = currentPendingValueValidIndex;\n          return normalizeToString(currentPendingValue);\n        } else if (!this.state.isOpen && currentPendingValue) {\n          return indexWithinBounds(currentOptions, index)\n            ? currentPendingValue\n            : normalizeToString(suggestedDisplayValue);\n        } else {\n          return indexWithinBounds(currentOptions, index)\n            ? getPreviewText(currentOptions[index])\n            : normalizeToString(suggestedDisplayValue);\n        }\n      }\n    }\n  };\n\n  private _getPendingString(\n    currentPendingValue: string | null | undefined,\n    currentOptions: IComboBoxOption[],\n    index: number,\n  ) {\n    return currentPendingValue !== null && currentPendingValue !== undefined\n      ? currentPendingValue\n      : indexWithinBounds(currentOptions, index)\n      ? getPreviewText(currentOptions[index])\n      : '';\n  }\n\n  /**\n   * Returns a string that concatenates all of the selected values\n   * for multiselect combo box.\n   */\n  private _getMultiselectDisplayString(\n    selectedIndices: number[] | undefined,\n    currentOptions: IComboBoxOption[],\n    suggestedDisplayValue: string | undefined,\n  ) {\n    const displayValues = [];\n    for (let idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n      const index: number = selectedIndices[idx];\n      if (currentOptions[index].itemType !== SelectableOptionMenuItemType.SelectAll) {\n        displayValues.push(\n          indexWithinBounds(currentOptions, index)\n            ? currentOptions[index].text\n            : normalizeToString(suggestedDisplayValue),\n        );\n      }\n    }\n    const { multiSelectDelimiter = ', ' } = this.props;\n    return displayValues.join(multiSelectDelimiter);\n  }\n\n  /**\n   * Handler for typing changes on the input\n   * @param updatedValue - the newly changed value\n   */\n  private _onInputChange = (updatedValue: string): void => {\n    if (this.props.disabled) {\n      this._handleInputWhenDisabled(null /* event */);\n      return;\n    }\n\n    if (this.props.onInputValueChange) {\n      this.props.onInputValueChange(updatedValue);\n    }\n\n    this.props.allowFreeform\n      ? this._processInputChangeWithFreeform(updatedValue)\n      : this._processInputChangeWithoutFreeform(updatedValue);\n  };\n\n  /**\n   * Process the new input's new value when the combo box allows freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithFreeform(updatedValue: string): void {\n    const { currentOptions } = this.props.hoisted;\n    let newCurrentPendingValueValidIndex = -1;\n\n    // if the new value is empty, see if we have an exact match and then set the pending info\n    if (updatedValue === '') {\n      const items = currentOptions\n        .map((item, index) => ({ ...item, index }))\n        .filter(option => isNormalOption(option) && getPreviewText(option) === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n      return;\n    }\n\n    // Remember the original value and then make the value lowercase for comparison\n    const originalUpdatedValue: string = updatedValue;\n    updatedValue = updatedValue.toLocaleLowerCase();\n\n    let newSuggestedDisplayValue = '';\n\n    // If autoComplete is on, attempt to find a match from the available options\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n      const items = currentOptions\n        .map((item, index) => ({ ...item, index }))\n        .filter(\n          option => isNormalOption(option) && getPreviewText(option).toLocaleLowerCase().indexOf(updatedValue) === 0,\n        );\n      if (items.length > 0) {\n        // use ariaLabel as the value when the option is set\n        const text: string = getPreviewText(items[0]);\n\n        // If the user typed out the complete option text, we don't need any suggested display text anymore\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';\n\n        // remember the index of the match we found\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } else {\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n      const items = currentOptions\n        .map((item, index) => ({ ...item, index }))\n        .filter(option => isNormalOption(option) && getPreviewText(option).toLocaleLowerCase() === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    }\n\n    // Set the updated state\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n  }\n\n  /**\n   * Process the new input's new value when the combo box does not allow freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithoutFreeform(updatedValue: string): void {\n    const { currentOptions } = this.props.hoisted;\n    const { currentPendingValue, currentPendingValueValidIndex } = this.state;\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on while allow freeform is off,\n      // we will remember the key press and build up a string to attempt to match\n      // as long as characters are typed within a the timeout span of each other,\n      // otherwise we will clear the string and start building a new one on the next keypress.\n      // Also, only do this processing if we have a non-empty value\n      if (updatedValue !== '') {\n        // If we have a pending autocomplete clearing task,\n        // we know that the user is typing with key press happening\n        // within the timeout of each other so remove the clearing task\n        // and continue building the pending value with the updated value\n        if (this._autoCompleteTimeout) {\n          this._async.clearTimeout(this._autoCompleteTimeout);\n          this._autoCompleteTimeout = undefined;\n          updatedValue = normalizeToString(currentPendingValue) + updatedValue;\n        }\n\n        const originalUpdatedValue: string = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase();\n\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n        const items = currentOptions\n          .map((item, i) => ({ ...item, index: i }))\n\n          .filter(option => isNormalOption(option) && option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\n\n        // If we found a match, update the state\n        if (items.length > 0) {\n          this._setPendingInfo(originalUpdatedValue, items[0].index, getPreviewText(items[0]));\n        }\n\n        // Schedule a timeout to clear the pending value after the timeout span\n        this._autoCompleteTimeout = this._async.setTimeout(() => {\n          this._autoCompleteTimeout = undefined;\n        }, ReadOnlyPendingAutoCompleteTimeout);\n        return;\n      }\n    }\n\n    // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n    // use that; otherwise use the selectedIndex\n    const index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\n\n    // Since we are not allowing freeform, we need to\n    // set both the pending and suggested values/index\n    // to allow us to select all content in the input to\n    // give the illusion that we are readonly (e.g. freeform off)\n    this._setPendingInfoFromIndex(index);\n  }\n\n  private _getFirstSelectedIndex(): number {\n    const { selectedIndices } = this.props.hoisted;\n    return selectedIndices?.length ? selectedIndices[0] : -1;\n  }\n\n  /**\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\n   * @param index - the index to get the next selectable index from\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n   */\n  private _getNextSelectableIndex(index: number, searchDirection: SearchDirection): number {\n    const { currentOptions } = this.props.hoisted;\n\n    let newIndex = index + searchDirection;\n\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n\n    if (!indexWithinBounds(currentOptions, newIndex)) {\n      return -1;\n    }\n\n    const option: IComboBoxOption = currentOptions[newIndex];\n\n    if (!isSelectableOption(option) || option.hidden === true) {\n      // Should we continue looking for an index to select?\n      if (\n        searchDirection !== SearchDirection.none &&\n        ((newIndex > 0 && searchDirection < SearchDirection.none) ||\n          (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))\n      ) {\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n      } else {\n        // If we cannot perform a useful search just return the index we were given\n        return index;\n      }\n    }\n\n    // We have the next valid selectable index, return it\n    return newIndex;\n  }\n\n  /**\n   * Set the selected index. Note, this is\n   * the \"real\" selected index, not the pending selected index\n   * @param index - the index to set (or the index to set from if a search direction is provided)\n   * @param searchDirection - the direction to search along the options from the given index\n   */\n  private _setSelectedIndex(\n    index: number,\n    submitPendingValueEvent: React.SyntheticEvent<any>,\n    searchDirection: SearchDirection = SearchDirection.none,\n  ): void {\n    const {\n      onChange,\n      onPendingValueChanged,\n      hoisted: { selectedIndices: initialIndices, currentOptions },\n    } = this.props;\n\n    // Clone currentOptions and selectedIndices so we don't mutate state\n    let selectedIndices = initialIndices ? initialIndices.slice() : [];\n    let changedOptions = currentOptions.slice();\n\n    // Find the next selectable index, if searchDirection is none\n    // we will get our starting index back\n    index = this._getNextSelectableIndex(index, searchDirection);\n\n    if (!indexWithinBounds(currentOptions, index)) {\n      return;\n    }\n\n    // Are we at a new index? If so, update the state, otherwise\n    // there is nothing to do\n    if (\n      this.props.multiSelect ||\n      selectedIndices.length < 1 ||\n      (selectedIndices.length === 1 && selectedIndices[0] !== index)\n    ) {\n      const option: IComboBoxOption = { ...currentOptions[index] };\n      // if option doesn't existing, or option is disabled, we noop\n      if (!option || option.disabled) {\n        return;\n      }\n      if (this.props.multiSelect) {\n        // Setting the initial state of option.selected in Multi-select combo box by checking the\n        // selectedIndices array and overriding the undefined issue\n        option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;\n\n        // handle changing all options if SelectAll is changed\n        if (option.itemType === SelectableOptionMenuItemType.SelectAll) {\n          selectedIndices = [];\n          // if select all is set to checked, push all selectable option indices\n          if (option.selected) {\n            currentOptions.forEach((currentOption, i) => {\n              if (!currentOption.disabled && isSelectableOption(currentOption)) {\n                selectedIndices.push(i);\n                changedOptions[i] = { ...currentOption, selected: true };\n              }\n            });\n          }\n          // otherwise un-check all options\n          else {\n            changedOptions = currentOptions.map(currentOption => ({ ...currentOption, selected: false }));\n          }\n        }\n        // otherwise update the individual option\n        else {\n          if (option.selected && selectedIndices.indexOf(index) < 0) {\n            selectedIndices.push(index);\n          } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\n            selectedIndices = selectedIndices.filter((value: number) => value !== index);\n          }\n          changedOptions[index] = option;\n\n          // If SelectAll exists and another option was toggled, update the SelectAll option's state\n          const selectAllOption = changedOptions.filter(o => o.itemType === SelectableOptionMenuItemType.SelectAll)[0];\n          if (selectAllOption) {\n            const selectAllState = this._isSelectAllChecked(selectedIndices);\n            const selectAllIndex = changedOptions.indexOf(selectAllOption);\n            if (selectAllState) {\n              selectedIndices.push(selectAllIndex);\n              changedOptions[selectAllIndex] = { ...selectAllOption, selected: true };\n            } else {\n              selectedIndices = selectedIndices.filter((value: number) => value !== selectAllIndex);\n              changedOptions[selectAllIndex] = { ...selectAllOption, selected: false };\n            }\n          }\n        }\n      } else {\n        selectedIndices[0] = index;\n      }\n\n      submitPendingValueEvent.persist();\n\n      // Only setState if combo box is uncontrolled.\n      if (this.props.selectedKey || this.props.selectedKey === null) {\n        // If combo box value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n      } else {\n        this.props.hoisted.setSelectedIndices(selectedIndices);\n        this.props.hoisted.setCurrentOptions(changedOptions);\n\n        // If ComboBox value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n      }\n\n      // Call onChange after state is updated\n      if (onChange) {\n        onChange(submitPendingValueEvent, option, index, getPreviewText(option));\n      }\n    }\n    if (this.props.multiSelect && this.state.isOpen) {\n      return;\n    }\n    // clear all of the pending info\n    this._clearPendingInfo();\n  }\n\n  /**\n   * Focus (and select) the content of the input\n   * and set the focused state\n   */\n  private _onFocus = (): void => {\n    this._autofill.current?.inputElement?.select();\n\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focusing' });\n    }\n  };\n\n  /**\n   * Callback issued when the options should be resolved, if they have been updated or\n   * if they need to be passed in the first time. This only does work if an onResolveOptions\n   * callback was passed in\n   */\n  private _onResolveOptions = (): void => {\n    if (this.props.onResolveOptions) {\n      // get the options\n      const newOptions = this.props.onResolveOptions([...this.props.hoisted.currentOptions]);\n\n      // Check to see if the returned value is an array, if it is update the state\n      // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n      // If it is then resolve it asynchronously.\n      if (Array.isArray(newOptions)) {\n        this.props.hoisted.setCurrentOptions(newOptions);\n      } else if (newOptions && (newOptions as PromiseLike<IComboBoxOption[]>).then) {\n        // Ensure that the promise will only use the callback if it was the most recent one\n        // and update the state when the promise returns\n        this._currentPromise = newOptions;\n        newOptions.then((newOptionsFromPromise: IComboBoxOption[]) => {\n          if (newOptions === this._currentPromise) {\n            this.props.hoisted.setCurrentOptions(newOptionsFromPromise);\n          }\n        });\n      }\n    }\n  };\n\n  /**\n   * OnBlur handler. Set the focused state to false\n   * and submit any pending value\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  private _onBlur = (event: React.FocusEvent<HTMLElement | Autofill | BaseButton | Button>): void => {\n    // Do nothing if the blur is coming from something\n    // inside the comboBox root or the comboBox menu since\n    // it we are not really blurring from the whole comboBox\n    let relatedTarget = event.relatedTarget;\n    if (event.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = document.activeElement as Element;\n    }\n\n    if (relatedTarget) {\n      const isBlurFromComboBoxTitle = this.props.hoisted.rootRef.current?.contains(relatedTarget as HTMLElement);\n      const isBlurFromComboBoxMenu = this._comboBoxMenu.current?.contains(relatedTarget as HTMLElement);\n      const isBlurFromComboBoxMenuAncestor =\n        this._comboBoxMenu.current &&\n        findElementRecursive(this._comboBoxMenu.current, (element: HTMLElement) => element === relatedTarget);\n\n      if (isBlurFromComboBoxTitle || isBlurFromComboBoxMenu || isBlurFromComboBoxMenuAncestor) {\n        if (\n          isBlurFromComboBoxMenuAncestor &&\n          this._hasFocus() &&\n          (!this.props.multiSelect || this.props.allowFreeform)\n        ) {\n          this._submitPendingValue(event);\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n    }\n\n    if (this._hasFocus()) {\n      this.setState({ focusState: 'none' });\n      if (!this.props.multiSelect || this.props.allowFreeform) {\n        this._submitPendingValue(event);\n      }\n    }\n  };\n\n  /**\n   * Submit a pending value if there is one\n   */\n  private _submitPendingValue(submitPendingValueEvent: React.SyntheticEvent<any>): void {\n    const { onChange, allowFreeform, autoComplete, multiSelect, hoisted } = this.props;\n    const { currentOptions } = hoisted;\n    const { currentPendingValue, currentPendingValueValidIndex, currentPendingValueValidIndexOnHover } = this.state;\n    let { selectedIndices } = this.props.hoisted;\n\n    // Do not submit any pending value if we\n    // have already initiated clearing the pending info\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    // If we allow freeform we need to handle that\n    if (allowFreeform) {\n      // if currentPendingValue is null or undefined the user did not submit anything\n      // (not even empty because we would have stored that as the pending value)\n      if (currentPendingValue === null || currentPendingValue === undefined) {\n        // if a user did not type anything they may just hovered over an item\n        if (currentPendingValueValidIndexOnHover >= 0) {\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n          this._clearPendingInfo();\n        }\n\n        return;\n      }\n\n      // Check to see if the user typed an exact match\n      if (indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n        const pendingOptionText = getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();\n        const autofill = this._autofill.current;\n\n        // By exact match, that means: our pending value is the same as the pending option text OR\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\n        // where the total length is equal to pending option length OR\n        // the live value in the underlying input matches the pending option; update the state\n        if (\n          currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\n          (autoComplete &&\n            pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\n            autofill?.isValueSelected &&\n            currentPendingValue.length + (autofill.selectionEnd! - autofill.selectionStart!) ===\n              pendingOptionText.length) ||\n          autofill?.inputElement?.value.toLocaleLowerCase() === pendingOptionText\n        ) {\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n          if (multiSelect && this.state.isOpen) {\n            return;\n          }\n          this._clearPendingInfo();\n          return;\n        }\n      }\n\n      if (onChange) {\n        if (onChange) {\n          // trigger onChange to clear value\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n        }\n      } else {\n        // If we are not controlled, create a new selected option\n        const newOption: IComboBoxOption = {\n          key: currentPendingValue || getId(),\n          text: normalizeToString(currentPendingValue),\n        };\n        // If it's multiselect, set selected state to true\n        if (multiSelect) {\n          newOption.selected = true;\n        }\n        const newOptions: IComboBoxOption[] = currentOptions.concat([newOption]);\n        if (selectedIndices) {\n          if (!multiSelect) {\n            selectedIndices = [];\n          }\n          selectedIndices.push(newOptions.length - 1);\n        }\n        hoisted.setCurrentOptions(newOptions);\n        hoisted.setSelectedIndices(selectedIndices);\n      }\n    } else if (currentPendingValueValidIndex >= 0) {\n      // Since we are not allowing freeform, we must have a matching\n      // to be able to update state\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\n      // If all else failed and we were hovering over an item, select it\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n    }\n\n    // Finally, clear the pending info\n    this._clearPendingInfo();\n  }\n\n  // Render Callout container and pass in list\n  private _onRenderContainer = (props: IComboBoxProps, defaultRender: IRenderFunction<IComboBoxProps>): JSX.Element => {\n    const {\n      onRenderList,\n      calloutProps,\n      dropdownWidth,\n      dropdownMaxWidth,\n      onRenderUpperContent = this._onRenderUpperContent,\n      onRenderLowerContent = this._onRenderLowerContent,\n      useComboBoxAsMenuWidth,\n      persistMenu,\n      shouldRestoreFocus = true,\n    } = props;\n\n    const { isOpen } = this.state;\n    const id = this._id;\n\n    const comboBoxMenuWidth =\n      useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n        ? this._comboBoxWrapper.current.clientWidth + 2\n        : undefined;\n\n    return (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={0}\n        doNotLayer={false}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintFixed={false}\n        {...calloutProps}\n        onLayerMounted={this._onLayerMounted}\n        className={css(this._classNames.callout, calloutProps?.className)}\n        target={this._comboBoxWrapper.current}\n        onDismiss={this._onDismiss}\n        onMouseDown={this._onCalloutMouseDown}\n        onScroll={this._onScroll}\n        setInitialFocus={false}\n        calloutWidth={\n          useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n            ? comboBoxMenuWidth && comboBoxMenuWidth\n            : dropdownWidth\n        }\n        calloutMaxWidth={dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth}\n        hidden={persistMenu ? !isOpen : undefined}\n        shouldRestoreFocus={shouldRestoreFocus}\n      >\n        {onRenderUpperContent(this.props, this._onRenderUpperContent)}\n        <div className={this._classNames.optionsContainerWrapper} ref={this._comboBoxMenu}>\n          {onRenderList?.({ ...props, id }, this._onRenderList)}\n        </div>\n        {onRenderLowerContent(this.props, this._onRenderLowerContent)}\n      </Callout>\n    );\n  };\n\n  private _onCalloutLayerMounted() {\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\n    // of the component. Any functionality required for callout \"on mount\" can\n    // go here so that we can also call it again during callout dismissal to reset\n    // object state.\n    this._gotMouseMove = false;\n  }\n\n  private _onLayerMounted = () => {\n    this._onCalloutLayerMounted();\n\n    // need to call this again here to get the correct scroll parent dimensions\n    // when the callout is first opened\n    this._async.setTimeout(() => {\n      this._scrollIntoView();\n    }, 0);\n\n    if (this.props.calloutProps && this.props.calloutProps.onLayerMounted) {\n      this.props.calloutProps.onLayerMounted();\n    }\n  };\n\n  private _onRenderLabel = (onRenderLabelProps: IOnRenderComboBoxLabelProps): JSX.Element | null => {\n    const { label, disabled, required } = onRenderLabelProps.props;\n\n    if (label) {\n      return (\n        <Label id={this._id + '-label'} disabled={disabled} required={required} className={this._classNames.label}>\n          {label}\n          {onRenderLabelProps.multiselectAccessibleText && (\n            <span className={this._classNames.screenReaderText}>{onRenderLabelProps.multiselectAccessibleText}</span>\n          )}\n        </Label>\n      );\n    }\n\n    return null;\n  };\n\n  // Render List of items\n  private _onRenderList = (props: IComboBoxProps): JSX.Element => {\n    const { onRenderItem = this._onRenderItem, label, ariaLabel, multiSelect } = props;\n\n    let queue: { id?: string; items: JSX.Element[] } = { items: [] };\n    let renderedList: JSX.Element[] = [];\n\n    const emptyQueue = (): void => {\n      const newGroup = queue.id\n        ? [\n            <div role=\"group\" key={queue.id} aria-labelledby={queue.id}>\n              {queue.items}\n            </div>,\n          ]\n        : queue.items;\n\n      renderedList = [...renderedList, ...newGroup];\n      // Flush items and id\n      queue = { items: [] };\n    };\n\n    const placeRenderedOptionIntoQueue = (item: IComboBoxOption, index: number) => {\n      /*\n        Case Header\n          empty queue if it's not already empty\n          ensure unique ID for header and set queue ID\n          push header into queue\n        Case Divider\n          push divider into queue if not first item\n          empty queue if not already empty\n        Default\n          push item into queue\n      */\n      switch (item.itemType) {\n        case SelectableOptionMenuItemType.Header:\n          queue.items.length > 0 && emptyQueue();\n\n          const id = this._id + item.key;\n          queue.items.push(onRenderItem({ id, ...item, index }, this._onRenderItem)!);\n          queue.id = id;\n          break;\n        case SelectableOptionMenuItemType.Divider:\n          index > 0 && queue.items.push(onRenderItem({ ...item, index }, this._onRenderItem)!);\n\n          queue.items.length > 0 && emptyQueue();\n          break;\n        default:\n          queue.items.push(onRenderItem({ ...item, index }, this._onRenderItem)!);\n      }\n    };\n\n    // Place options into the queue. Queue will be emptied anytime a Header or Divider is encountered\n    props.options.forEach((item: IComboBoxOption, index: number) => {\n      placeRenderedOptionIntoQueue(item, index);\n    });\n\n    // Push remaining items into all renderedList\n    queue.items.length > 0 && emptyQueue();\n\n    const id = this._id;\n    return (\n      <div\n        id={id + '-list'}\n        className={this._classNames.optionsContainer}\n        aria-labelledby={label && id + '-label'}\n        aria-label={ariaLabel && !label ? ariaLabel : undefined}\n        aria-multiselectable={multiSelect ? 'true' : undefined}\n        role=\"listbox\"\n      >\n        {renderedList}\n      </div>\n    );\n  };\n\n  // Render items\n  private _onRenderItem = (item: IComboBoxOption): JSX.Element | null => {\n    switch (item.itemType) {\n      case SelectableOptionMenuItemType.Divider:\n        return this._renderSeparator(item);\n      case SelectableOptionMenuItemType.Header:\n        return this._renderHeader(item);\n      default:\n        return this._renderOption(item);\n    }\n  };\n\n  // Default _onRenderLowerContent function returns nothing\n  private _onRenderLowerContent = (): null => {\n    return null;\n  };\n\n  // Default _onRenderUpperContent function returns nothing\n  private _onRenderUpperContent = (): null => {\n    return null;\n  };\n\n  // Render separator\n  private _renderSeparator(item: IComboBoxOption): JSX.Element | null {\n    const { index, key } = item;\n\n    if (index && index > 0) {\n      return <div role=\"separator\" key={key} className={this._classNames.divider} />;\n    }\n    return null;\n  }\n\n  private _renderHeader(item: IComboBoxOption): JSX.Element {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n\n    return (\n      <div id={item.id} key={item.key} className={this._classNames.header}>\n        {onRenderOption(item, this._onRenderOptionContent)}\n      </div>\n    );\n  }\n\n  private _renderOption = (item: IComboBoxOption): JSX.Element => {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n    const id = this._id;\n    const isSelected: boolean = this._isOptionSelected(item.index);\n    const isChecked: boolean = this._isOptionChecked(item.index);\n    const isIndeterminate: boolean = this._isOptionIndeterminate(item.index);\n    const optionStyles = this._getCurrentOptionStyles(item);\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    const title = item.title;\n\n    const onRenderCheckboxLabel = () => onRenderOption(item, this._onRenderOptionContent);\n\n    const getOptionComponent = () => {\n      return !this.props.multiSelect ? (\n        <CommandButton\n          id={id + '-list' + item.index}\n          key={item.key}\n          data-index={item.index}\n          styles={optionStyles}\n          checked={isSelected}\n          className={'ms-ComboBox-option'}\n          onClick={this._onItemClick(item)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseEnter={this._onOptionMouseEnter.bind(this, item.index)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseMove={this._onOptionMouseMove.bind(this, item.index)}\n          onMouseLeave={this._onOptionMouseLeave}\n          role=\"option\"\n          // aria-selected should only be applied to checked items, not hovered items\n          aria-selected={isSelected ? 'true' : 'false'}\n          ariaLabel={item.ariaLabel}\n          disabled={item.disabled}\n          title={title}\n        >\n          {\n            <span className={optionClassNames.optionTextWrapper} ref={isSelected ? this._selectedElement : undefined}>\n              {onRenderOption(item, this._onRenderOptionContent)}\n            </span>\n          }\n        </CommandButton>\n      ) : (\n        <Checkbox\n          id={id + '-list' + item.index}\n          ariaLabel={item.ariaLabel}\n          key={item.key}\n          styles={optionStyles}\n          className={'ms-ComboBox-option'}\n          onChange={this._onItemClick(item)}\n          label={item.text}\n          checked={isChecked}\n          indeterminate={isIndeterminate}\n          title={title}\n          disabled={item.disabled}\n          // eslint-disable-next-line react/jsx-no-bind\n          onRenderLabel={onRenderCheckboxLabel}\n          inputProps={{\n            // aria-selected should only be applied to checked items, not hovered items\n            'aria-selected': isChecked ? 'true' : 'false',\n            role: 'option',\n            ...({\n              'data-index': item.index,\n              'data-is-focusable': true,\n            } as any),\n          }}\n        />\n      );\n    };\n\n    return (\n      <ComboBoxOptionWrapper\n        key={item.key}\n        index={item.index}\n        disabled={item.disabled}\n        isSelected={isSelected}\n        isChecked={isChecked}\n        isIndeterminate={isIndeterminate}\n        text={item.text}\n        // eslint-disable-next-line react/jsx-no-bind\n        render={getOptionComponent}\n        data={item.data}\n      />\n    );\n  };\n\n  /**\n   * If we are coming from a mouseOut:\n   * there is no visible selected option.\n   *\n   * Else if We are hovering over an item:\n   * that gets the selected look.\n   *\n   * Else:\n   * Use the current valid pending index if it exists OR\n   * we do not have a valid index and we currently have a pending input value,\n   * otherwise use the selected index\n   * */\n  private _isOptionHighlighted(index: number | undefined): boolean {\n    const { currentPendingValueValidIndexOnHover } = this.state;\n\n    // If the hover state is set to clearAll, don't show a selected index.\n    // Note, this happens when the user moused out of the menu items\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n      return false;\n    }\n\n    return currentPendingValueValidIndexOnHover >= 0\n      ? currentPendingValueValidIndexOnHover === index\n      : this._isOptionSelected(index);\n  }\n\n  private _isOptionSelected(index: number | undefined): boolean {\n    return this._getPendingSelectedIndex(true /* includePendingValue */) === index;\n  }\n\n  private _isOptionChecked(index: number | undefined): boolean {\n    if (this.props.multiSelect && index !== undefined && this.props.hoisted.selectedIndices) {\n      let idxOfSelectedIndex = -1;\n\n      idxOfSelectedIndex = this.props.hoisted.selectedIndices.indexOf(index);\n      return idxOfSelectedIndex >= 0;\n    }\n    return false;\n  }\n\n  private _isOptionIndeterminate(index: number | undefined): boolean {\n    const { multiSelect, hoisted } = this.props;\n\n    if (multiSelect && index !== undefined && hoisted.selectedIndices && hoisted.currentOptions) {\n      const option = hoisted.currentOptions[index];\n      if (option && option.itemType === SelectableOptionMenuItemType.SelectAll) {\n        return hoisted.selectedIndices.length > 0 && !this._isSelectAllChecked();\n      }\n    }\n\n    return false;\n  }\n\n  private _isSelectAllChecked(testIndices?: number[]): boolean {\n    const { multiSelect, hoisted } = this.props;\n    const selectAllOption = hoisted.currentOptions.find(\n      option => option.itemType === SelectableOptionMenuItemType.SelectAll,\n    );\n    const selectedIndices = testIndices || hoisted.selectedIndices;\n\n    if (!multiSelect || !selectedIndices || !selectAllOption) {\n      return false;\n    }\n\n    // start by not including the select all option itself\n    const selectAllIndex = hoisted.currentOptions.indexOf(selectAllOption);\n    const compareSelectedIndices = selectedIndices.filter(value => value !== selectAllIndex);\n\n    // get array of selectable options, excluding disabled options, headers, and dividers\n    const selectableOptions = hoisted.currentOptions.filter(\n      option =>\n        !option.disabled && option.itemType !== SelectableOptionMenuItemType.SelectAll && isSelectableOption(option),\n    );\n\n    return compareSelectedIndices.length === selectableOptions.length;\n  }\n\n  /**\n   * Gets the pending selected index taking into account valueValidIndex and selectedIndex\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n   * finding the index\n   */\n  private _getPendingSelectedIndex(includeCurrentPendingValue: boolean): number {\n    const { currentPendingValueValidIndex, currentPendingValue } = this.state;\n\n    return currentPendingValueValidIndex >= 0 ||\n      (includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined)\n      ? currentPendingValueValidIndex\n      : this.props.multiSelect\n      ? 0\n      : this._getFirstSelectedIndex();\n  }\n\n  /**\n   * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n   */\n  private _onCalloutMouseDown: ICalloutProps['onMouseDown'] = ev => {\n    ev.preventDefault();\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = () => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    if (this.props.calloutProps?.onScroll) {\n      this.props.calloutProps.onScroll();\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, ScrollIdleDelay);\n  };\n\n  /**\n   * Scroll the selected element into view\n   */\n  private _scrollIntoView(): void {\n    const { onScrollToItem, scrollSelectedToTop } = this.props;\n\n    const currentPendingSelectedIndex = this._getPendingSelectedIndex(true);\n\n    if (onScrollToItem) {\n      // Use the custom scroll handler\n      onScrollToItem(currentPendingSelectedIndex >= 0 ? currentPendingSelectedIndex : this._getFirstSelectedIndex());\n      return;\n    }\n\n    let scrollToElement: HTMLElement | null = this._selectedElement.current as HTMLElement;\n\n    // in multi-select there are multiple selected elements, so we use the pending select index\n    // to locate the option to scroll to.\n    if (this.props.multiSelect && this._comboBoxMenu.current) {\n      scrollToElement = findFirstDescendant(this._comboBoxMenu.current, (element: HTMLElement) => {\n        return element.dataset?.index === currentPendingSelectedIndex.toString();\n      });\n    }\n\n    if (scrollToElement && scrollToElement.offsetParent) {\n      let alignToTop = true;\n\n      // We are using refs, scroll the ref into view\n      if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n        const scrollableParent = this._comboBoxMenu.current.offsetParent;\n        const selectedElement = scrollToElement.offsetParent;\n\n        const { offsetHeight, offsetTop } = selectedElement as HTMLElement;\n        const { offsetHeight: parentOffsetHeight, scrollTop } = scrollableParent as HTMLElement;\n\n        const isAbove = offsetTop < scrollTop;\n        const isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;\n\n        if (isAbove || scrollSelectedToTop) {\n          alignToTop = false;\n          scrollableParent.scrollTo(0, offsetTop);\n        } else if (isBelow) {\n          scrollableParent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);\n        }\n      }\n\n      // if _comboboxMenu doesn't exist, fall back to scrollIntoView\n      else {\n        scrollToElement.offsetParent.scrollIntoView(alignToTop);\n      }\n    }\n  }\n\n  private _onRenderOptionContent = (item: IComboBoxOption): JSX.Element => {\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    return <span className={optionClassNames.optionText}>{item.text}</span>;\n  };\n\n  /**\n   * Click handler for the menu items\n   * to select the item and also close the menu\n   * @param index - the index of the item that was clicked\n   */\n  private _onItemClick(item: IComboBoxOption): (ev: React.MouseEvent<any>) => void {\n    const { onItemClick } = this.props;\n    const { index } = item;\n    return (ev: React.MouseEvent<any>): void => {\n      // only close the callout when it's in single-select mode\n      if (!this.props.multiSelect) {\n        // ensure that focus returns to the input, not the button\n        this._autofill.current && this._autofill.current.focus();\n        this.setState({\n          isOpen: false,\n        });\n      }\n\n      // Continue processing the click only after\n      // performing menu close / control focus(inner working)\n      onItemClick && onItemClick(ev, item, index);\n      this._setSelectedIndex(index as number, ev);\n    };\n  }\n\n  /**\n   * Handles dismissing (cancelling) the menu\n   */\n  private _onDismiss = (): void => {\n    const { onMenuDismiss } = this.props;\n    if (onMenuDismiss) {\n      onMenuDismiss();\n    }\n\n    // In persistMode we need to simulate callout layer mount\n    // since that only happens once. We do it on dismiss since\n    // it works either way.\n    if (this.props.persistMenu) {\n      this._onCalloutLayerMounted();\n    }\n\n    // close the menu\n    this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);\n\n    // reset the selected index\n    // to the last value state\n    this._resetSelectedIndex();\n  };\n\n  /**\n   * Reset the selected index by clearing the\n   * input (of any pending text), clearing the pending state,\n   * and setting the suggested display value to the last\n   * selected state text\n   */\n  private _resetSelectedIndex(): void {\n    const { currentOptions } = this.props.hoisted;\n    this._clearPendingInfo();\n\n    const selectedIndex: number = this._getFirstSelectedIndex();\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n      this.props.hoisted.setSuggestedDisplayValue(currentOptions[selectedIndex].text);\n    } else if (this.props.text) {\n      // If we had a value initially, restore it\n      this.props.hoisted.setSuggestedDisplayValue(this.props.text);\n    }\n  }\n\n  /**\n   * Clears the pending info state\n   */\n  private _clearPendingInfo(): void {\n    this._processingClearPendingInfo = true;\n\n    this.props.hoisted.setSuggestedDisplayValue(undefined);\n    this.setState(\n      {\n        currentPendingValue: undefined,\n        currentPendingValueValidIndex: -1,\n        currentPendingValueValidIndexOnHover: HoverStatus.default,\n      },\n      this._onAfterClearPendingInfo,\n    );\n  }\n\n  private _onAfterClearPendingInfo = () => {\n    this._processingClearPendingInfo = false;\n  };\n\n  /**\n   * Set the pending info\n   * @param currentPendingValue - new pending value to set\n   * @param currentPendingValueValidIndex - new pending value index to set\n   * @param suggestedDisplayValue - new suggest display value to set\n   */\n  private _setPendingInfo(\n    currentPendingValue?: string,\n    currentPendingValueValidIndex: number = -1,\n    suggestedDisplayValue?: string,\n  ): void {\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    this.props.hoisted.setSuggestedDisplayValue(suggestedDisplayValue);\n    this.setState({\n      currentPendingValue: normalizeToString(currentPendingValue),\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    });\n  }\n\n  /**\n   * Set the pending info from the given index\n   * @param index - the index to set the pending info from\n   */\n  private _setPendingInfoFromIndex(index: number): void {\n    const { currentOptions } = this.props.hoisted;\n\n    if (index >= 0 && index < currentOptions.length) {\n      const option = currentOptions[index];\n      this._setPendingInfo(getPreviewText(option), index, getPreviewText(option));\n    } else {\n      this._clearPendingInfo();\n    }\n  }\n\n  /**\n   * Sets the pending info for the combo box\n   * @param index - the index to search from\n   * @param searchDirection - the direction to search\n   */\n  private _setPendingInfoFromIndexAndDirection(index: number, searchDirection: SearchDirection): void {\n    const { currentOptions } = this.props.hoisted;\n\n    // update index to allow content to wrap\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n      index = -1;\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\n      index = currentOptions.length;\n    }\n\n    // get the next \"valid\" index\n    const indexUpdate = this._getNextSelectableIndex(index, searchDirection);\n\n    // if the two indices are equal we didn't move and\n    // we should attempt to get  get the first/last \"valid\" index to use\n    // (Note, this takes care of the potential cases where the first/last\n    // item is not focusable), otherwise use the updated index\n    if (index === indexUpdate) {\n      if (searchDirection === SearchDirection.forward) {\n        index = this._getNextSelectableIndex(-1, searchDirection);\n      } else if (searchDirection === SearchDirection.backward) {\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n      }\n    } else {\n      index = indexUpdate;\n    }\n\n    if (indexWithinBounds(currentOptions, index)) {\n      this._setPendingInfoFromIndex(index);\n    }\n  }\n\n  private _notifyPendingValueChanged(prevState: IComboBoxState): void {\n    const { onPendingValueChanged } = this.props;\n\n    if (!onPendingValueChanged) {\n      return;\n    }\n\n    const { currentOptions } = this.props.hoisted;\n    const { currentPendingValue, currentPendingValueValidIndex, currentPendingValueValidIndexOnHover } = this.state;\n\n    let newPendingIndex: number | undefined = undefined;\n    let newPendingValue: string | undefined = prevState.currentPendingValue;\n\n    if (\n      currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&\n      indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)\n    ) {\n      // Set new pending index if hover index was changed\n      newPendingIndex = currentPendingValueValidIndexOnHover;\n    } else if (\n      currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&\n      indexWithinBounds(currentOptions, currentPendingValueValidIndex)\n    ) {\n      // Set new pending index if currentPendingValueValidIndex was changed\n      newPendingIndex = currentPendingValueValidIndex;\n    } else if (currentPendingValue !== prevState.currentPendingValue) {\n      // Set pendingValue in the case it was changed and no index was changed\n      newPendingValue = currentPendingValue;\n    }\n\n    // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n      onPendingValueChanged(\n        newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined,\n        newPendingIndex,\n        newPendingValue,\n      );\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n    }\n  }\n\n  /**\n   * Sets the isOpen state and updates focusInputAfterClose\n   */\n  private _setOpenStateAndFocusOnClose(isOpen: boolean, focusInputAfterClose: boolean): void {\n    this._focusInputAfterClose = focusInputAfterClose;\n    this.setState({\n      isOpen: isOpen,\n    });\n  }\n\n  /**\n   * Handle keydown on the input\n   * @param ev - The keyboard event that was fired\n   */\n  private _onInputKeyDown = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const {\n      disabled,\n      allowFreeform,\n      autoComplete,\n      hoisted: { currentOptions },\n    } = this.props;\n    const { isOpen, currentPendingValueValidIndexOnHover } = this.state;\n\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _onInputKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = isAltOrMeta(ev);\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    let index = this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.enter:\n        if (this._autofill.current && this._autofill.current.inputElement) {\n          this._autofill.current.inputElement.select();\n        }\n\n        this._submitPendingValue(ev);\n        if (this.props.multiSelect && isOpen) {\n          this.setState({\n            currentPendingValueValidIndex: index,\n          });\n        } else {\n          // On enter submit the pending value\n          if (\n            isOpen ||\n            ((!allowFreeform ||\n              this.state.currentPendingValue === undefined ||\n              this.state.currentPendingValue === null ||\n              this.state.currentPendingValue.length <= 0) &&\n              this.state.currentPendingValueValidIndex < 0)\n          ) {\n            // if we are open or\n            // if we are not allowing freeform or\n            // our we have no pending value\n            // and no valid pending index\n            // flip the open state\n            this.setState({\n              isOpen: !isOpen,\n            });\n          }\n        }\n        break;\n\n      case KeyCodes.tab:\n        // On enter submit the pending value\n        if (!this.props.multiSelect) {\n          this._submitPendingValue(ev);\n        }\n\n        // If we are not allowing freeform\n        // or the combo box is open, flip the open state\n        if (isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n        }\n\n        // Allow TAB to propagate\n        return;\n\n      case KeyCodes.escape:\n        // reset the selected index\n        this._resetSelectedIndex();\n\n        // Close the menu if opened\n        if (isOpen) {\n          this.setState({\n            isOpen: false,\n          });\n        } else {\n          return;\n        }\n        break;\n\n      case KeyCodes.up:\n        // if we are in clearAll state (e.g. the user as hovering\n        // and has since mousedOut of the menu items),\n        // go to the last index\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n          index = this.props.hoisted.currentOptions.length;\n        }\n\n        if (ev.altKey || ev.metaKey) {\n          // Close the menu if it is open and break so\n          // that the event get stopPropagation and prevent default.\n          // Otherwise, we need to let the event continue to propagate\n          if (isOpen) {\n            this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n            break;\n          }\n\n          return;\n        }\n\n        // do not scroll page\n        ev.preventDefault();\n\n        // Go to the previous option\n        this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n        break;\n\n      case KeyCodes.down:\n        // Expand the combo box on ALT + DownArrow\n        if (ev.altKey || ev.metaKey) {\n          this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\n        } else {\n          // if we are in clearAll state (e.g. the user as hovering\n          // and has since mousedOut of the menu items),\n          // go to the first index\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            index = -1;\n          }\n\n          // do not scroll page\n          ev.preventDefault();\n\n          // Got to the next option\n          this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n        }\n        break;\n\n      case KeyCodes.home:\n      case KeyCodes.end:\n        if (allowFreeform) {\n          return;\n        }\n\n        // Set the initial values to respond to HOME\n        // which goes to the first selectable option\n        index = -1;\n        let directionToSearch = SearchDirection.forward;\n\n        // If end, update the values to respond to END\n        // which goes to the last selectable option\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.which === KeyCodes.end) {\n          index = currentOptions.length;\n          directionToSearch = SearchDirection.backward;\n        }\n\n        this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n        break;\n\n      /* eslint-disable no-fallthrough */\n      case KeyCodes.space:\n        // event handled in _onComboBoxKeyUp\n        if (!allowFreeform && autoComplete === 'off') {\n          break;\n        }\n\n      default:\n        /* eslint-enable no-fallthrough */\n        // are we processing a function key? if so bail out\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\n          return;\n        }\n\n        // If we get here and we got either and ALT key\n        // or meta key, let the event propagate\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta' /* && isOpen */) {\n          return;\n        }\n\n        // If we are not allowing freeform and\n        // allowing autoComplete, handle the input here\n        // since we have marked the input as readonly\n        if (!allowFreeform && autoComplete === 'on') {\n          this._onInputChange(ev.key);\n          break;\n        }\n\n        // allow the key to propagate by default\n        return;\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  /**\n   * Handle keyup on the input\n   * @param ev - the keyboard event that was fired\n   */\n  private _onInputKeyUp = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const { disabled, allowFreeform, autoComplete } = this.props;\n    const isOpen = this.state.isOpen;\n\n    // We close the menu on key up only if ALL of the following are true:\n    // - Most recent key down was alt or meta (command)\n    // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n    //   expand/collapse the menu)\n    // - We're not on a Mac (or iOS)\n    // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n    // closing any open context menus. There is not a similar behavior on Macs.\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    const shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.space:\n        // If we are not allowing freeform and are not autoComplete\n        // make space expand/collapse the combo box\n        // and allow the event to propagate\n        if (!allowFreeform && autoComplete === 'off') {\n          this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n        }\n        return;\n      default:\n        if (shouldHandleKey && isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n        } else {\n          if (this.state.focusState === 'focusing' && this.props.openOnKeyboardFocus) {\n            this.setState({ isOpen: true });\n          }\n          if (this.state.focusState !== 'focused') {\n            this.setState({ focusState: 'focused' });\n          }\n        }\n        return;\n    }\n  };\n\n  private _onOptionMouseEnter(index: number): void {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseMove(index: number): void {\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseLeave = () => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    // Ignore the event in persistMenu mode if the callout has\n    // closed. This is to avoid clearing the visuals on item click.\n    if (this.props.persistMenu && !this.state.isOpen) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: HoverStatus.clearAll,\n    });\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  /**\n   * Handle dismissing the menu and eating the required key event when disabled\n   * @param ev - the keyboard event that was fired\n   */\n  private _handleInputWhenDisabled(ev: React.KeyboardEvent<HTMLElement | Autofill> | null): void {\n    // If we are disabled, close the menu (if needed)\n    // and eat all keystrokes other than TAB or ESC\n    if (this.props.disabled) {\n      if (this.state.isOpen) {\n        this.setState({ isOpen: false });\n      }\n\n      // When disabled stop propagation and prevent default\n      // of the event unless we have a tab, escape, or function key\n      if (\n        ev !== null &&\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which !== KeyCodes.tab &&\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which !== KeyCodes.escape &&\n        // eslint-disable-next-line deprecation/deprecation\n        (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */\n      ) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    }\n  }\n\n  /**\n   * Click handler for the button of the combo box and the input when not allowing freeform.\n   * This toggles the expand/collapse state of the combo box (if enabled).\n   */\n  private _onComboBoxClick = (): void => {\n    const { disabled } = this.props;\n    const { isOpen } = this.state;\n\n    if (!disabled) {\n      this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Click handler for the autofill.\n   */\n  private _onAutofillClick = (): void => {\n    const { disabled, allowFreeform } = this.props;\n    if (allowFreeform && !disabled) {\n      this.focus(this.state.isOpen || this._processingTouch);\n    } else {\n      this._onComboBoxClick();\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (this._comboBoxWrapper.current && !('onpointerdown' in this._comboBoxWrapper)) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCaretButtonStyles(): IButtonStyles {\n    const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;\n    return getCaretDownButtonStyles(this.props.theme!, customCaretDownButtonStyles);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCurrentOptionStyles(item: IComboBoxOption): Partial<IComboBoxOptionStyles> {\n    const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;\n    const { styles: customStylesForCurrentOption } = item;\n\n    return getOptionStyles(\n      this.props.theme!,\n      customStylesForAllOptions,\n      customStylesForCurrentOption,\n      this._isPendingOption(item),\n      item.hidden,\n      this._isOptionHighlighted(item.index),\n    );\n  }\n\n  /**\n   * Get the aria-activedescendant value for the combo box.\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n   * null otherwise\n   */\n  private _getAriaActiveDescendantValue(): string | undefined {\n    const { selectedIndices } = this.props.hoisted;\n    const { isOpen, currentPendingValueValidIndex } = this.state;\n    let descendantText = isOpen && selectedIndices?.length ? this._id + '-list' + selectedIndices[0] : undefined;\n    if (isOpen && this._hasFocus() && currentPendingValueValidIndex !== -1) {\n      descendantText = this._id + '-list' + currentPendingValueValidIndex;\n    }\n    return descendantText;\n  }\n\n  /**\n   * Get the aria autocomplete value for the combo box\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n   * and can dynamically populate input, and 'list' if auto-complete is not enabled as selection is the only option.\n   * Ideally, this should be 'none' if auto-complete is not enabled, but there is a known bug in Edge\n   * where the callout may appear over the combo box if this attribute is set to 'none'\n   */\n  private _getAriaAutoCompleteValue(): 'none' | 'inline' | 'list' | 'both' | undefined {\n    const autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n    return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'list';\n  }\n\n  private _isPendingOption(item: IComboBoxOption): boolean {\n    return item && item.index === this.state.currentPendingValueValidIndex;\n  }\n\n  /**\n   * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n   */\n  private _hasFocus() {\n    return this.state.focusState !== 'none';\n  }\n}\n\n/**\n * Get the indices of the options that are marked as selected\n * @param options - the combo box options\n * @param selectedKeys - the known selected keys to find\n * @returns - an array of the indices of the selected options, empty array if nothing is selected\n */\nfunction getSelectedIndices(\n  options: IComboBoxOption[] | undefined,\n  selectedKeys: (string | number | undefined)[],\n): number[] {\n  if (!options || !selectedKeys) {\n    return [];\n  }\n\n  const selectedIndices: { [key: number]: boolean } = {};\n  options.forEach((option: IComboBoxOption, index: number) => {\n    if (option.selected) {\n      selectedIndices[index] = true;\n    }\n  });\n\n  for (const selectedKey of selectedKeys) {\n    const index = findIndex(options, option => option.key === selectedKey);\n    if (index > -1) {\n      selectedIndices[index] = true;\n    }\n  }\n\n  return Object.keys(selectedIndices).map(Number).sort();\n}\n\n/**\n * Given default selected key(s) and selected key(s), return the selected keys(s).\n * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n *\n * @returns No matter what specific types the input parameters are, always return an array of\n *  either strings or numbers instead of primitive type.  This normalization makes caller's logic easier.\n */\nfunction buildDefaultSelectedKeys(\n  defaultSelectedKey: string | number | string[] | number[] | null | undefined,\n  selectedKey: string | number | string[] | number[] | null | undefined,\n): string[] | number[] {\n  const selectedKeys: string[] | number[] = buildSelectedKeys(defaultSelectedKey);\n  if (selectedKeys.length) {\n    return selectedKeys;\n  }\n  return buildSelectedKeys(selectedKey);\n}\n\nfunction buildSelectedKeys(selectedKey: string | number | string[] | number[] | null | undefined): string[] | number[] {\n  if (selectedKey === undefined) {\n    return [];\n  }\n\n  // need to cast here so typescript does not complain\n  return (selectedKey instanceof Array ? selectedKey : [selectedKey]) as string[] | number[];\n}\n\nfunction normalizeToString(value: string | undefined) {\n  return value || '';\n}\n\n/**\n * Is the index within the bounds of the array?\n * @param options - options to check if the index is valid for\n * @param index - the index to check\n * @returns - true if the index is valid for the given options, false otherwise\n */\nfunction indexWithinBounds(options: IComboBoxOption[] | undefined, index: number): boolean {\n  return !!options && index >= 0 && index < options.length;\n}\n\n/** Whether this is a normal option, not a header or divider or select all. */\nfunction isNormalOption(option: IComboBoxOption) {\n  return (\n    option.itemType !== SelectableOptionMenuItemType.Header &&\n    option.itemType !== SelectableOptionMenuItemType.Divider &&\n    option.itemType !== SelectableOptionMenuItemType.SelectAll\n  );\n}\n\n/** Whether this is a selectable option, not a header or divider. */\nfunction isSelectableOption(option: IComboBoxOption) {\n  return (\n    option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider\n  );\n}\n\n/**\n * For scenarios where the option's `text` prop contains embedded styles, we use the option's\n * `ariaLabel` value as the text in the input and for autocomplete matching. We know to use this\n * when the `useAriaLabelAsText` prop is set to true.\n */\nfunction getPreviewText(item: IComboBoxOption): string {\n  return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n}\n\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\nfunction isAltOrMeta(ev: React.KeyboardEvent<HTMLElement | Autofill>): boolean {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}