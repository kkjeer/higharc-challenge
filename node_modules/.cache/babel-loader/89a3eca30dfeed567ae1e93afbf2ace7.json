{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\n\nvar Autofill =\n/** @class */\nfunction (_super) {\n  __extends(Autofill, _super);\n\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n    _this._onCompositionStart = function (ev) {\n      _this.setState({\n        isComposing: true\n      });\n\n      _this._autoFillEnabled = false;\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n\n      _this.setState({\n        isComposing: false\n      }); // Due to timing, this needs to be async, otherwise no text will be selected.\n\n\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n\n    _this._onClick = function () {\n      if (_this.value && _this.value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n\n      if (!ev.nativeEvent.isComposing) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this.setState({\n                inputValue: _this.props.suggestedDisplayValue || ''\n              });\n\n              _this._autoFillEnabled = false;\n            }\n\n            break;\n\n          default:\n            if (!_this._autoFillEnabled) {\n              // eslint-disable-next-line deprecation/deprecation\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n\n            break;\n        }\n      }\n    };\n\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n\n      if (!_this.state.isComposing) {\n        _this._tryEnableAutofill(value, _this.value, ev.nativeEvent.isComposing);\n      } // If it is not IE11 and currently composing, update the value\n\n\n      if (!(isIE11() && _this.state.isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this.state.isComposing : nativeEventComposing;\n\n        _this._updateValue(value, isComposing);\n      }\n    };\n\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n\n\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this.value) {\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var _a = _this.props,\n          onInputChange = _a.onInputChange,\n          onInputValueChange = _a.onInputValueChange;\n\n      if (onInputChange) {\n        newValue = (onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(newValue, composing)) || '';\n      }\n\n      _this.setState({\n        inputValue: newValue\n      }, function () {\n        return onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing);\n      });\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false\n    };\n    return _this;\n  }\n\n  Autofill.getDerivedStateFromProps = function (props, state) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      var updatedInputValue = props.updateValueInWillReceiveProps(); // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return __assign(__assign({}, state), {\n          inputValue: updatedInputValue\n        });\n      }\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function () {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function () {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function () {\n      return this._getControlledValue() || this.state.inputValue || '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function () {\n      return this._inputElement.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Autofill.prototype.componentDidUpdate = function (_, _1, cursor) {\n    var _a = this.props,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        shouldSelectFullInputValueInComponentDidUpdate = _a.shouldSelectFullInputValueInComponentDidUpdate,\n        preventValueSelection = _a.preventValueSelection;\n    var differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (this._autoFillEnabled && this.value && suggestedDisplayValue && _doesTextStartWith(suggestedDisplayValue, this.value)) {\n      var shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < this.value.length && this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  };\n\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n\n  Autofill.prototype.render = function () {\n    var nativeProps = getNativeProps(this.props, inputProperties);\n\n    var style = __assign(__assign({}, this.props.style), {\n      fontFamily: 'inherit'\n    });\n\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      style: style,\n      ref: this._inputElement,\n      value: this._getDisplayValue(),\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n\n    this._updateValue('', false);\n\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n\n  Autofill.prototype.getSnapshotBeforeUpdate = function () {\n    var _a, _b;\n\n    var inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: (_a = inel.selectionStart) !== null && _a !== void 0 ? _a : inel.value.length,\n        end: (_b = inel.selectionEnd) !== null && _b !== void 0 ? _b : inel.value.length,\n        dir: inel.selectionDirection || 'backward' || 'none'\n      };\n    }\n\n    return null;\n  };\n\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n\n\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n\n  Autofill.prototype._getDisplayValue = function () {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  };\n\n  Autofill.prototype._getControlledValue = function () {\n    var value = this.props.value;\n\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    } // eslint-disable-next-line no-console\n\n\n    console.warn(\"props.value of Autofill should be a string, but it is \" + value + \" with type of \" + typeof value);\n    return value.toString();\n  };\n\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  return Autofill;\n}(React.Component);\n\nexport { Autofill };\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\n\nfunction _getDisplayValue(inputValue, suggestedDisplayValue) {\n  var displayValue = inputValue;\n\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text, startWith) {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (var _i = 0, _a = [text, startWith]; _i < _a.length; _i++) {\n      var val = _a[_i];\n\n      if (typeof val !== 'string') {\n        throw new Error(Autofill.name + \" received non-string value \\\"\" + val + \"\\\" of type \" + typeof val + \" from either input's value or suggestedDisplayValue\");\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}","map":{"version":3,"sources":["components/Autofill/Autofill.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nimport type { IAutofill, IAutofillProps } from './Autofill.types';\n\nexport interface IAutofillState {\n  inputValue: string;\n  isComposing: boolean;\n}\n\ninterface ICursorLocation {\n  start: number;\n  end: number;\n  dir: 'forward' | 'backward' | 'none' | undefined;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(props: IAutofillProps, state: IAutofillState): IAutofillState | null {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      const updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return { ...state, inputValue: updatedInputValue };\n      }\n    }\n    return null;\n  }\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false,\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._getControlledValue() || this.state.inputValue || '';\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public componentDidUpdate(_: any, _1: any, cursor: ICursorLocation | null) {\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (\n      this._autoFillEnabled &&\n      this.value &&\n      suggestedDisplayValue &&\n      _doesTextStartWith(suggestedDisplayValue, this.value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < this.value.length &&\n          this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    const style = { ...this.props.style, fontFamily: 'inherit' };\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        style={style}\n        ref={this._inputElement}\n        value={this._getDisplayValue()}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  public getSnapshotBeforeUpdate(): ICursorLocation | null {\n    const inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: inel.selectionStart ?? inel.value.length,\n        end: inel.selectionEnd ?? inel.value.length,\n        dir: (inel.selectionDirection as 'forward') || 'backward' || 'none',\n      };\n    }\n    return null;\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this.setState({ isComposing: true });\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this.setState({ isComposing: false });\n\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this.value && this.value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n    if (!(ev.nativeEvent as any).isComposing) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this.setState({ inputValue: this.props.suggestedDisplayValue || '' });\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this.state.isComposing) {\n      this._tryEnableAutofill(value, this.value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this.state.isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this.state.isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as HTMLInputElement).value) {\n      return (ev.target as HTMLInputElement).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this.value) {\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { onInputChange, onInputValueChange } = this.props;\n    if (onInputChange) {\n      newValue = onInputChange?.(newValue, composing) || '';\n    }\n\n    this.setState({ inputValue: newValue }, () => onInputValueChange?.(newValue, composing));\n  };\n\n  private _getDisplayValue(): string {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  }\n\n  private _getControlledValue(): string | undefined {\n    const { value } = this.props;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(`props.value of Autofill should be a string, but it is ${value} with type of ${typeof value}`);\n\n    return value.toString();\n  }\n}\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n  let displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text: string, startWith: string): boolean {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (const val of [text, startWith]) {\n      if (typeof val !== 'string') {\n        throw new Error(\n          `${\n            Autofill.name\n            // eslint-disable-next-line @fluentui/max-len\n          } received non-string value \"${val}\" of type ${typeof val} from either input's value or suggestedDisplayValue`,\n        );\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}