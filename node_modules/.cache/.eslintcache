[{"C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\index.tsx":"1","C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\reportWebVitals.ts":"2","C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\App.tsx":"3","C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\AddSmoothie.tsx":"4","C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\ViewSmoothies.tsx":"5","C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\types.ts":"6"},{"size":151,"mtime":1652420686716,"results":"7","hashOfConfig":"8"},{"size":425,"mtime":1652404053034,"results":"9","hashOfConfig":"8"},{"size":2048,"mtime":1652426097820,"results":"10","hashOfConfig":"8"},{"size":9913,"mtime":1652426032685,"results":"11","hashOfConfig":"8"},{"size":4067,"mtime":1652426085847,"results":"12","hashOfConfig":"8"},{"size":285,"mtime":1652425157610,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"1l29hgk",{"filePath":"17","messages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"22","messages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24"},{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\index.tsx",[],["30","31"],"C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\reportWebVitals.ts",[],["32","33"],"C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\App.tsx",[],"C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\AddSmoothie.tsx",["34","35","36","37"],"import * as React from \"react\";\r\nimport { Smoothies, IIngredient, ISmoothie, UNITS } from \"./types\";\r\nimport { Stack, Text, TextField, DefaultButton, IconButton, PrimaryButton, Dropdown, IDropdownOption } from \"@fluentui/react\";\r\n\r\ninterface IAddSmoothieProps {\r\n  smoothies: Smoothies;\r\n  onAddSmoothie: (name: string, smoothie: ISmoothie) => void;\r\n}\r\n\r\ninterface IAddSmoothieState {\r\n  name: string;\r\n  ingredients: IIngredient[];\r\n  tags: string[];\r\n  currTag: string;\r\n}\r\n\r\nconst EMPTY_INGREDIENT = {\r\n  name: \"\",\r\n  quantity: \"0\",\r\n  unit: UNITS[0]\r\n};\r\n\r\n/**\r\n * Renders UI that allows the user to add or edit one new smoothie at a time.\r\n */\r\nexport class AddSmoothie extends React.Component<IAddSmoothieProps, IAddSmoothieState> {\r\n  constructor(props: IAddSmoothieProps) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      name: \"\",\r\n      ingredients: [EMPTY_INGREDIENT],\r\n      tags: [],\r\n      currTag: \"\"\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const { name, ingredients, tags, currTag } = this.state;\r\n\r\n    const ingredientError = !this._checkIngredients();\r\n\r\n    return (\r\n      <Stack\r\n        className=\"card\"\r\n        tokens={{childrenGap: 10}}\r\n        horizontalAlign=\"start\"\r\n        styles={{root: {\r\n          padding: 10,\r\n          alignSelf: \"flex-start\"\r\n        }}}>\r\n        <Text variant=\"large\">Add a smoothie</Text>\r\n        <Stack horizontal verticalAlign=\"end\" tokens={{childrenGap: 10}}>\r\n          <TextField\r\n            label=\"Smoothie name\"\r\n            value={name}\r\n            required\r\n            onChange={this._changeSmoothieName}\r\n            errorMessage={this._isNameConflict() ? \"A smoothie with this name already exists.\" : \"\"}\r\n          />\r\n          <PrimaryButton\r\n            text=\"Add smoothie\"\r\n            onClick={this._addSmoothie}\r\n            disabled={this._isNameConflict() || !name || ingredients.length < 1 || ingredientError}\r\n          />\r\n          <Stack tokens={{childrenGap: 5}} styles={{root: {maxWidth: 250}}}>\r\n            {\r\n              !name &&\r\n              <Text className=\"errorText\">\r\n                Smoothie must have a nonempty name.\r\n              </Text>\r\n            }\r\n            {\r\n              ingredients.length < 1 &&\r\n              <Text className=\"errorText\">\r\n                Smoothie must have at least one ingredient.\r\n              </Text>\r\n            }\r\n            {\r\n              ingredientError &&\r\n              <Text className=\"errorText\">\r\n                All ingredients must have a nonempty name and a positive numerical quantity.\r\n              </Text>\r\n            }\r\n          </Stack>\r\n        </Stack>\r\n        {ingredients.map((ingredient: IIngredient, index: number) => this._ingredient(ingredient, index))}\r\n        <DefaultButton text=\"Add ingredient\" onClick={this._addIngredient} />\r\n        <TextField\r\n          placeholder=\"Add tags (optional)\"\r\n          underlined\r\n          value={currTag}\r\n          errorMessage={this._duplicateTag() ? \"Tag already exists.\" : \"\"}\r\n          onChange={this._changeCurrTag}\r\n          onKeyDown={this._addTag}\r\n        />\r\n        <Stack\r\n          horizontal\r\n          wrap\r\n          tokens={{childrenGap: 10}}\r\n          styles={{root: { maxWidth: 550 }}}>\r\n          {tags.map((tag, index) => this._tag(tag, index))}\r\n        </Stack>\r\n      </Stack>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Event handler for changing the pending name of the smoothie to add.\r\n   */\r\n  _changeSmoothieName = (ev: any, val?: string) => {\r\n    this.setState({ name: val || \"\" });\r\n  }\r\n\r\n  /**\r\n   * Event handler to add the current pending smoothie.\r\n   */\r\n  _addSmoothie = (ev: any) => {\r\n    const { onAddSmoothie } = this.props;\r\n    const { name, ingredients, tags } = this.state;\r\n\r\n    const smoothie = {\r\n      ingredients: ingredients.filter(ingredient => ingredient.name != \"\").map(ingredient => ({\r\n        ...ingredient,\r\n        unit: ingredient.unit || UNITS[0]\r\n      })),\r\n      tags\r\n    };\r\n\r\n    onAddSmoothie(name, smoothie);\r\n    this.setState({\r\n      name: \"\",\r\n      ingredients: [EMPTY_INGREDIENT],\r\n      tags: [],\r\n      currTag: \"\"\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Renders the UI to construct a single pending ingredient.\r\n   */\r\n  _ingredient = (ingredient: IIngredient, index: number) => {\r\n    const quantityErrorMsg = isNaN(Number(ingredient.quantity || \"0\")) ? \"Quantity must be a number.\" : \"\";\r\n\r\n    return (\r\n      <Stack key={index} horizontal verticalAlign=\"end\" tokens={{childrenGap: 10}}>\r\n        <TextField\r\n          label=\"Ingredient name\"\r\n          value={ingredient.name}\r\n          required\r\n          onChange={this._changeIngredientName(index)}\r\n        />\r\n        <TextField\r\n          label=\"Quantity\"\r\n          value={ingredient.quantity}\r\n          required\r\n          onChange={this._changeIngredientQuantity(index)}\r\n          errorMessage={quantityErrorMsg}\r\n        />\r\n        <Dropdown\r\n          label=\"Unit\"\r\n          options={UNITS.map(unit => ({ key: unit, text: unit }))}\r\n          selectedKey={ingredient.unit || UNITS[0]}\r\n          onChange={this._changeUnit(index)}\r\n          styles={{\r\n            root: {\r\n              minWidth: 80\r\n            }\r\n          }}\r\n        />\r\n        <IconButton iconProps={{iconName: \"Delete\"}} onClick={this._deleteIngredient(index)} />\r\n      </Stack>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Event handler to add a new blank pending ingredient.\r\n   */\r\n  _addIngredient = (ev: any) => {\r\n    const ingredients = [...this.state.ingredients, {\r\n      name: \"\",\r\n      quantity: \"0\",\r\n      unit: \"\"\r\n    }];\r\n    this.setState({ ingredients });\r\n  }\r\n\r\n  /**\r\n   * Returns an event handler to change the name of the pending ingredient at the given index.\r\n   */\r\n  _changeIngredientName = (index: number) => {\r\n    return (ev: any, val?: string) => {\r\n      const ingredients = JSON.parse(JSON.stringify(this.state.ingredients));\r\n      ingredients[index].name = val || \"\";\r\n      this.setState({ ingredients });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an event handler to change the quantity of the pending ingredient at the given index.\r\n   */\r\n  _changeIngredientQuantity = (index: number) => {\r\n    return (ev: any, val?: string) => {\r\n      const ingredients = JSON.parse(JSON.stringify(this.state.ingredients));\r\n      ingredients[index].quantity = val || \"\";\r\n      this.setState({ ingredients });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an event handler to change the unit of the pending ingredient at the given index.\r\n   */\r\n  _changeUnit = (index: number) => {\r\n    return (ev: any, option?: IDropdownOption) => {\r\n      if (!option) return;\r\n      const ingredients = [...this.state.ingredients];\r\n      ingredients[index].unit = option.key.toString();\r\n      this.setState({ ingredients });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an event handler to delete the pending ingredient at the given index.\r\n   */\r\n  _deleteIngredient = (index: number) => {\r\n    return (ev: any) => {\r\n      let ingredients = this.state.ingredients;\r\n      ingredients.splice(index, 1);\r\n      this.setState({ ingredients });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Renders the UI for one pending tag.\r\n   * Includes the ability to delete the pending tag.\r\n   */\r\n  _tag = (tag: string, index: number) => {\r\n    const borderRadius = 15;\r\n\r\n    return (\r\n      <Stack\r\n        key={tag}\r\n        horizontal\r\n        verticalAlign=\"center\"\r\n        tokens={{childrenGap: 5}}\r\n        styles={{root: {\r\n          borderRadius,\r\n          backgroundColor: \"#cccccc\",\r\n          paddingRight: 10\r\n        }}}\r\n      >\r\n        <IconButton\r\n          iconProps={{iconName: \"StatusCircleErrorX\"}}\r\n          styles={{root: { borderRadius }}}\r\n          onClick={this._deleteTag(index)}\r\n        />\r\n        <Text>{tag}</Text>\r\n      </Stack>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Event handler for changing the current tag to be added to the set of pending tags.\r\n   */\r\n  _changeCurrTag = (ev: any, val?: string) => {\r\n    this.setState({ currTag: val || \"\" });\r\n  }\r\n\r\n  /**\r\n   * Event handler for adding a tag to the set of pending tags.\r\n   */\r\n  _addTag = (ev: any) => {\r\n    if (ev.key != \"Enter\" || this._duplicateTag()) {\r\n      return;\r\n    }\r\n\r\n    const tags = [...this.state.tags, this.state.currTag];\r\n    this.setState({ tags, currTag: \"\" });\r\n  }\r\n\r\n  /**\r\n   * Returns an event handler for removing the tag at the given index\r\n   * from the set of pending tags.\r\n   */\r\n  _deleteTag = (index: number) => {\r\n    return (ev: any) => {\r\n      const tags = [...this.state.tags];\r\n      tags.splice(index, 1);\r\n      this.setState({ tags });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns true if and only if there is already a smoothie with the same\r\n   * (case-insensitive) name as the name of the pending smoothie.\r\n   */\r\n  _isNameConflict = () => {\r\n    const { smoothies } = this.props;\r\n    const { name } = this.state;\r\n\r\n    if (!name) {\r\n      return false;\r\n    }\r\n\r\n    for (const existingName in smoothies) {\r\n      if (existingName.toLowerCase() == name.toLowerCase()) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns true if and only if all pending ingredients:\r\n   * 1. Have nonempty names, and:\r\n   * 2. Have positive numerical quantities\r\n   */\r\n  _checkIngredients = () => {\r\n    const { ingredients } = this.state;\r\n    for (const i in ingredients) {\r\n      const { name, quantity } = ingredients[i];\r\n      if (!name) {\r\n        return false;\r\n      }\r\n      const quant = Number(quantity);\r\n      if (isNaN(quant) || quant <= 0) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns true if and only if the current tag the user has typed in\r\n   * already exists (case insensitive) in the set of pending tags.\r\n   */\r\n  _duplicateTag = () => {\r\n    const { currTag, tags } = this.state;\r\n    for (const i in tags) {\r\n      if (tags[i].toLowerCase() == currTag.toLowerCase()) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\ViewSmoothies.tsx",["38"],"import * as React from \"react\";\r\nimport { Stack, Text, IconButton, SearchBox } from \"@fluentui/react\";\r\nimport { Smoothies, IIngredient } from \"./types\";\r\n\r\ninterface IViewSmoothiesProps {\r\n  smoothies: Smoothies;\r\n  onDeleteSmoothie: (name: string) => void;\r\n}\r\n\r\ninterface IViewSmoothiesState {\r\n  searchName: string;\r\n}\r\n\r\n/**\r\n * Renders a set of smoothies in a grid view.\r\n * Each smoothie UI contains the capability to delete that smoothie.\r\n */\r\nexport class ViewSmoothies extends React.Component<IViewSmoothiesProps, IViewSmoothiesState> {\r\n  constructor(props: IViewSmoothiesProps) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      searchName: \"\"\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const { smoothies } = this.props;\r\n    const { searchName } = this.state;\r\n\r\n    // If the search text is nonempty, only show smoothies whose names contain (case insensitive) the search text.\r\n    let namesToShow = Object.keys(smoothies);\r\n    if (searchName) {\r\n      namesToShow = namesToShow.filter(name => name.toLowerCase().indexOf(searchName.toLowerCase()) != -1);\r\n    }\r\n    \r\n    return (\r\n      <Stack tokens={{childrenGap: 20}} horizontalAlign=\"start\">\r\n        <SearchBox\r\n          underlined\r\n          placeholder=\"Search for a smoothie by name\"\r\n          onChange={this._searchChange}\r\n          onSearch={this._searchForSmoothie}\r\n          onClear={this._clearSearch}\r\n          styles={{root: {\r\n            minWidth: 250\r\n          }}}\r\n        />\r\n        <Stack\r\n          horizontal\r\n          wrap\r\n          tokens={{childrenGap: 20}}\r\n          horizontalAlign=\"start\">\r\n            {namesToShow.map(name => this._smoothie(name))}\r\n        </Stack>\r\n      </Stack>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Event handler for changing the smoothie name search text.\r\n   */\r\n  _searchChange = (ev: any, val?: string) => {\r\n    this.setState({ searchName: val || \"\" });\r\n  }\r\n\r\n  /**\r\n   * Event handler for pressing Enter on the search box to search smoothies by name.\r\n   */\r\n  _searchForSmoothie = (val?: string) => {\r\n    this.setState({ searchName: val || \"\" });\r\n  }\r\n\r\n  /**\r\n   * Event handler for clearing the smoothie name search text.\r\n   */\r\n  _clearSearch = (ev: any) => {\r\n    this.setState({ searchName: \"\" });\r\n  }\r\n\r\n  /**\r\n   * Renders one smoothie.\r\n   */\r\n  _smoothie = (name: string) => {\r\n    const smoothie = this.props.smoothies[name];\r\n\r\n    return (\r\n      <Stack\r\n        className=\"card\"\r\n        key={name}\r\n        tokens={{childrenGap: 10}}\r\n        styles={{root: {\r\n          padding: 5,\r\n          paddingBottom: 10,\r\n          paddingLeft: 10\r\n        }}}>\r\n          <Stack\r\n            horizontal\r\n            horizontalAlign=\"space-between\"\r\n            verticalAlign=\"center\"\r\n            tokens={{childrenGap: 20}}>\r\n            <Text variant=\"mediumPlus\">{name}</Text>\r\n            <IconButton iconProps={{iconName: \"Delete\"}} onClick={this._deleteSmoothie(name)} />\r\n          </Stack>\r\n          <Stack tokens={{childrenGap: 10}} styles={{root: {paddingLeft: 5}}}>\r\n            {smoothie.ingredients.map(ingredient => this._ingredient(ingredient))}\r\n          </Stack>\r\n          <Stack\r\n            horizontal\r\n            wrap\r\n            tokens={{childrenGap: 5}}\r\n            styles={{root: { maxWidth: 250 }}}>\r\n            {smoothie.tags.map(tag => <Text key={tag} variant=\"small\">#{tag}</Text>)}\r\n          </Stack>\r\n      </Stack>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Renders the information for one ingredient.\r\n   */\r\n  _ingredient = (ingredient: IIngredient) => {\r\n    const { name, quantity, unit } = ingredient;\r\n\r\n    // Remove the last \"s\" in the unit display string if the quantity is 1\r\n    let unitStr = unit;\r\n    if (Number(quantity) === 1) {\r\n      unitStr = unitStr.substring(0, unitStr.length - 1);\r\n    }\r\n\r\n    return <Text key={name}>{quantity} {unitStr} of {name.toLowerCase()}</Text>\r\n  }\r\n\r\n  /**\r\n   * Returns an event handler to delete the smoothie with the given name.\r\n   */\r\n  _deleteSmoothie = (name: string) => {\r\n    return (ev: any) => {\r\n      this.props.onDeleteSmoothie(name);\r\n    }\r\n  }\r\n}","C:\\Users\\kkjee\\Coding\\higharc-challenge\\src\\types.ts",[],{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","replacedBy":"42"},{"ruleId":"39","replacedBy":"43"},{"ruleId":"41","replacedBy":"44"},{"ruleId":"45","severity":1,"message":"46","line":123,"column":69,"nodeType":"47","messageId":"48","endLine":123,"endColumn":71},{"ruleId":"45","severity":1,"message":"46","line":273,"column":16,"nodeType":"47","messageId":"48","endLine":273,"endColumn":18},{"ruleId":"45","severity":1,"message":"49","line":306,"column":38,"nodeType":"47","messageId":"48","endLine":306,"endColumn":40},{"ruleId":"45","severity":1,"message":"49","line":341,"column":33,"nodeType":"47","messageId":"48","endLine":341,"endColumn":35},{"ruleId":"45","severity":1,"message":"46","line":34,"column":101,"nodeType":"47","messageId":"48","endLine":34,"endColumn":103},"no-native-reassign",["50"],"no-negated-in-lhs",["51"],["50"],["51"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","no-global-assign","no-unsafe-negation"]